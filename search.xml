<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习绘画</title>
    <url>/2020/03/12/%E5%AD%A6%E4%B9%A0%E7%BB%98%E7%94%BB/</url>
    <content><![CDATA[<p><img src="/2020/03/12/%E5%AD%A6%E4%B9%A0%E7%BB%98%E7%94%BB/myPic3.png" style="width: 50%"></p>
<center>procreate</center>
<a id="more"></a>

<img src="/2020/03/12/%E5%AD%A6%E4%B9%A0%E7%BB%98%E7%94%BB/myPic1.jpg" style="width: 50%">

<center>procreate</center>

<p><img src="/2020/03/12/%E5%AD%A6%E4%B9%A0%E7%BB%98%E7%94%BB/myPic2.png" style="width: 50%"></p>
<center>sketchbook</center>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF BDCI 海口市交通流量可视化</title>
    <url>/2020/03/12/%E6%B5%B7%E5%8F%A3%E5%B8%82%E4%BA%A4%E9%80%9A%E6%B5%81%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=95709708&cid=163397270&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"> </iframe>
</div>

<a id="more"></a>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>一个想从头截图到尾的游戏Ori</title>
    <url>/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/</url>
    <content><![CDATA[<p><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/7.jpg" style="width: 75%"><br><a id="more"></a><br>    &emsp;&emsp;  昨天奥日与精灵意志发布了！！期待了好久！！！真的太美丽了！还是用unity做的！游戏相比上一部，感觉操作真的更加友好了（也有可能是我选的简单模式，才开始吧，哈哈哈哈），主要感觉跳跃和攀爬比上一部好很多。技能系统也更加丰富，剧情角色更加多样。这一部还有一个就是渲染，真的非常赞，个人感觉在光线和水流方面有很大提升！！<br>    哈哈哈哈，不知道啥时候才能通关，呵呵呵呵<br>    <br></p>
<table border="0">
    <tr>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/1.jpg"></center></td>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/2.jpg"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/3.jpg"></center></td>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/4.jpg"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/5.jpg"></center></td>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/6.jpg"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/7.jpg"></center></td>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/8.jpg"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/9.jpg"></center></td>
        <td><center><img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%83%B3%E4%BB%8E%E5%A4%B4%E6%88%AA%E5%9B%BE%E5%88%B0%E5%B0%BE%E7%9A%84%E6%B8%B8%E6%88%8FOri/10.jpg"></center></td>
    </tr>
</table>]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Offer-Week6</title>
    <url>/2020/07/27/Offer-Week6/</url>
    <content><![CDATA[<h1 id="0到n-1中缺失的数字"><a href="#0到n-1中缺失的数字" class="headerlink" title="0到n-1中缺失的数字"></a>0到n-1中缺失的数字</h1><p>一个长度为<strong>n-1的递增排序数组中的所有数字都是唯一的</strong>，并且每个数字都在范围0到n-1之内。在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>优化时间复杂度，高斯公式——等差数列求和</strong></p>
<p><strong>二分查找</strong></p>
<ol>
<li>左子数组：$nums[i]=i$；</li>
<li>右子数组：$nums[i]\neq i$；</li>
</ol>
<p>缺失数字等于<strong>右子数组的首元素</strong>对应的索引</p>
<p><img src="/2020/07/27/Offer-Week6/01.png"></p>
<ol>
<li><strong>初始化</strong>：左边界$i=0$，右边界$j=nums.size() - 1$；代表区间$[i,j]$</li>
<li><strong>循环二分</strong>：当$i\leq j$时循环<ol>
<li>计算中点$mid=(i+j)/2$</li>
<li>若$nums[mid]=mid$，则表示左子数组元素没有少，执行$i=mid+1$;</li>
<li>若$nums[mid]\neq mid$，则表示左子数组元素缺失，执行$j=mid-1$;</li>
</ol>
</li>
<li><strong>返回值</strong>：变量$i,j$分别指向右子数组首元素和左子数组末尾元素，返回$i$即可</li>
</ol>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (n <span class="number">-1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) res -= x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == mid) i = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中数值和下标相等的元素"><a href="#数组中数值和下标相等的元素" class="headerlink" title="数组中数值和下标相等的元素"></a>数组中数值和下标相等的元素</h1><p>假设一个<strong>单调递增的数组里的每个元素都是整数并且是唯一的</strong>。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:如果不存在，则返回-1。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>二分查找</strong></p>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] - mid &gt;= <span class="number">0</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] - r ==<span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h1><p> 给定一棵二叉搜索树，请找出其中的<strong>第k小的结点</strong>。你可以假设树和k都存在，并且1≤k≤树的总结点数。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, null, null, null, null] ，k = <span class="number">3</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。 </p>
<p>二叉搜索树的<strong>中序遍历的倒序</strong>（右、根、左）为 <strong>递减序列</strong> 。</p>
<p>  求“二叉搜索树第$k$大的节点”可转化为求“此树的中序遍历倒序的第$k$个节点”。 </p>
<p><img src="/2020/07/27/Offer-Week6/02.png"></p>
<ol>
<li><strong>终止条件：</strong>当结点为空时，返回</li>
<li><strong>递归右子树：</strong>$dfs(root-&gt;right)$</li>
<li><strong>三项工作：</strong><ol>
<li>提前返回：若$k=0$，代表已经找到目标结点，无需继续遍历，返回</li>
<li>统计序号：执行$k—$</li>
<li>记录结果：若$k=0$，代表当前节点为第$k$大的结点，记录$res=root-&gt;val$</li>
</ol>
</li>
<li><strong>递归左子树：</strong>$dfs(root-&gt;left)$</li>
</ol>
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;right, k);</span><br><span class="line">        -- k;</span><br><span class="line">        <span class="keyword">if</span>(!k) res = root -&gt; val;</span><br><span class="line">        dfs(root -&gt; left, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* cur = pRoot;</span><br><span class="line">        <span class="keyword">while</span>(cur || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(-- k == <span class="number">0</span>) <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p>输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：二叉树[<span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, null, null, <span class="number">6</span>, <span class="number">4</span>, null, null, null, null]如下图所示：</span><br><span class="line">    <span class="number">8</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">2</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">6</span>   <span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>递归</strong></p>
<p><strong>后序遍历：</strong></p>
<p><img src="/2020/07/27/Offer-Week6/03_1.png"></p>
<ul>
<li><p>树的后序遍历 / 深度优先搜索往往利用 <strong>递归</strong> 或 <strong>栈</strong> 实现，本文使用递归实现。 </p>
</li>
<li><p><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</p>
</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li><strong>终止条件</strong>： 当<code>root</code>为空，说明已越过叶节点，因此返回深度<code>0</code>。</li>
<li><strong>递推工作</strong>： 本质上是对树做后序遍历。<ol>
<li>计算节点<code>root</code>的<strong>左子树的深度</strong> ，即调用<code>maxDepth(root.left)</code></li>
<li>计算节点<code>root</code>的<strong>右子树的深度</strong> ，即调用<code>maxDepth(root.right)</code></li>
</ol>
</li>
<li><strong>返回值</strong>： 返回 此树的深度 ，即<code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><strong>层次遍历：</strong></p>
<ul>
<li>树的层序遍历 / 广度优先搜索往往利用 <strong>队列</strong> 实现。</li>
<li><strong>关键点：</strong> 每遍历一层，则计数器+1，直到遍历完成，则可得到树的深度。</li>
</ul>
<p><strong>算法解析</strong>：</p>
<ol>
<li><strong>特例处理</strong>： 当<code>root</code>为空，直接返回深度<code>0</code>。</li>
<li><strong>初始化</strong>： 队列<code>queue</code>（加入根节点<code>root</code>），计数器<code>res = 0</code>。</li>
<li><strong>循环遍历</strong>： 当<code>queue</code>为空时跳出。<ol>
<li>初始化一个空列表<code>tmp</code>，用于临时存储下一层节点；</li>
<li>遍历队列： 遍历<code>queue</code>中的各节点<code>node</code>，并将其左子节点和右子节点加入<code>tmp</code>；</li>
<li>更新队列： 执行<code>queue = tmp</code>，将下一层节点赋值给<code>queue</code>；</li>
<li>统计层数： 执行<code>res += 1</code>，代表层数加<code>1</code></li>
</ol>
</li>
<li><strong>返回值</strong>： 返回<code>res</code> 即可。</li>
</ol>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(TreeDepth(root -&gt; left),TreeDepth(root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>输入一棵二叉树的根结点，<strong>判断该树是不是平衡二叉树</strong>。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>注意：</strong></p>
<ul>
<li>规定空树也是一棵平衡二叉树。</li>
</ul>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：二叉树[<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,null,null,<span class="number">12</span>,<span class="number">9</span>,null,null,null,null]如下所示，</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">7</span>  <span class="number">11</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">12</span>   <span class="number">9</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>遇上一题类似</strong></p>
<p>以下两种方法均基于以下性质推出：<strong>此树的深度</strong> 等于<strong>左子树的深度</strong>与<strong>右子树的深度</strong>中的<strong>最大值</strong>+1。</p>
<h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root -&gt; left), right = dfs(root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中只出现过一次的两个数字"><a href="#数组中只出现过一次的两个数字" class="headerlink" title="数组中只出现过一次的两个数字"></a>数组中只出现过一次的两个数字</h1><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。你可以假设这两个数字一定存在。</p>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p> <strong>位运算，分组异或操作</strong></p>
<ol>
<li>将所有数进行异或操作，得到<code>x^y</code>的结果</li>
<li>找到<code>x^y</code>的第<code>k</code>位为1</li>
<li>根据第<code>k</code>位为0或1的情况，将数组分成两个集合（<code>x</code>和<code>y</code>分别位于两个集合）</li>
<li>对两个集合再次进行异或操作，得到<code>x</code>和<code>y</code></li>
</ol>
<h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data) sum ^= x;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k ++;</span><br><span class="line">        *num1 = <span class="number">0</span>, *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : data)</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                *num1 ^= x;</span><br><span class="line">        *num2 = *num1 ^ sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中唯一只出现一次的数字"><a href="#数组中唯一只出现一次的数字" class="headerlink" title="数组中唯一只出现一次的数字"></a>数组中唯一只出现一次的数字</h1><p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。你可以假设满足条件的数字一定存在。</p>
<p><strong>思考题：</strong></p>
<ul>
<li>如果要求只使用O(n)的时间和额外O(1)的空间，该怎么做呢？</li>
</ul>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/" target="_blank" rel="noopener">思路</a></h4><p><strong>二进制，有限状态机</strong></p>
<ol>
<li>对于出现三次的数字，各<strong>二进制位</strong>出现的次数都是3的倍数。 </li>
<li>统计所有数字的各二进制位中1的出现次数，并对3求余，结果则为只出现一次的数字。 </li>
</ol>
<p><img src="/2020/07/27/Offer-Week6/04.png"></p>
<h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h1><p>输入一个数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。你可以认为每组输入中都至少含有一组满足条件的输出。</p>
<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] , sum=<span class="number">7</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针</strong></p>
<p><img src="/2020/07/27/Offer-Week6/05.png"></p>
<h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(target - nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;target - nums[i], nums[i]&#125;;</span><br><span class="line">            hash.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                j --;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i],nums[j]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="和为S的连续正整数序列"><a href="#和为S的连续正整数序列" class="headerlink" title="和为S的连续正整数序列"></a>和为S的连续正整数序列</h1><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1～5、4～6和7～8。</p>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">15</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针，滑动窗口</strong></p>
<p><img src="/2020/07/27/Offer-Week6/06.png"></p>
<h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">1</span>; i &lt;= sum; i ++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s &lt; sum) s += ++ j;</span><br><span class="line">            <span class="keyword">if</span>(s == sum &amp;&amp; j - i + <span class="number">1</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">line</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k ++) <span class="built_in">line</span>.push_back(k);</span><br><span class="line">                res.push_back(<span class="built_in">line</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串<code>&quot;I am a student.&quot;</code>，则输出<code>&quot;student. a am I&quot;</code>。</p>
<h4 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"I am a student."</span></span><br><span class="line">输出：<span class="string">"student. a am I"</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针</strong></p>
<h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; str[j] != <span class="string">' '</span>) j ++;</span><br><span class="line">            reverse(str.<span class="built_in">begin</span>() + i, str.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串<code>&quot;abcdefg&quot;</code>和数字2，该函数将返回左旋转2位得到的结果<code>&quot;cdefgab&quot;</code>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证n小于等于输入字符串的长度。</li>
</ul>
<h4 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"abcdefg"</span> , n=<span class="number">2</span></span><br><span class="line">输出：<span class="string">"cdefgab"</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p><strong>操作分解</strong></p>
<ol>
<li>反转整个字符串序列</li>
<li>反转两个字符串子序列</li>
</ol>
<h4 id="C-代码-10"><a href="#C-代码-10" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n);</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络——概念、组成、功能和分类</title>
    <url>/2020/07/23/ComputerNetwork01/</url>
    <content><![CDATA[<h1 id="计算机网络基础概念"><a href="#计算机网络基础概念" class="headerlink" title="计算机网络基础概念"></a>计算机网络基础概念</h1><p><strong>计算机网络的功能：数据通信、资源共享</strong>、分布式处理、提高可靠性、负载均衡</p>
<p><strong>组成部分：硬件、软件和协议</strong></p>
<p><strong>工作方式：</strong>边缘部分（C/S、P2P）——用户直接使用；核心部分——为边缘部分提供服务</p>
<p><strong>功能组成：</strong>通信子网——数据通信；资源子网——资源共享</p>
<p><img src="/2020/07/23/ComputerNetwork01/01.png" style="width:60%"></p>
<p><strong>分类：</strong></p>
<p>范围：广域网（交换）、城域网、局域网（广播）、个人区域网</p>
<p>使用者：公用、专用</p>
<p>交换技术：电路交换、报文交换、分组交换</p>
<p>拓扑：总线型、星型、环形、网状</p>
<p>传输技术：广播式、点对点（分组存储转发和路由选择）</p>
<p><img src="/2020/07/23/ComputerNetwork01/02.png"></p>
<h3 id="标准化工作及其组织"><a href="#标准化工作及其组织" class="headerlink" title="标准化工作及其组织"></a>标准化工作及其组织</h3><p>法定标准——OSI</p>
<p>事实标准——TCP/IP</p>
<p><strong>RFC请求评论</strong>：</p>
<ol>
<li>因特网草案</li>
<li>建议标准</li>
<li>草案标准</li>
<li>因特网标准</li>
</ol>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p><strong>速率</strong>：数据率或数据传输率或比特率</p>
<p><img src="/2020/07/23/ComputerNetwork01/03.png" style="width:60%"></p>
<p><img src="/2020/07/23/ComputerNetwork01/04.png" style></p>
<p><strong>带宽</strong>：单位时间内从网络中到某一点所能通过的<strong>最高数据率</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/05.png" style></p>
<p><strong>吞吐量</strong>：单位时间内通过某个网络的数据<strong>量</strong>（类似流量）</p>
<p><img src="/2020/07/23/ComputerNetwork01/06.png" style></p>
<p><strong>时延</strong>：数据从网络一端传送到另一端所需的时间</p>
<p><img src="/2020/07/23/ComputerNetwork01/07.png" style></p>
<p><strong>时延带宽积</strong>=传播时延×带宽，以比特为单位的链路长度</p>
<p><strong>往返时延</strong>：从发送方发送数据开始，到发送方接收到接收方确认总共经理的时延（越大，可以发送的数据越多），包括：往返传播时延（2倍传播时延）、末端处理时间</p>
<p><strong>利用率</strong>：<strong>信道利用率</strong>、网络利用率</p>
<p><img src="/2020/07/23/ComputerNetwork01/08.png" style></p>
<h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><p><img src="/2020/07/23/ComputerNetwork01/09.png" style></p>
<p><img src="/2020/07/23/ComputerNetwork01/10.png" style></p>
<p>实体、协议（语法、语义、同步，式水平的）、接口、服务（垂直）</p>
<h4 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h4><p><img src="/2020/07/23/ComputerNetwork01/7level.png" style="width:70%"></p>
<p><strong>数据封装：</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/eg.png"></p>
<p><strong>PDU：协议数据单元</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/eg1.png"></p>
<p><strong>应用层</strong>：文件传输FTP、电子邮件SMTP、万维网HTTP</p>
<p><strong>表示层</strong>：</p>
<pre><code>1. 数据格式变换
 2. 数据加密解密
 3. 数据压缩与恢复
</code></pre><p><strong>会话层</strong>：向表示层/用户进程提供建立连接并在连接上有序传递数据</p>
<ol>
<li>建立、管理、终止会话</li>
<li>使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信实现同步</li>
</ol>
<p><strong>传输层</strong>：（<strong>TCP\UDP</strong>）两个进程的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据段</p>
<ol>
<li>可靠传输、不可靠传输</li>
<li>差错控制</li>
<li>流量控制</li>
<li>复用分用</li>
</ol>
<p><strong>网络层</strong>：把分组从源端传到目的端，为分组交换网上不同主机提供通信服务，<strong>数据报</strong></p>
<ol>
<li>路由选择</li>
<li>流量控制</li>
<li>差错控制</li>
<li>拥塞控制</li>
</ol>
<p><strong>数据链路层</strong>：把网络层传下来的数据报组装城帧</p>
<ol>
<li>成帧</li>
<li>差错控制</li>
<li>流量控制</li>
</ol>
<p><strong>物理层</strong>：</p>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p><img src="/2020/07/23/ComputerNetwork01/TCPIP.png"></p>
<h4 id="5层体系结构"><a href="#5层体系结构" class="headerlink" title="5层体系结构"></a>5层体系结构</h4><p><img src="/2020/07/23/ComputerNetwork01/5leve.png"></p>
<h5 id="封装与解封"><a href="#封装与解封" class="headerlink" title="封装与解封"></a>封装与解封</h5><p><img src="/2020/07/23/ComputerNetwork01/5leve_1.png"></p>
<h3 id="两个公式——重点"><a href="#两个公式——重点" class="headerlink" title="两个公式——重点"></a>两个公式——重点</h3><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体</p>
<p>主要任务：确定与传输媒体接口有关的一些特性——定义标准</p>
<p>特性：机械、电气（二进制）、功能、规程</p>
<h4 id="数据通信——传输消息"><a href="#数据通信——传输消息" class="headerlink" title="数据通信——传输消息"></a>数据通信——传输消息</h4><p><img src="/2020/07/23/ComputerNetwork01/dm.png"></p>
<p>基本方式：<strong>单工通信、半双工通信、全双工通信</strong></p>
<p>数据传输：<strong>串行传输、并行传输</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/dend.png"></p>
<h3 id="奈氏准者、香浓定理"><a href="#奈氏准者、香浓定理" class="headerlink" title="奈氏准者、香浓定理"></a>奈氏准者、香浓定理</h3><p> 失真：</p>
<p><img src="/2020/07/23/ComputerNetwork01/loss.png"></p>
<h2 id="网络IP地址"><a href="#网络IP地址" class="headerlink" title="网络IP地址"></a>网络IP地址</h2><p><img src="/2020/07/23/ComputerNetwork01/IP.png"></p>
<p>IP分类</p>
<p><img src="/2020/07/23/ComputerNetwork01/ip2.png"></p>
<p><strong>特殊IP</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/ip3.png"></p>
<p>私有地址</p>
<p><img src="/2020/07/23/ComputerNetwork01/ip4.png"></p>
<p>联系</p>
<p><img src="/2020/07/23/ComputerNetwork01/ip5.png"></p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><img src="/2020/07/23/ComputerNetwork01/ip6.png"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="/2020/07/23/ComputerNetwork01/ip7.png"></p>
<h1 id="1-传输层"><a href="#1-传输层" class="headerlink" title="1. 传输层"></a>1. 传输层</h1><h2 id="1-1-传输层的功能"><a href="#1-1-传输层的功能" class="headerlink" title="1.1 传输层的功能"></a>1.1 传输层的功能</h2><p><img src="/2020/07/23/ComputerNetwork01/传输层功能1.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/传输层功能3.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/传输层功能2.png"></p>
<h2 id="1-2-传输层的寻址与端口"><a href="#1-2-传输层的寻址与端口" class="headerlink" title="1.2 传输层的寻址与端口"></a>1.2 传输层的寻址与端口</h2><p><img src="/2020/07/23/ComputerNetwork01/端口1.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/端口2.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/端口3.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/端口4.png"></p>
<h2 id="1-3-无连接服务与面向连接服务"><a href="#1-3-无连接服务与面向连接服务" class="headerlink" title="1.3 无连接服务与面向连接服务"></a>1.3 无连接服务与面向连接服务</h2><ol>
<li><strong>面向连接服务（TCP）</strong>：通信双方在通信之前，必须先建立连接（三次握手），在通信过程中，整个连接的情况一直被实施地监控和管理。通信结束后，应该释放这个连接（四次挥手）。<strong>双工可靠逻辑信道</strong>。增加许多占用处理机资源地开销：<strong>确认、流量控制、计时器、连接管理</strong>等——使得协议数据单元头部增大，<strong>适用于文件传输（FTP）、超文本传输协议（HTTP）、远程登陆（TELNET）</strong>。</li>
<li><strong>无连接服务（UDP）</strong>：实体之间的通信不需要事先建立好连接，需要通信时，直接将消息发送到“网络”中，让该信息地传递在网络上尽力而为地往目的地传送。<strong>不可靠逻辑信道</strong>。<strong>简单，实时性好，适用于小文件传输（TFTP）、DNS、SNMP、实时传输协议（RTP）</strong>。</li>
</ol>
<p><strong>信息都对路由不可见</strong>。</p>
<p><img src="/2020/07/23/ComputerNetwork01/tcpudp.png"></p>
<h1 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2. UDP协议"></a>2. UDP协议</h1><p>无连接用户数据报协议，仅在IP数据服务之上增加了两个基本服务：复用/分用和差错检验。</p>
<ol>
<li>适用于一次性传输较少数据的网络应用（QQ表情、视频通话）；</li>
<li>维护传输可靠性需要在应用层完成。</li>
<li>发送方对应用层交付下来的报文添加首部后就交付给IP层，既不合并，也不拆分，保留报文的边界；接收方在接收IP层的UDP用户数据报，去除首部后直接交付给应用进程——<strong>报文不可分割，是UDP数据处理的最小单位</strong>。</li>
</ol>
<p><img src="/2020/07/23/ComputerNetwork01/UDP1.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/UDP2.png"></p>
<h2 id="2-1-UDP报文格式"><a href="#2-1-UDP报文格式" class="headerlink" title="2.1 UDP报文格式"></a>2.1 UDP报文格式</h2><p><img src="/2020/07/23/ComputerNetwork01/UDP3.PNG"></p>
<h2 id="2-2-UDP校验"><a href="#2-2-UDP校验" class="headerlink" title="2.2 UDP校验"></a>2.2 UDP校验</h2><p>在UDP数据报之前增加12B的伪首部，在计算校验时临时添加，校验和就按照这个临时的UDP数据包计算。<strong>伪首部既不向上传送也不向下递交，仅为了校验和</strong>。</p>
<p><img src="/2020/07/23/ComputerNetwork01/UDP4.PNG"></p>
<p><strong>二进制反码运算求和再取反（还要校验数据部分）</strong>：</p>
<p><img src="/2020/07/23/ComputerNetwork01/UDP5.PNG"></p>
<h1 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3. TCP协议"></a>3. TCP协议</h1><p>在不可靠IP层实现可靠传输——解决传输的可靠、有序、无丢失、不重复。</p>
<p><img src="/2020/07/23/ComputerNetwork01/tcp.png"></p>
<h2 id="3-1-TCP报文格式"><a href="#3-1-TCP报文格式" class="headerlink" title="3.1 TCP报文格式"></a>3.1 TCP报文格式</h2><p>数据传送单元：<strong>报文段</strong>——TCP首部、TCP数据，整个报文段作为IP数据报的数据部分封装在IP数据报中。首部20B 是固定的。</p>
<p><img src="/2020/07/23/ComputerNetwork01/TCP1_2.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/TCP1_3.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/TCP1_4.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/tcp1.png"><img src="/2020/07/23/ComputerNetwork01/tcp2.png"></p>
<h2 id="3-2-TCP连接管理（三次握手）"><a href="#3-2-TCP连接管理（三次握手）" class="headerlink" title="3.2 TCP连接管理（三次握手）"></a>3.2 TCP连接管理（三次握手）</h2><p><img src="/2020/07/23/ComputerNetwork01/TCP1_5.png"></p>
<p>TCP把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机、IP地址、应用进程、传输层的协议端口，<strong>TCP连接的端口成为套接字或插口</strong>。</p>
<p>TCP连接的建立应采用客户机/服务器方式，主动发起连接的应用进程称为客户机，被动等待连接建立的应用进程称为服务器。</p>
<p><img src="/2020/07/23/ComputerNetwork01/tcpsend.png"></p>
<ol>
<li><p><strong>第一步</strong>：<strong>请求报文段：SYN=1，ACK=0，seq=x</strong>。</p>
<p>客户机的TCP首先向服务器的TCP发送一个请求报文段。<strong>不含应用层数据，SYN=1</strong>。客户机随机选择一个起始序列号（连接请求报文段不携带数据，但消耗一个序号段）。</p>
</li>
<li><p><strong>第二步</strong>：<strong>服务器确认报文段：SYN=1，ACK=1，seq=y，ack=x+1（确认号字段）</strong></p>
<p>服务器的TCP收到连接请求报文段后，如果同意连接，就像客户机发回确认，并为该TCP连接分配TCP<strong>缓存和变量</strong>。在<strong>确认报文段中，SYN和ACK位都被置为1</strong>。（确认报文段不携带数据，但消耗一个序号段）</p>
</li>
<li><p><strong>第三步</strong>：<strong>客户端确认报文段：SYN=1，ACK=1，seq=x+1，ack=y+1（确认号字段）</strong>。</p>
<p>当客户端收到确认报文段之后，还要向服务器给出确认，并且也要给该连接<strong>分配缓存和变量</strong>。（可以携带数据，若不携带则不消耗序号）</p>
</li>
</ol>
<p><img src="/2020/07/23/ComputerNetwork01/3woshou.png"></p>
<p>成功进行以上三步，就建立了TCP连接。接下来就可以传输应用层数据，TCP提供的时双工通信，因此通信双方的应用进程任意时刻都能收发数据。<strong>服务器资源是在第二次握手分配，客户端资源在第三次握手分配</strong>。</p>
<h2 id="3-3-TCP连接的释放（四次挥手）"><a href="#3-3-TCP连接的释放（四次挥手）" class="headerlink" title="3.3 TCP连接的释放（四次挥手）"></a>3.3 TCP连接的释放（四次挥手）</h2><p><img src="/2020/07/23/ComputerNetwork01/4huishou.png"></p>
<ol>
<li><p><strong>第一步</strong>：<strong>客户机释放连接报文段：FIN=1，seq=u</strong>（u等于前面已经传送过去的数据最后一个字节序号+1）</p>
<p>客户机打算关闭连接，向其TCP<strong>发送一个连接释放报文段</strong>，并<strong>停止发送数据</strong>，<strong>主动关闭TCP连接</strong>。<strong>发送FIN报文时，发送FIN的一端不能再发送数据</strong>，即关闭了双工中的一条数据通路，但是<strong>对方还可以发送数据</strong>。</p>
</li>
<li><p><strong>第二步</strong>：<strong>服务器确认报文：ack=u+1</strong></p>
<p>服务器自己的序号是v，等于已经传过的数据的最后一个字节的序号+1。服务器收到连接释放报文后发出确认，即从客户端到服务器指个方向的连接释放。<strong>TCP处于半关闭状态</strong>，若服务器继续发送数据，客户端仍要接收。</p>
</li>
<li><p><strong>第三步</strong>：<strong>服务器释放报文段：FIN=1</strong>。</p>
<p>若服务器已经没有要向客户机发送的数据，就通知TCP释放此链接，此时其发处FIN=1的连接释放报文段。</p>
</li>
<li><p><strong>第四步</strong>：<strong>客户机确认报文：ACK=1，ack=w+1，seq=u+1</strong>。</p>
<p>客户机收到连接释放报文段，必须发出确认。TCP连接还未释放，<strong>必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态</strong>。</p>
</li>
</ol>
<p><img src="/2020/07/23/ComputerNetwork01/4woshou1.png"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><img src="/2020/07/23/ComputerNetwork01/TCP1_6.png"></p>
<h2 id="4-1-洪泛攻击"><a href="#4-1-洪泛攻击" class="headerlink" title="4.1 洪泛攻击"></a>4.1 洪泛攻击</h2><p><img src="/2020/07/23/ComputerNetwork01/hongfan.png"></p>
<h1 id="5-TCP可靠传输"><a href="#5-TCP可靠传输" class="headerlink" title="5. TCP可靠传输"></a>5. TCP可靠传输</h1><p>保证接收方进程从缓存区中读取的字节流与发送方发出的字节流完全一样，使用<strong>校验</strong>、<strong>序号</strong>、<strong>确认</strong>、<strong>重传</strong>等机制。</p>
<p><strong>1. 序号</strong></p>
<p>首部序号字段用于保证数据能<strong>有序地提交给应用层</strong>，TCP把数据视为一个<strong>无结构但有序地字节流</strong>，序号建立在传送的字节流上，而不建立在报文段上。序号字段的值就是指本报文段所发送的数据的第一个字节的编号。<img src="/2020/07/23/ComputerNetwork01/TCPNO.png"></p>
<p><strong>2. 确认</strong></p>
<p>TCP首部确认号是<strong>期望收到对方的下一个报文的数据的第一个字节的序号</strong>。<strong>发送缓冲区会继续存储那些以发送但未收到确认的报文段，以便在需要时重传</strong>。使用<strong>累积确认</strong>，即TCP<strong>只确认数据流中至第一个丢失字节为止的字节</strong>。如：B收到了A发送的0~2及6~7报文段，由于某种原因，B还未收到3~5，此时<strong>B仍在等待字节3（</strong>和其后面的字节），B到A的下一个报文段将<strong>确认号置为3</strong>。</p>
<p><img src="/2020/07/23/ComputerNetwork01/ack1.png"><img src="/2020/07/23/ComputerNetwork01/ack2.png"></p>
<p><strong>3. 重传</strong></p>
<p>两种事件：超时、冗余ACK</p>
<p><strong>超时</strong>：<strong>在规定时间内没受到接收方的确认就需要重传——超时重传</strong>TCP每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认是，就要重传这个报文段。</p>
<p><strong>冗余ACK</strong>：超时重传的超时周期太长。在超时发生之前，通过注意冗余ACK来检测丢包的情况。<strong>冗余：再次确认某个报文段的ACK，而发送方先前已经受到过该报文的确认</strong>。每当比期望到达序列号大的失序报文到达时，及发送一个冗余ACK，指明下一个期望收到的报文。</p>
<p><img src="/2020/07/23/ComputerNetwork01/ackack.png"></p>
<h2 id="5-1-TCP流量控制——滑动窗口"><a href="#5-1-TCP流量控制——滑动窗口" class="headerlink" title="5.1 TCP流量控制——滑动窗口"></a>5.1 TCP流量控制——滑动窗口</h2><p>消除发送方使接收方缓存溢出的可能性——<strong>速度匹配服务</strong>。<strong>利用滑动窗口机制实现流量控制，大小可动态变化</strong></p>
<p><img src="/2020/07/23/ComputerNetwork01/wwindow.png"></p>
<p>主机A向主机B发送数据，B说：我的rwnd=400字节</p>
<p><img src="/2020/07/23/ComputerNetwork01/windows.png"></p>
<h2 id="5-2-TCP拥塞控制"><a href="#5-2-TCP拥塞控制" class="headerlink" title="5.2 TCP拥塞控制"></a>5.2 TCP拥塞控制</h2><p><strong>防止过多的数据注入网络，保证网络中的路由或链路不致过载</strong>。与流量控制相似，都通过控制发送方发送数据的速率来达到控制效果。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>拥塞控制</strong>——<strong>让网络能够承受现有的网络负荷</strong>，是一个<strong>全局性</strong>的过程，涉及所有主机、所有路由器、以及与降低网络传输性能有关的所有因素。</li>
<li><strong>流量控制</strong>——<strong>抑制发送端发送数据的速率，以便接收方来得及接收</strong>。<strong>点对点的通信量控制</strong>，即接收端和发送端。</li>
</ul>
<p><img src="/2020/07/23/ComputerNetwork01/拥塞控制.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/拥塞控制1.png"></p>
<p><strong>慢开始和拥塞避免</strong>：接收窗口的大小可根据TCP报文首部的窗口字段通知发送方，但是发送方如何维护？</p>
<p><img src="/2020/07/23/ComputerNetwork01/慢开始拥塞避免.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/慢开始拥塞避免1.png"></p>
<p><img src="/2020/07/23/ComputerNetwork01/慢开始拥塞避免2.png"></p>
<p><strong>快重传和快恢复</strong>：对慢开始和拥塞避免算法的改进</p>
<p><img src="/2020/07/23/ComputerNetwork01/快重传快恢复.png"></p>
<p><strong>流量控制</strong>：发送方的数据量由就受访定</p>
<p><strong>拥塞控制</strong>：发送方自己通过检测网络状况决定</p>
<p><strong>超时</strong>：慢开始和拥塞避免</p>
<p><strong>冗余</strong>：快重传快恢复</p>
<p>发送方窗口的实际大小由流量控制和拥塞控制共同决定，且<strong>取rwnd接收窗口和cwnd拥塞窗口中较小</strong>的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer——Week5</title>
    <url>/2020/07/23/Offer-Week5/</url>
    <content><![CDATA[<h1 id="数字序列中某一位的数"><a href="#数字序列中某一位的数" class="headerlink" title="数字序列中某一位的数"></a>数字序列中某一位的数</h1><p>数字以0123456789101112131415…的格式<strong>序列化到一个字符序列</strong>中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数<strong>求任意位对应的数字</strong>。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">13</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>递推</strong></p>
<ol>
<li>将$101112…$中的每一位称为<strong>数位</strong>，记为$n$；</li>
<li>将$10$、$11$、$12$、、、成为<strong>数字</strong>，记为$num$；</li>
<li>数字$10$是一个两位数，称此数的<strong>位数</strong>为$2$，记为$digit$；</li>
<li>每$digit$位数的起始数字（$10$、$11$、$12$、、、），记为$start$。</li>
</ol>
<p><img src="/2020/07/23/Offer-Week5/01.png"></p>
<p>根据以上凡汐，可将其分解为三步：</p>
<ol>
<li><p>确定$n$所在<strong>数字</strong>的<strong>位数</strong>，记为$digit$；</p>
<ul>
<li>循环执行$n$减去 一位数、两位数、… 的数位数量$count$，直至$n \leq count$时跳出。 </li>
<li>由于$n$已经减去了一位数、两位数、…、$(digit−1)$位数的数位数量$count$，因而此时的$n$是从起始数字$start$开始计数的。</li>
<li>所求数位 ① 在某个$digit$位数中； ② 为从数字$start$开始的第$n$个数位。 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">digit = <span class="number">1</span>, start = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span>(n &gt; count):</span><br><span class="line">    n -= count</span><br><span class="line">    start *= <span class="number">10</span> # <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, ...</span><br><span class="line">    digit += <span class="number">1</span>  # <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, ...</span><br><span class="line">    count = <span class="number">9</span> * start * digit # <span class="number">9</span>, <span class="number">180</span>, <span class="number">2700</span>, ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定$n$所在<strong>数字</strong>，记为$num$；</p>
<ul>
<li>所求数位的数字在从$start$开始的第$[(n - 1) / digit]$个数字中（$start$为第0个数字）</li>
<li>$num = start + (n - 1) // digit $</li>
</ul>
</li>
<li><p>确定$n$是$num$中的哪一位，并返回。</p>
<ul>
<li><p>所求数位为数字$num$的第$(n - 1) \% digit$位（数字的首个数位为第0位）。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s = str(num) 						# 转化为 <span class="built_in">string</span></span><br><span class="line">res = <span class="keyword">int</span>(s[(n - <span class="number">1</span>) % digit]) 		# 获得 num 的 第 (n - <span class="number">1</span>) % digit 个数位，并转化为 <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度</strong>$O(\log n)$： 所求数位$nn$对应数字$num$的位数$digit$最大为$O(\log n)$；第一步最多循环$O(logn)$次；第三步中将$num$转化为字符串使用$O(logn)$时间；因此总体为$O(logn)$。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">return</span> to_string(num)[(n - <span class="number">1</span>) % digit] - <span class="string">'0'</span>; <span class="comment">// 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p>输入一个<strong>正整数数组</strong>，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中<strong>最小的一个</strong>。例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>]</span><br><span class="line">输出：<span class="number">321323</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：输出数字的格式为<strong>字符串</strong>。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>定义新的排序规则</strong></p>
<ol>
<li><strong>排序判断规则</strong>：设$nums$任意两数字的字符串格式为$x$和$y$，则：<ol>
<li>若拼接字符串$x+y&gt;y+x$，则$x&gt;y$；</li>
<li>反之，若$x+y&lt;y+x$，则$x&lt;y$。</li>
</ol>
</li>
<li>根据以上规则，套用任何排序方法对$nums$进行排序。</li>
</ol>
<p><img src="/2020/07/23/Offer-Week5/02.png"></p>
<h4 id="算法时间复杂度-1"><a href="#算法时间复杂度-1" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度</strong>$O(N \log N)$：$N$为最终返回值的字符数量（列表的长度$\leq N$）；使用快排或内置函数的平均时间复杂度为$O(NlogN)$，最差为$O(N^2)$。</p>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> as = to_string(a), bs = to_string(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : numbers)</span><br><span class="line">            res += to_string(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：<strong>0翻译成”a”</strong>，<strong>1翻译成”b”</strong>，……，<strong>11翻译成”l”</strong>，……，<strong>25翻译成”z”</strong>。<strong>一个数字可能有多个翻译</strong>。例如12258有5种不同的翻译，它们分别是”<strong>bccfi</strong>”、”<strong>bwfi</strong>”、”<strong>bczi</strong>”、”<strong>mcfi</strong>”和”<strong>mzi</strong>”。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"12258"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划</strong></p>
<p><img src="/2020/07/23/Offer-Week5/03.png"></p>
<ol>
<li><p><strong>状态表示</strong>： 设动态规划列表$dp$，$dp[i]$代表以$x_i$为结尾的数字的翻译方案数量。     </p>
</li>
<li><p><strong>转移方程</strong>：若$x_i$和$x_{i-1}$组成的两位数字可以被翻译，则$dp[i] = dp[i - 1] + dp[i - 2]$；否则$dp[i] = dp[i - 1]$。</p>
<ul>
<li><script type="math/tex; mode=display">
dp[i]=\left\{
\begin{aligned}
dp[i−1]+dp[i−2],10x_{i-1} +x _i\in[10,25]\\ 
dp[i−1],10x _{i−1}+x _i\in [0,10)∪(25,99]\\
\end{aligned}
\right.</script></li>
</ul>
</li>
</ol>
<ol>
<li><strong>边界条件</strong>：初始状态： $dp[0]=dp[1]=1$，即 “无数字” 和 “第1位数字” 的翻译方法数量均为1；$dp[n]$ ，即此数字的翻译方案数量。 </li>
</ol>
<h4 id="算法时间复杂度-2"><a href="#算法时间复杂度-2" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> src = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = <span class="number">0</span>;</span><br><span class="line">            r += q;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> pre = src.substr(i - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (pre &lt;= <span class="string">"25"</span> &amp;&amp; pre &gt;= <span class="string">"10"</span>) &#123;</span><br><span class="line">                r += p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度：O(n)，遍历数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = s.substr(i - <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="string">"10"</span> &amp;&amp; a &lt;= <span class="string">"25"</span>)</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><p>在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。你可以从棋盘的<strong>左上角</strong>开始拿格子里的礼物，并每次<strong>向右或者向下</strong>移动一格直到到达棋盘的<strong>右下角</strong>。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
<p><strong>注意：</strong>m,n&gt;0m,n&gt;0</p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">7</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：沿着路径 <span class="number">2</span>→<span class="number">3</span>→<span class="number">7</span>→<span class="number">6</span>→<span class="number">1</span> 可以得到拿到最大价值礼物。</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划</strong></p>
<ol>
<li><p><strong>状态表示：</strong>$f[i,j]$——从左上角走到当前$[i,j]$处最大礼物累积</p>
</li>
<li><p><strong>转移方程：</strong>$f[i,j]=max[f[i-1,j],f[i,j-1]]+grid[i,j]$</p>
</li>
<li><p><strong>边界条件：</strong></p>
<ul>
<li><p><strong>初始状态</strong>：$f[0,0]=grid[0,0]$</p>
</li>
<li><p><strong>返回值：</strong>$f[m-1][n-1]$，$m,n$分别为矩阵的行高和列宽，即右下角。</p>
</li>
<li><script type="math/tex; mode=display">
f[i,j]=\left\{
\begin{aligned}
grid[i,j]——i=0,j=0\\ 
grid[i,j]+f[i,j-1]——i=0,j\neq0\\
grid[i,j]+f[i-1,j]——i\neq0,j=0\\
grid[i,j]+max[f[i,j-1],f[i-1,j]]——i\neq0,j\neq0\\
\end{aligned}
\right.</script></li>
</ul>
</li>
</ol>
<p><img src="/2020/07/23/Offer-Week5/04.png"></p>
<h4 id="算法时间复杂度-3"><a href="#算法时间复杂度-3" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <strong>时间复杂度$O(MN)$：</strong> $M, N$分别为矩阵行高、列宽；动态规划需遍历整个$grid$矩阵，使用$O(MN)$时间。 </p>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p>请从字符串中找出一个<strong>最长的不包含重复字符的子字符串</strong>，<strong>计算该最长子字符串的长度</strong>。假设字符串中只包含从’a’到’z’的字符。</p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"abcabc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针</strong></p>
<h4 id="算法时间复杂度-4"><a href="#算法时间复杂度-4" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[j]] ++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[j]] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hash[s[i ++]] --;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。求第n个丑数的值。</p>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：习惯上我们把1当做第一个丑数。</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>三路归并排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums2 &#x3D; &#123;1*2, 2*2, 3*2, 4*2, 5*2, 6*2, 8*2...&#125;</span><br><span class="line">nums3 &#x3D; &#123;1*3, 2*3, 3*3, 4*3, 5*3, 6*3, 8*3...&#125;</span><br><span class="line">nums5 &#x3D; &#123;1*5, 2*5, 3*5, 4*5, 5*5, 6*5, 8*5...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>包含2的除以2，包含3的除以3，包含5的除以5——判重合并（并集）之后可以得到丑数序列！！</strong></p>
<p><strong>判重：</strong></p>
<h4 id="算法时间复杂度-5"><a href="#算法时间复杂度-5" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (index &lt; <span class="number">7</span>)<span class="keyword">return</span> index;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(index)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; index; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = <span class="built_in">min</span>(res[t2] * <span class="number">2</span>, <span class="built_in">min</span>(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t2] * <span class="number">2</span>) t2++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t3] * <span class="number">3</span>) t3++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == res[t5] * <span class="number">5</span>) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串中第一个只出现一次的字符"><a href="#字符串中第一个只出现一次的字符" class="headerlink" title="字符串中第一个只出现一次的字符"></a>字符串中第一个只出现一次的字符</h1><p>在字符串中找出第一个只出现一次的字符。如输入<code>&quot;abaccdeff&quot;</code>，则输出<code>b</code>。如果字符串中不存在只出现一次的字符，返回#字符。</p>
<h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"abaccdeff"</span></span><br><span class="line">输出：<span class="string">'b'</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><strong>模拟，哈希表</strong></p>
<h4 id="算法时间复杂度-6"><a href="#算法时间复杂度-6" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">            ++ mp[ch];</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h1><p>请实现一个函数用来找出<strong>字符流</strong>中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是’g’。当从该字符流中读出前六个字符”google”时，第一个只出现一次的字符是’l’。如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"google"</span></span><br><span class="line">输出：<span class="string">"ggg#ll"</span></span><br><span class="line">解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针——队列，动态的过程</strong></p>
<p>每次出现重复的字母，将其全部删掉</p>
<p>维护一个哈希表，记录从前往后字符出现的次数。</p>
<h4 id="算法时间复杂度-7"><a href="#算法时间复杂度-7" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (mp.<span class="built_in">find</span>(ch) == mp.<span class="built_in">end</span>()) &#123;	</span><br><span class="line">             q.push(ch);		<span class="comment">// 如果是第一次出现， 则添加到队列中</span></span><br><span class="line">         &#125;</span><br><span class="line">         ++mp[ch];				<span class="comment">// 不管是不是第一次出现，都进行计数   </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = q.front();<span class="comment">// 拿出头部，如果是第一次出现，则返回</span></span><br><span class="line">            <span class="keyword">if</span> (mp[ch] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q.pop();		<span class="comment">// 不是第一次出现，则弹出，然后继续判断下一个头部</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组的逆序对"><a href="#数组的逆序对" class="headerlink" title="数组的逆序对"></a>数组的逆序对</h1><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>归并排序</strong></p>
<p>「归并排序」是分治思想的典型应用，它包含这样三个步骤： </p>
<h4 id="算法时间复杂度-8"><a href="#算法时间复杂度-8" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力—— 50%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">                    res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">begin</span> + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;        <span class="comment">// 初始化中间位置</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">copy</span><span class="params">(nums)</span></span>;            <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="comment">// 递归求解左右两边逆序对</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = getCount(nums, <span class="built_in">begin</span>, mid);</span><br><span class="line">        <span class="keyword">int</span> rightCount = getCount(nums, mid + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> crossCount = <span class="number">0</span>;                <span class="comment">// 记录跨域两边的逆序对</span></span><br><span class="line">        <span class="keyword">int</span> i = mid, j = <span class="built_in">end</span>, index = <span class="built_in">end</span>;    <span class="comment">// 前半部分、后半部分、辅助数组下标范围</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="built_in">begin</span> &amp;&amp; j &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;            <span class="comment">// 统计跨区逆序对</span></span><br><span class="line">                copy[index --] = nums[i --];</span><br><span class="line">                crossCount += j - <span class="built_in">begin</span> - (mid - <span class="built_in">begin</span>);    <span class="comment">// 右边的减去左边的个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                copy[index --] = nums[j --];    <span class="comment">// 不存在逆序对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="built_in">begin</span>)</span><br><span class="line">            copy[index --] = nums[i --];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; mid)</span><br><span class="line">            copy[index --] = nums[j --];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt;= <span class="built_in">end</span>; ++ i)</span><br><span class="line">            nums[i] = copy[i];</span><br><span class="line">        <span class="keyword">return</span> (leftCount + rightCount + crossCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> getCount(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共结点。当不存在公共节点时，返回空节点。</p>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给出两个链表如下所示：</span><br><span class="line">A：        a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line">输出第一个公共节点c1</span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针</strong></p>
<p>我们使用两个指针<code>node1</code>，<code>node2</code>分别指向两个链表<code>headA</code>，<code>headB</code>的头结点，然后同时分别逐结点遍历，当<code>node1</code>到达链表<code>headA</code>的末尾时，重新定位到链表<code>headB</code>的头结点；当<code>node2</code>到达链表<code>headB</code>的末尾时，重新定位到链表<code>headA</code>的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。</p>
<h4 id="算法时间复杂度-9"><a href="#算法时间复杂度-9" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode *node1 = pHead1;</span><br><span class="line">        ListNode *node2 = pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="literal">nullptr</span> ? node1 -&gt; next : pHead2;</span><br><span class="line">            node2 = node2 != <span class="literal">nullptr</span> ? node2 -&gt; next : pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><p>统计一个数字在排序数组中出现的次数。例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<h4 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ,  <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p><strong>二分法</strong></p>
<p><img src="/2020/07/23/Offer-Week5/07.png"></p>
<p>排序数组$nums$中的所有数字$target$形成一个窗口，记窗口的 左 / 右边界索引分别为$left$和$right$，分别对应窗口左边 / 右边的首个元素。</p>
<ol>
<li><strong>初始化：</strong>左边界$i=1$，右边界$r=nums.size() - 1$</li>
<li><strong>循环二分：</strong>当闭区间$[i,j]$无元素就跳出来<ol>
<li>计算中点$mid=(i+j)/2$</li>
<li>若$nums[mid]&lt;target$，则$target$在闭区间$[mid+1,j]$中，执行$l=mid+1$;</li>
<li>若$nums[mid] &gt; target$，则$target$在闭区间$[i,mid−1]$中，因此执行$j = mid - 1$；</li>
<li>若$nums[m] = target$，则右边界$right$在闭区间$[mid+1,j]$中；左边界$left$在闭区间$[i,mid-1]$中。因此分为以下两种情况：<ol>
<li>若查找右边界$right$，则执行$i = mid + 1$；（跳出时$i$指向右边界）</li>
<li>若查找左边界$left$，则执行$j = mid - 1$；（跳出时$j$指向左边界）</li>
</ol>
</li>
</ol>
</li>
<li><strong>返回值：</strong> 应用两次二分，分别查找$right$和$left$，最终返回$right - left - 1$即可。 </li>
</ol>
<h4 id="算法时间复杂度-10"><a href="#算法时间复杂度-10" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><h4 id="C-代码-10"><a href="#C-代码-10" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - left +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer——Week4</title>
    <url>/2020/07/15/Offer-Week4/</url>
    <content><![CDATA[<h1 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h1><p>输入一个整数数组，<strong>判断该数组是不是某二叉搜索树的后序遍历的结果</strong>。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>递归，分治，$O(n^2)$</strong></p>
<ol>
<li><strong>终止条件：</strong>当$l&gt;=r$时，说明此子树节点数量$&lt;=1$，无需判断正确性，直接返回<code>true</code>；</li>
<li><strong>递归：</strong><ol>
<li><strong>划分左右子树：</strong>遍历后序序列的$[l,r]$区间元素，寻找<strong>第一个大于根节点的节点，索引记为$m$</strong>。此时，可划分出<strong>左子树区间$[l,m-1]$</strong>，<strong>右子树区间$[m,r-1]$</strong>，<strong>根节点索引为$r$</strong>。</li>
<li><strong>判断是否是二叉搜索树：</strong><ol>
<li><strong>左子树区间$[l,m-1]$</strong>内所有节点都应该$&lt;postorder[j]$。而第$1.$步已经保证左子树区间正确性，只需要判断右子树区间即可。</li>
<li><strong>右子树区间$[m,j-1]$</strong>内所有节点都应该$&gt;postorder[j]$。实现方式为遍历，当遇到$&lt;postorder[j]$的节点则跳出，通过判断$p=j$判断是否为二叉搜索树。</li>
</ol>
</li>
</ol>
</li>
<li><strong>返回值：</strong> 所有子树都需正确才可判定正确，因此使用与逻辑符<code>&amp;&amp;</code>连接。 <ol>
<li><code>p=j</code>： 判断此树是否正确。</li>
<li><code>recur(i, m - 1)</code>： 判断此树的左子树是否正确。</li>
<li><code>recur(m, j - 1)</code>： 判断此树的右子树是否正确。</li>
</ol>
</li>
</ol>
<p><img src="/2020/07/15/Offer-Week4/postorder.png" style="width:60%"></p>
<p>时<strong>间复杂度</strong>$O(N^2)$)：每次调用<code>recur(l,r)</code>减去一个根节点，因此递归占用$O(N)$；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = l;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[r]) p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[r]) p++;</span><br><span class="line">        <span class="keyword">return</span> p == r &amp;&amp; recur(postorder, l, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p>输入一棵二叉树和一个整数，<strong>打印出二叉树中结点值的和为输入整数的所有路径</strong>。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给出二叉树如下所示，并给出num=<span class="number">22</span>。</span><br><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">6</span></span><br><span class="line">   /   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">13</span>  <span class="number">6</span></span><br><span class="line"> /  \    / \</span><br><span class="line"><span class="number">9</span>    <span class="number">1</span>  <span class="number">5</span>   <span class="number">1</span></span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>回溯法，$O(n)$</strong></p>
<p><strong>先序遍历，路径记录</strong></p>
<p><strong><code>pathSum(root, sum)</code>函数：</strong></p>
<ol>
<li><strong>初始化</strong>：结果列表<code>res</code>，路径<code>path</code>。</li>
<li><strong>返回值</strong>：返回<code>res</code>即可。</li>
</ol>
<p><strong><code>recur(root,tar)</code>函数：</strong></p>
<ol>
<li><strong>递归参数</strong>：当前节点<code>root</code>，当前目标值<code>tar</code>。</li>
<li><strong>终止条件</strong>：若节点<code>root</code>为空，则返回。</li>
<li><strong>递归工作</strong>：<ol>
<li>路径更新：当前节点值<code>root-&gt;val</code>加入<code>path</code></li>
<li>目标值更新：<code>tar=tar-root-&gt;val</code>（即目标值<code>tar</code>从<code>sum</code>减到<code>0</code>）</li>
<li>路径记录：当<code>root</code>为叶子且路径和等于目标值，将此路径<code>path</code>加入到<code>res</code></li>
<li>先序遍历：递归左右子节点</li>
<li>路径恢复：向上回溯，需要将当前节点从路径<code>path</code>中删除，执行<code>path.pop()</code></li>
</ol>
</li>
</ol>
<p><img src="/2020/07/15/Offer-Week4/tree1.png"></p>
<p><img src="/2020/07/15/Offer-Week4/tree2.png"></p>
<p><img src="/2020/07/15/Offer-Week4/tree3.png"></p>
<p><img src="/2020/07/15/Offer-Week4/tree4.png"></p>
<h4 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h4><p> <strong>时间复杂度$O(N)$：</strong>$N$为二叉树的节点数，先序遍历需要遍历所有节点。</p>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">		recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode* root, <span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        tar -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) res.push_back(path);</span><br><span class="line">        recur(root-&gt;left, tar);</span><br><span class="line">        recur(root-&gt;right, tar);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="复杂链表的复刻"><a href="#复杂链表的复刻" class="headerlink" title="复杂链表的复刻"></a>复杂链表的复刻</h1><p>请实现一个函数可以<strong>复制一个复杂链表</strong>。在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个<strong>额外的指针指向链表中的任意结点或者null</strong>。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><p><img src="/2020/07/15/Offer-Week4/list.png" style="width:70%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：head = [[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">7</span>,null],[<span class="number">13</span>,<span class="number">0</span>],[<span class="number">11</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>优化的迭代</strong></p>
<p><img src="/2020/07/15/Offer-Week4/dummy.png" style="width:50%"></p>
<h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> 时间复杂度：$O(N)$。 </p>
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 插入新复制的链表到每个原始链表节点的后边</span></span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            Node* np = <span class="keyword">new</span> Node(p-&gt;val);</span><br><span class="line">            np-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = np;</span><br><span class="line">            p = np-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据原始链表的random，设置新链表的random</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;<span class="built_in">random</span> == <span class="literal">nullptr</span>) p-&gt;next-&gt;<span class="built_in">random</span> = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next-&gt;<span class="built_in">random</span> = p-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分离新旧链表</span></span><br><span class="line">        p = head;</span><br><span class="line">        Node* dummy = head-&gt;next;</span><br><span class="line">        Node* cp = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p) cp-&gt;next = p-&gt;next;</span><br><span class="line">            cp = cp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<strong>不能创建任何新的结点，只能调整树中结点指针的指向</strong>。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>需要返回双向链表最左侧的节点。</li>
</ul>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><p>输入下图中左边的二叉搜索树，则输出右边的排序双向链表。</p>
<p><img src="/2020/07/15/Offer-Week4/treeList.png"></p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>中序遍历</strong></p>
<p>二叉搜索树中序遍历序列为升序，将其转换为排序的循环双链表，包括：</p>
<ol>
<li><strong>排序链表：</strong>节点从小到大排序，应使用<strong>中序遍历</strong>访问数的节点；</li>
<li><strong>双向链表：</strong>构建相邻节点（前驱节点$pre$，当前节点$cur$）关时，不仅应<code>pre-&gt;right=cur</code>，还需要<code>cur-&gt;left=pre</code></li>
<li><strong>循环链表：</strong>设置链表头节点$head$和尾节点$tail$，应建立<code>head-&gt;left=tai</code>，<code>tail-&gt;right=head</code>。</li>
</ol>
<p><img src="/2020/07/15/Offer-Week4/treeList1.png"></p>
<p><strong>流程：</strong></p>
<p><strong><code>dfs(cur)</code>中序遍历：</strong></p>
<ol>
<li><strong>终止条件：</strong>当节点<code>cur</code>为空，代表节点越过叶节点，直接返回</li>
<li>递归左子树，即 <code>dfs(cur.left)</code> ；</li>
<li><strong>构建链表：</strong> <ol>
<li><strong>当$pre$为空时：</strong> 代表正在访问链表头节点，记为$head$。 </li>
<li>当$pre$不为空时： 修改双向节点引用，即<code>pre.right = cur</code>，<code>cur.left = pre</code>；</li>
<li><strong>保存$cur$：</strong> 更新<code>pre = cur</code>，即节点<code>cur</code>是后继节点的<code>pre</code>； </li>
</ol>
</li>
<li><p>递归右子树，即 <code>dfs(cur.left)</code> ； </p>
<p><strong><code>treeToDoublyList(root)：</code></strong> </p>
</li>
<li><p><strong>特例处理：</strong> 若节点<code>root</code>为空，则直接返回；</p>
</li>
<li><strong>初始化：</strong> 空节点<code>pre</code>；</li>
<li><strong>转化为双向链表：</strong> 调用<code>dfs(root)</code>；</li>
<li><strong>构建循环链表：</strong> 中序遍历完成后，<code>head</code>指向头节点，<code>pre</code>指向尾节点，因此修改<code>head</code>和<code>pre</code>的双向节点引用即可。</li>
<li><strong>返回值：</strong> 返回链表的头节点<code>head</code>即可。</li>
</ol>
<h4 id="算法时间发杂度"><a href="#算法时间发杂度" class="headerlink" title="算法时间发杂度"></a>算法时间发杂度</h4><p> <strong>时间复杂度$O(N)$：</strong> $N$为二叉树的节点数，中序遍历需要访问所有节点。 </p>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *pre, *head;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> null;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span>) pre-&gt;right=cur;</span><br><span class="line">        <span class="keyword">else</span> head=cur;</span><br><span class="line">        cur-&gt;left=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        dfs(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p>请实现两个函数，分别用来<strong>序列化</strong>和<strong>反序列化二叉树</strong>。您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247485871&amp;idx=1&amp;sn=bcb24ea8927995b585629a8b9caeed01&amp;chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&amp;mpshare=1&amp;scene=23&amp;srcid=0721QWiL5bFepssmnNk80Xx7&amp;sharer_sharetime=1595329499896&amp;sharer_shareid=02a8ba1696317c3798e55c33d2be7a04#rd" target="_blank" rel="noopener">参考</a></p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">你可以序列化如下的二叉树</span><br><span class="line">    <span class="number">8</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">2</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">6</span>   <span class="number">4</span></span><br><span class="line">为：<span class="string">"[8, 12, 2, null, null, 6, 4, null, null, null, null]"</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>二叉树的层次遍历</strong></p>
<p> 题目要求的 “序列化” 和 “反序列化” 是 <strong>可逆</strong> 操作。因此，序列化的字符串应携带 “完整的” 二叉树信息，即拥有单独表示二叉树的能力。 </p>
<p>为使反序列化可行，考虑<strong>将越过叶节点后的$null$也看作是节点</strong>。在此基础上，对于列表中任意某节点$node$，其左子节点$node.left$和右子节点$node.right$在序列中的位置都是唯一确定 的。</p>
<p><img src="/2020/07/15/Offer-Week4/treeSort.png"></p>
<h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 非层次遍历，用前序遍历序列，递归 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs_s(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, <span class="built_in">string</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            res+=<span class="string">"null "</span>;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">' '</span>;</span><br><span class="line">        dfs_s(root-&gt;left, res);</span><br><span class="line">        dfs_s(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data,u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span> &amp;u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == data.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[k]!=<span class="string">' '</span>) k++;</span><br><span class="line">        <span class="keyword">if</span>(data[u]==<span class="string">'n'</span>)&#123;</span><br><span class="line">            u=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = u+<span class="number">1</span>; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;</span><br><span class="line">                val  = -val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果是数字是正的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u = k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left=dfs_d(data,u);</span><br><span class="line">        root-&gt;right=dfs_d(data,u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但<strong>里面不能有重复元素</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span></span><br><span class="line">输出：[<span class="string">"abc"</span>,<span class="string">"acb"</span>,<span class="string">"bac"</span>,<span class="string">"bca"</span>,<span class="string">"cab"</span>,<span class="string">"cba"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>回溯法</strong></p>
<p> <strong>排列方案的生成方法：</strong> 根据字符串排列的特点，考虑<strong>深度优先搜索所有排列方案</strong>。即通过字符交换，先固定第1位字符（n种情况）、再固定第2位字符（n−1种情况）、… 、最后固定第n位字符（1种情况）。</p>
<p><strong>重复方案与剪枝</strong>： 当字符串存在<strong>重复字符</strong>时，排列方案中也存在重复方案。为排除重复方案，<strong>需在固定某位字符时，保证 “每种字符只在此位固定一次”</strong> ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p>
<ol>
<li><strong>终止条件：</strong>当$x=len(c)-1$时，代表所有位已经固定（最后只有一种情况），则将当前组合<code>c</code>转化为字符串并加入<code>res</code>，返回。</li>
<li><strong>递归参数：</strong>当前固定位<code>x</code></li>
<li><strong>递归工作：</strong>初始化一个<code>set</code>，用于排除重复的字符；将第<code>x</code>位字符与$i\in[x,len(c)]$字符分别交换，并进入下一层递归；<ol>
<li><strong>剪枝</strong>：若$c[i]$在Set中，代表其是重复字符，因此需要剪枝；</li>
<li>将$c[i]$加入Set，以便之后遇到重复字符时剪枝；</li>
<li><strong>固定字符</strong>：将字符$c[i]$和$c[x]$交换，即固定$c[i]$位当前字符；</li>
<li><strong>开启下层递归</strong>：调用$dfs(x+1)$，即开始固定$(x+1)$个字符；</li>
<li><strong>还原交换</strong>：将字符$c[i]$和$c[x]$交换（还原之前的交换）</li>
</ol>
</li>
</ol>
<h4 id="算法时间复杂度-1"><a href="#算法时间复杂度-1" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>时间复杂度$O(N!)$： $N$为字符串$s$的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为$N \times (N-1) \times (N-2) … \times 2 \times 1$，因此复杂度为$O(N!)$ 。</p>
<h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>		<span class="comment">// 只通过了50%</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">cursor</span>=<span class="number">0</span>;</span><br><span class="line">        permutation(s,<span class="built_in">cursor</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> <span class="built_in">cursor</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cursor</span>==s.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;				<span class="comment">// 满足条件</span></span><br><span class="line">            res.push_back(s);				<span class="comment">// 添加路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">cursor</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;	<span class="comment">// 选择列表 </span></span><br><span class="line">                <span class="keyword">if</span>(judge(s,<span class="built_in">cursor</span>,i))<span class="keyword">continue</span>;  <span class="comment">// 从cursor开始，遍历不重复的字符</span></span><br><span class="line">                swap(s[<span class="built_in">cursor</span>],s[i]);			<span class="comment">// 做选择</span></span><br><span class="line">                permutation(s,<span class="built_in">cursor</span>+<span class="number">1</span>);	    <span class="comment">// 下一层决策树</span></span><br><span class="line">                swap(s[<span class="built_in">cursor</span>],s[i]);			<span class="comment">// 撤销选择</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="built_in">end</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[<span class="built_in">end</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。假设数组非空，并且一定存在满足条件的数字。</p>
<p><strong>思考题</strong>：</p>
<ul>
<li>假设要求只能使用$O(n)$的时间和额外$O(1)$的空间，该怎么做呢？</li>
</ul>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol>
<li><strong>哈希表统计</strong></li>
<li><strong>数组排序</strong></li>
<li><strong>摩尔投票</strong>：<strong>构建正负抵消</strong><ol>
<li><strong>票数和</strong>：由于众数出现的次数超过数组长度的一半；若记<strong>众数</strong>的票数为$+1$，<strong>非众数</strong>的票数为$−1$，则一定有所有数字的票数和$&gt;0$。</li>
<li><strong>票数正负抵消</strong>： 设数组<code>nums</code>中的众数为<code>x</code>，数组长度为<code>n</code>。若<code>nums</code>的前<code>a</code>个数字的<strong>票数和$=0$</strong>，则数组后<code>(n−a)</code>个数字的<strong>票数和一定仍$&gt;0$</strong>（即后<code>(n−a)</code>个数字的<strong>众数仍为<code>x</code></strong>）。</li>
</ol>
</li>
</ol>
<p><img src="/2020/07/15/Offer-Week4/zhongshu.png"></p>
<h4 id="算法时间复杂度-2"><a href="#算法时间复杂度-2" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <strong>时间复杂度$O(N)$ ：</strong>$N$为数组 <code>nums</code> 长度。 </p>
<h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>, count = <span class="number">0</span>;       <span class="comment">// x记录众数，votes记录票数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>)&#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span>(num == x) count++;</span><br><span class="line">        <span class="keyword">return</span> count &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span> ? x : <span class="number">0</span>; <span class="comment">// 当无众数时返回 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h1><p>输入n个整数，找出其中最小的k个数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>数据保证k一定小于等于输入数组的长度;</li>
<li>输出数组内元素请按<strong>从小到大顺序排序</strong>;</li>
</ul>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] , k=<span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>优先队列，最小的K个数，大顶堆；最大的K个数，小顶堆</strong></p>
<p>应该使用<strong>大顶堆</strong>来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<h4 id="算法时间复杂度-3"><a href="#算法时间复杂度-3" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> 复杂度：$O(NlogK) + O(K)$ </p>
<h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;arr.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">		priority_queue&lt;<span class="keyword">int</span>&gt; heap;			<span class="comment">// 申请一个堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)&#123;</span><br><span class="line">            heap.push(x);					<span class="comment">// 将元素放入堆</span></span><br><span class="line">            <span class="keyword">if</span>(heap.<span class="built_in">size</span>()&gt;k)				<span class="comment">// 数组长度大于k，将对顶元素删除</span></span><br><span class="line">                heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(heap.<span class="built_in">size</span>()) res.push_back(heap.top()),heap.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><p>如何得到一个<strong>数据流中的中位数</strong>？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>,<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">2.5</span></span><br><span class="line">解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。</span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>大小顶堆，</strong></p>
<p><img src="/2020/07/15/Offer-Week4/dataflow.png"></p>
<p>建立一个<strong>小顶堆$A$</strong>和一个<strong>大顶堆$B$</strong>，各保存列表的一般元素，且规定：</p>
<ul>
<li>$A$保存<strong>较大</strong>的一半，长度位$\frac{N}{2}，(N为偶数)$或$\frac{N+1}{2}，(N为奇数)$；</li>
<li>$A$保存<strong>较小</strong>的一半，长度位$\frac{N}{2}，(N为偶数)$或$\frac{N-1}{2}，(N为奇数)$；</li>
</ul>
<h4 id="算法时间复杂度-4"><a href="#算法时间复杂度-4" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度</strong>：</p>
<p>查找中位数$O(1)$： 获取堆顶元素使用$O(1)$时间；<br>添加数字$O(logN)$： 堆的插入和弹出操作使用$O(logN)$时间。</p>
<h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        max_heap.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_heap.<span class="built_in">size</span>() &amp;&amp; max_heap.top() &gt; min_heap.top())  <span class="comment">// **1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxv = max_heap.top(), minv = min_heap.top();</span><br><span class="line">            max_heap.pop(), min_heap.pop();</span><br><span class="line">            max_heap.push(minv), min_heap.push(maxv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(max_heap.<span class="built_in">size</span>() &gt; min_heap.<span class="built_in">size</span>() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_heap.push(max_heap.top());</span><br><span class="line">            max_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((max_heap.<span class="built_in">size</span>() + min_heap.<span class="built_in">size</span>()) &amp; <span class="number">1</span>) <span class="keyword">return</span> max_heap.top();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (max_heap.top() + min_heap.top()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p>输入一个 <strong>非空</strong> 整型数组，数组里的数可能为正，也可能为负。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">-4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">-5</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划</strong></p>
<p><img src="/2020/07/15/Offer-Week4/sunarr.png"></p>
<ul>
<li><strong>状态定义：</strong>设动态规划列表$dp$ ，$dp[i]$代表以元素$nums[i]$为结尾的连续子数组最大和。 <ul>
<li>为何定义最大和$dp[i]$中必须包含元素$nums[i]$：保证$dp[i]$递推到$dp[i+1]$的正确性；如果不包含 $nums[i]$，递推时则不满足题目的<strong>连续子数组</strong>要求。</li>
</ul>
</li>
<li><strong>转移方程：</strong>若$dp[i-1] \leq 0$，说明$dp[i−1]$对$dp[i]$产生负贡献，即$dp[i−1]+nums[i]$还不如$nums[i]$本身大。<ul>
<li>$dp[i]=dp[i-1]+nums[i],dp[i-1]&gt;0$</li>
<li>$dp[i]=nums[i],dp[i-1]\leq0$</li>
</ul>
</li>
<li><strong>初始状态：</strong>$dp[0]=nums[0]$，即以$nums[0]$结尾的连续子数组最大和为$nums[0]$</li>
<li><strong>返回值：</strong>返回$dp$列表中最大值</li>
</ul>
<h4 id="算法时间复杂度-5"><a href="#算法时间复杂度-5" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <strong>时间复杂度$O(N)$：</strong> 线性遍历数组$nums$即可获得结果，使用$O(N)$时间。 </p>
<h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s &gt; 0: s + x;</span></span><br><span class="line"><span class="comment">s &lt;=0: x;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            s += x;</span><br><span class="line">            res = <span class="built_in">max</span>(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="从1到n整数中1出现的次数"><a href="#从1到n整数中1出现的次数" class="headerlink" title="从1到n整数中1出现的次数"></a>从1到n整数中1出现的次数</h1><p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。</p>
<h4 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入： <span class="number">12</span></span><br><span class="line">输出： <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p> 将$1 ~ n$的<strong>个位</strong>、<strong>十位</strong>、<strong>百位</strong>、…的1出现次数相加，即为1出现的总次数。 </p>
<p><img src="/2020/07/15/Offer-Week4/1-n.png"></p>
<p>算法时间复杂度</p>
<p>C++代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number;</span><br><span class="line">        <span class="keyword">while</span>(n) number.push_back(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = number.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = number.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; --j) left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) right = right * <span class="number">10</span> + number[j], t *= <span class="number">10</span>;</span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(number[i] &gt;<span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer——Week3</title>
    <url>/2020/07/14/Offer-Week3/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p><strong>思考题：</strong></p>
<ul>
<li>请同时实现迭代版本和递归版本。</li>
</ul>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入:<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="literal">NULL</span></span><br><span class="line">输出:<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>链表操作，迭代，$O(n)$</strong></p>
<p>翻转即将所有节点的next指针指向前驱节点。<br>由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。</p>
<h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>只遍历一次链表，时间复杂度是 $O(n)$</p>
<h5 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span> , <span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>二路归并，$O(n)$</strong></p>
<ol>
<li><strong>初始化：</strong> 伪头节点$dummy$ ，节点$cur$ 指向$dummy$。 </li>
<li><strong>循环合并：</strong> 当$l_1$或$l_2$为空时跳出；<ol>
<li>当$l_1-&gt;val<l_2->val$时，$cur$的后继结点指向$l_1$，并且$l_1$向前走一步；</l_2-></li>
<li>当$l_1-&gt;val&gt;=l_2-&gt;val$时，$cur$的后继结点指向$l_2$，并且$l_2$向前走一步；</li>
<li>结点$cur$向前走一步，即$cur=cur-&gt;next$。</li>
</ol>
</li>
<li><strong>合并剩余尾部：</strong>跳出时有两种情况，即$l_1$为空或$l_2$为空；<ol>
<li>若$l_1\neq null$：将$l_1$添加至结点$cur$之后；</li>
<li>否则：将$l_2$添加至阶段$cur$之后。</li>
</ol>
</li>
<li><strong>返回值：</strong>合并链表在伪头节点$dummy$之后，因此返回$dummy-&gt;next$。</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/merge.png" style="width:50%"></p>
<h4 id="算法时间复杂度-1"><a href="#算法时间复杂度-1" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>$O(m+n)$：分别为两个链表的长度</p>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">		ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = l1 != <span class="literal">nullptr</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p>输入两棵二叉树A，B，判断B是不是A的子结构。我们规定空树不是任何树的子结构。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">树A：    </span><br><span class="line">     <span class="number">8</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">8</span>   <span class="number">7</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line">树B：</span><br><span class="line">   <span class="number">8</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>   <span class="number">2</span></span><br><span class="line">返回：<span class="literal">true</span>，因为B是A的子结构。</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>二叉树，递归，$O(nm)$</strong></p>
<ol>
<li>先序遍历树$A$中的每个结点$n_A$——对应函数：<code>isSubStructure(A, B)</code></li>
<li>判断树$A$中<strong>以$n_A$为根节点的子树是否包含树</strong>$B$——对应函数：<code>recur(A, B)</code></li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/suntree.png" style="width:50%"></p>
<p><strong>步骤</strong>：</p>
<p><strong><code>recur(A, B)</code>函数：</strong></p>
<ol>
<li><strong>终止条件：</strong><ol>
<li>当节点$B$为空：说明树$B$已经匹配完成（越过叶子节点），因此返回<code>true</code>;</li>
<li>当节点$A$为空：说明已经越过树$A$的叶子节点，即匹配失败，返回<code>false</code>；</li>
<li>当节点$A$和$B$的值不同：说明匹配失败，返回<code>false</code>；</li>
</ol>
</li>
<li><strong>返回值：</strong><ol>
<li>判断$A$和$B$的<strong>左子节点</strong>是否相等，即 <code>recur(A.left, B.left)</code> ； </li>
<li>判断$A$和$B$的<strong>右子节点</strong>是否相等，即 <code>recur(A.right, B.right)</code> ； </li>
</ol>
</li>
</ol>
<p><strong><code>isSunStructure(A, B)函数：</code></strong></p>
<ol>
<li><strong>特例处理：</strong>当树$A$为空或者树$B$为空时，返回<code>false</code>；</li>
<li><strong>返回值：</strong>若树$B$是树$A$的子结构，<strong>必须满足以下三种情况之一</strong>，用<code>||</code>连接；<ol>
<li><strong>以节点$A$为根节点的子树包含树$B$</strong> ，对应 <code>recur(A, B)</code>； </li>
<li><strong>树$B$是树$A$左子树的子结构</strong>，对应 <code>isSubStructure(A.left, B)</code>； </li>
<li><strong>树$B$是树$A$右子树的子结构</strong>，对应 <code>isSubStructure(A.right, B)</code>；</li>
</ol>
</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/sub_1.png"></p>
<p><img src="/2020/07/14/Offer-Week3/sub_2.png"></p>
<p><img src="/2020/07/14/Offer-Week3/sub_3.png"></p>
<p><img src="/2020/07/14/Offer-Week3/sub_4.png"></p>
<h4 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h4><p>$O(nm)$：分别为两棵树的节点数量 </p>
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(recur(A, B)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!A || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p>输入一个二叉树，将它变换为它的<strong>镜像</strong>。</p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入树：</span><br><span class="line">      <span class="number">8</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">6</span>  <span class="number">10</span></span><br><span class="line">   / \ / \</span><br><span class="line">  <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br><span class="line"> [<span class="number">8</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,null,null,null,null,null,null,null,null] </span><br><span class="line">输出树：</span><br><span class="line">      <span class="number">8</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">10</span>  <span class="number">6</span></span><br><span class="line">   / \ / \</span><br><span class="line">  <span class="number">11</span> <span class="number">9</span> <span class="number">7</span>  <span class="number">5</span></span><br><span class="line"> [<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,null,null,null,null,null,null,null,null]</span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/" target="_blank" rel="noopener">思路</a></h4><p><strong>递归，$O(n)$</strong></p>
<ul>
<li>根据二叉树镜像的定义，递归二叉树交换每个节点的左/右子节点。</li>
</ul>
<ol>
<li><strong>终止条件：</strong>当节点$root$为空时（即越过叶子节点），返回<code>nullptr</code>；</li>
<li><strong>递归条件：</strong><ol>
<li>初始化节点$tmp$，用于暂存$root$的左子节点；</li>
<li>开启递归<strong>右子节点</strong><code>mirrorTree(root-&gt;right)</code>，并返回值作为$root$的<strong>左子节点</strong>；</li>
<li>开启递归<strong>左子节点</strong><code>mirrorTree(tmp)</code>，并返回值作为$root$的<strong>右子节点</strong>；</li>
</ol>
</li>
<li><strong>返回值：</strong>返回房前节点$root$。</li>
</ol>
<blockquote>
<p>Q： 为何需要暂存$root$的左子节点？<br>A： 在递归右子节点<code>root-&gt;left = mirrorTree(root-&gt;right);</code> 执行完毕后，<code>root-&gt;left</code>的值已经发生改变，此时递归左子节点<code>mirrorTree(root-&gt;left)</code>则会出问题。</p>
</blockquote>
<p><img src="/2020/07/14/Offer-Week3/mirror_21.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_22.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_23.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_24.png"></p>
<p><strong>辅助栈：</strong></p>
<ul>
<li>利用栈（或队列）遍历树的所有节点$node$，并交换每个$node$的左/右子节点</li>
</ul>
<ol>
<li><strong>特例处理：</strong>当节点$root$为空时，返回<code>nullptr</code>；</li>
<li><strong>初始化：</strong>栈（或队列），并加入根节点$root$；</li>
<li><strong>循环交换：</strong>当栈$stack$为空时跳出；<ol>
<li><strong>出栈：</strong>记为$node$；</li>
<li><strong>添加子节点：</strong>将$node$左和右子节点入栈；</li>
<li><strong>交换：</strong>交换$node$的左/右子节点。</li>
</ol>
</li>
<li><strong>返回值：</strong>返回根节点$root$</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/mirror_1.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_2.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_3.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_4.png"></p>
<p><img src="/2020/07/14/Offer-Week3/mirror_5.png"></p>
<h4 id="算法时间复杂度-2"><a href="#算法时间复杂度-2" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度$O(N)$ ：</strong> 其中$N$为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用$O(N)$时间。 </p>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 辅助栈 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>) s.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) s.push(node-&gt;right);</span><br><span class="line">            TreeNode* tmp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \ &#x2F; \</span><br><span class="line">   4 4  3</span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>自上而下递归，二叉树，$O(n)$</strong></p>
<p><code>isSynmetric(root)</code>：</p>
<ol>
<li><strong>特例处理：</strong>若根节点$root$为空，直接返回<code>true</code>；</li>
<li><strong>返回值：</strong>即<code>recur(root-&gt;left, root-&gt;right)</code>;</li>
</ol>
<p><code>recur(L, R)</code>：</p>
<ol>
<li><strong>终止条件：</strong><ol>
<li>当$L$和$R$同时越过叶子节点：此树自上而下的节点都对称，返回<code>true</code>；</li>
<li>当$L$或$R$中只有一个越过叶节点：此树步对称，因此返回<code>false</code>；</li>
<li>当节点$L-&gt;val \neq R-&gt;val$：此树不对称，因此返回<code>false</code>；</li>
</ol>
</li>
<li><strong>递推工作：</strong><ol>
<li>判断两个节点$L-&gt;left$和$R-&gt;right$是否对称：<code>recur(L-&gt;left, R-&gt;right)</code>；</li>
<li>判断两个节点$L-&gt;right$和$R-&gt;left$是否对称：<code>recur(L-&gt;right, R-&gt;left)</code>；</li>
</ol>
</li>
<li><strong>返回值：</strong>两对节点对称时，才是对称树，逻辑与<code>&amp;&amp;</code>。</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/dui_1.png"></p>
<p><img src="/2020/07/14/Offer-Week3/dui_2.png"></p>
<p><img src="/2020/07/14/Offer-Week3/dui_3.png"></p>
<p><img src="/2020/07/14/Offer-Week3/dui_4.png"></p>
<p><img src="/2020/07/14/Offer-Week3/dui_5.png" style="width:50%"></p>
<h4 id="算法时间复杂度-3"><a href="#算法时间复杂度-3" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>$O(n)$：其中$n$为二叉树的节点数量</p>
<h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="literal">true</span> : recur(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* L, TreeNode* R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == <span class="literal">nullptr</span> &amp;&amp; R == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(L == <span class="literal">nullptr</span> || R == <span class="literal">nullptr</span> || L-&gt;val != R-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L-&gt;left, R-&gt;right) &amp;&amp; recur(L-&gt;right, R-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>模拟，$O(n^2)$</strong></p>
<ol>
<li>顺时针定义四个方向：上、右、下、左。</li>
<li>从左上角开始遍历，先往右走，走到不能走为止；</li>
<li>然后更改到下个方向，再走到不能走为止；</li>
<li>依次类推，遍历$n^2$ 个格子后停止。</li>
</ol>
<h4 id="算法时间复杂度-4"><a href="#算法时间复杂度-4" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>矩阵中每个格子遍历一次，所以总时间复杂度是$O(n^2)$。</p>
<h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">st</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>))</span></span>;		<span class="comment">// 记录访问状态</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;		<span class="comment">// 定义运动方向</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;					<span class="comment">// 初始状态为[0, 0]，初始方向为右：1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n * m; k ++ )&#123;</span><br><span class="line">            res.push_back(matrix[x][y]);			<span class="comment">// 初始点加入结果数组</span></span><br><span class="line">            st[x][y] = <span class="literal">true</span>;						<span class="comment">// 改变当前点的状态为已访问</span></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];		<span class="comment">// 计算下一次的步数</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;		<span class="comment">// 不可达状态</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p>
<ul>
<li>push(x)–将元素x插入栈中</li>
<li>pop()–移除栈顶元素</li>
<li>top()–得到栈顶元素</li>
<li>min()–得到栈中最小元素</li>
</ul>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-1</span>);</span><br><span class="line">minStack.push(<span class="number">3</span>);</span><br><span class="line">minStack.push(<span class="number">-4</span>);</span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-4.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns <span class="number">3.</span></span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-1.</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><strong>辅助栈（单调栈）</strong></p>
<p><strong>函数设计：</strong></p>
<ul>
<li><strong><code>push(x)</code>函数：</strong>保持栈$B$的元素是<strong>严格降序</strong>的；<ul>
<li>将$x$压入栈$A$（即<code>push(x)</code>）；</li>
<li>若<strong>栈$B$为空</strong><code>|| x &lt;= B.top()</code>，则将$x$压入栈$B$（即<code>B.push(x)</code>）。</li>
</ul>
</li>
<li><strong><code>pop()</code>函数：</strong>保持栈$A$、$B$的<strong>元素一致性</strong>；<ul>
<li>执行<code>A.pop()</code>，将出战元素记为<code>y</code>；</li>
<li>若<code>y == B.top()</code>，则执行$B$出栈（即<code>B.pop()</code>）。</li>
</ul>
</li>
<li><strong><code>top()</code>函数：</strong>直接返回栈$A$的栈顶元素即可（<code>A.top()</code>）;</li>
<li><strong><code>min()</code>函数：</strong>直接返回栈$B$的栈顶元素即可（<code>B.top()</code>）;</li>
</ul>
<h4 id="算法时间复杂度-5"><a href="#算法时间复杂度-5" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <code>push()</code>, <code>pop()</code>, <code>top()</code>, <code>min()</code> 四个函数的时间复杂度均为常数级别$O(1)$。 </p>
<h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackValue;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackMin;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		stackValue.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stackMin.empty() || stackMin.top() &gt;= x)</span><br><span class="line">            stackMin.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(stackMin.top() == stackValue.top()) stackMin.pop();</span><br><span class="line">        stackValue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stackValue.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stackMin.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p><strong>输入两个整数序列</strong>，第一个序列表示栈的<strong>压入顺序</strong>，请<strong>判断第二个序列是否可能为该栈的弹出顺序</strong>。假设压入栈的所有数字均不相等。</p>
<p><strong>注意</strong>：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p>
<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">      [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>模拟，辅助栈，$O(n)$</strong></p>
<ul>
<li><strong>入栈：</strong> 按照压栈序列的顺序执行。 </li>
<li><strong>出栈：</strong> 每次入栈后，循环判断“栈顶元素 == 弹出序列的当前元素”是否成立，将符合弹出序列顺序的栈顶元素全部弹出。 </li>
</ul>
<p><strong>流程：</strong></p>
<ol>
<li><strong>初始化：</strong>辅助栈<code>stack</code>，弹出序列的索引<code>i</code>；</li>
<li><strong>遍历压栈序列：</strong>各元素记为<code>num</code>；<ol>
<li>元素<code>num</code>入栈；</li>
<li>循环出栈：若<code>stack.top() == popped[i]; ++i;</code>；</li>
</ol>
</li>
<li><strong>返回值：</strong>若<code>stack</code>为空，则此弹出序列合法</li>
</ol>
<h4 id="算法时间复杂度-6"><a href="#算法时间复杂度-6" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <strong>时间复杂度$O(N)$：</strong> 其中$N$为列表$pushed$的长度；每个元素最多入栈与出栈一次，即最多共$2N$次出入栈操作。 </p>
<h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pushed.<span class="built_in">size</span>() != popped.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;				<span class="comment">// 申请辅助栈</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; 				<span class="comment">// 记录弹出索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); ++i)&#123;		<span class="comment">// 模拟入栈操作</span></span><br><span class="line">            s.push(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popped[index])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="不分行从上往下打印二叉树（层次）"><a href="#不分行从上往下打印二叉树（层次）" class="headerlink" title="不分行从上往下打印二叉树（层次）"></a>不分行从上往下打印二叉树（层次）</h1><p>从上往下打印出二叉树的每个结点，<strong>同一层的结点按照从左到右的顺序打印</strong>。</p>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, null, null, <span class="number">6</span>, null, <span class="number">4</span>, null, null, null]</span><br><span class="line">    <span class="number">8</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">2</span></span><br><span class="line">     /</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">   /</span><br><span class="line">  <span class="number">4</span></span><br><span class="line">输出：[<span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>BFS，层次遍历，$O(n)$</strong></p>
<p>BFS 通常借助<strong>队列</strong>的先入先出特性来实现。 </p>
<ol>
<li><strong>特例处理：</strong>当树的结点为空，直接返回<code>[]</code></li>
<li><strong>初始化：</strong>打印结果列表<code>res = []</code>，包含根节点的队列<code>queue = [root]</code></li>
<li><strong>BFS循环：</strong>当队列<code>queue</code>为空时跳出<ol>
<li><strong>出队：</strong>队首元素出队，记为<code>node</code></li>
<li><strong>打印：</strong>将<code>node-&gt;val</code>添加到列表<code>res</code>尾部</li>
<li><strong>添加子节点：</strong>若<code>node</code>的左（右）子树节点不空，则将左（右）子节点加入队列<code>queue</code></li>
</ol>
</li>
<li><strong>返回值：</strong>返回打印结果列表<code>res</code>即可</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/level_1.png"></p>
<p><img src="/2020/07/14/Offer-Week3/level_2.png"></p>
<p><img src="/2020/07/14/Offer-Week3/level_3.png"></p>
<h4 id="算法时间复杂度-7"><a href="#算法时间复杂度-7" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p> <strong>时间复杂度$O(N)$：</strong>$N$为二叉树的节点数量，即BFS需循环$ N$次。</p>
<h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;				<span class="comment">// 辅助队列</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="分行从上往下打印二叉树"><a href="#分行从上往下打印二叉树" class="headerlink" title="分行从上往下打印二叉树"></a>分行从上往下打印二叉树</h1><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，<strong>每一层打印到一行</strong>。</p>
<h4 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, null, null, <span class="number">6</span>, null, <span class="number">4</span>, null, null, null]</span><br><span class="line">    <span class="number">8</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">12</span>  <span class="number">2</span></span><br><span class="line">     /</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">   /</span><br><span class="line">  <span class="number">4</span></span><br><span class="line">输出：[[<span class="number">8</span>], [<span class="number">12</span>, <span class="number">2</span>], [<span class="number">6</span>], [<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>BFS，$O(n)$</strong></p>
<ol>
<li><strong>特例处理：</strong>当树的结点为空，直接返回<code>[]</code>（<strong>同上</strong>）</li>
<li><strong>初始化：</strong>打印结果列表<code>res = []</code>，包含根节点的队列<code>queue = [root]</code><strong>（同上）</strong></li>
<li><strong>BFS循环：</strong>当队列<code>queue</code>为空时跳出<ol>
<li><strong>新建一个临时列表<code>tmp</code>，用于存储当前层的打印结果</strong>\</li>
<li><strong>当前层打印循环：</strong>循环次数为当前层节点数（队列<code>queue</code>长度）<ol>
<li><strong>出队：</strong>队首元素出队，记为<code>node</code></li>
<li><strong>打印：</strong>将<code>node-&gt;val</code>添加到列表<code>tmp</code>尾部</li>
<li><strong>添加子节点：</strong>若<code>node</code>的左（右）子树节点不空，则将左（右）子节点加入队列<code>queue</code></li>
</ol>
</li>
<li>当前层结果<code>tmp</code>添加到<code>res</code></li>
</ol>
</li>
<li><strong>返回值：</strong>返回打印结果列表<code>res</code>即可</li>
</ol>
<p><img src="/2020/07/14/Offer-Week3/level_11.png"></p>
<p><img src="/2020/07/14/Offer-Week3/level_22.png"></p>
<p><img src="/2020/07/14/Offer-Week3/level_33.png"></p>
<h4 id="算法时间复杂度-8"><a href="#算法时间复杂度-8" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度$O(N)$：</strong>$N$为二叉树的节点数量，即BFS需循环$ N$次。</p>
<h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;				<span class="comment">// 辅助队列</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;			<span class="comment">// 临时列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;	<span class="comment">// 多一层循环 计算每一层的输出</span></span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>) q.push(node-&gt;left);</span><br><span class="line">            	<span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Z字形打印二叉树"><a href="#Z字形打印二叉树" class="headerlink" title="Z字形打印二叉树"></a>Z字形打印二叉树</h1><p>请实现一个函数<strong>按照之字形顺序从上向下打印二叉树</strong>。即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<h4 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[8, 12, 2, null, null, 6, 4, null, null, null, null]</span><br><span class="line">    8</span><br><span class="line">   &#x2F; \</span><br><span class="line">  12  2</span><br><span class="line">     &#x2F; \</span><br><span class="line">    6   4</span><br><span class="line">输出：[[8], [2, 12], [6, 4]]</span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p><strong>BFS，$O(n)$</strong></p>
<p>同上一题，<strong>偶数层倒叙（<code>res.size() % 2 == 1</code>），奇数层顺序(<code>res.size() % 2 == 0</code>)</strong>。</p>
<h4 id="算法时间复杂度-9"><a href="#算法时间复杂度-9" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p><strong>时间复杂度$O(N)$：</strong>$N$为二叉树的节点数量，即BFS需循环$ N$次。</p>
<h4 id="C-代码-10"><a href="#C-代码-10" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;							<span class="comment">// 辅助队列</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;						<span class="comment">// 临时列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;		<span class="comment">// 多一层循环 计算每一层的输出</span></span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>) q.push(node-&gt;left);</span><br><span class="line">            	<span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) reverse(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——查找</title>
    <url>/2020/07/12/DataStructure-Search/</url>
    <content><![CDATA[<p><img src="/2020/07/12/DataStructure-Search/1.png" style="width:50%"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>定义</strong>：在数据结构中寻找满足某种条件的数据元素的过程，查找成功与查找失败。</p>
<p><strong>查找表</strong>：用于查找的数据集合，由同一种数据类型（或记录）的组成，可以是一个数组或链表等数据类型。</p>
<p><strong>操作</strong>：</p>
<ul>
<li>查询某个特定的数据元素是否在查找表中</li>
<li>检索满足条件的某个特定的数据元素的各种属性</li>
<li>在查找表中插入一个元素</li>
<li>从查找表中删除一个元素</li>
</ul>
<p>前两种：<strong>静态查找表</strong>；前四个：<strong>动态查找表</strong></p>
<p><strong>关键字</strong>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p>
<p><strong>平均查找长度</strong>：查找时，关键字比较次数的平均值——$ASL=\sum_{i=1}^nP_iC_i$</p>
<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>最简单，最好理解。从头开始进行比较。</p>
<p>也称为<strong>线性查找（可以有序，也可以无序）</strong>，主要用于在线性表中进行查找。</p>
<h2 id="无序线性表的顺序查找"><a href="#无序线性表的顺序查找" class="headerlink" title="无序线性表的顺序查找"></a>无序线性表的顺序查找</h2><p><strong>无序线性表进行顺序查找，查找失败时要遍历整个线性表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key;		<span class="comment">// 哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ST.TableLen;ST.elem[i]!=key;--i)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度</strong>：</p>
<p>$ASL_{success}=\sum_{i=1}^n P_iC_i=\sum_{i=1}^nP_i(n-i+1)=\sum_{i=1}^n\frac{1}{n}*(n-i+1)=\frac{n+1}{2}$</p>
<p>$ASL_{failed}=\sum_{i=1}^nP_iC_i=\sum_{i=1}^n\frac{1}{n}*(n+1)=n+1$</p>
<h2 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h2><p><strong>对关键字有序线性表进行顺序查找，查找失败不一定要遍历整个线性表，遍历到比它大的元素就可以</strong></p>
<p><strong>判定树</strong>：描述查找过程的二叉排序树</p>
<p><img src="/2020/07/12/DataStructure-Search/234.png"></p>
<p><strong>平均查找长度</strong>：$n+1$个失败节点</p>
<p>$ASL_{failed}=\sum_{i=1}^nP_iC_i=\sum_{i=1}^n\frac{1}{n+1}=\frac{1+2+…+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$</p>
<h1 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h1><p><strong>仅适用于有序表的顺序表——数组</strong></p>
<p><strong>思想</strong>：</p>
<ul>
<li>首先将给定值key与表中中间位置的元素进行比较</li>
<li>若相等，就返回该元素的位置</li>
<li>若不等，则在前半部分或后半部分进行查找</li>
</ul>
<p>查找升序序列时：</p>
<ul>
<li>若key小于中间元素，则查找前半部分</li>
<li>若key大于中间元素，则查找后半部分</li>
</ul>
<p>重复该过程，直到查找到元素为止；或者查找失败</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1l</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判定树</strong>：</p>
<p><img src="/2020/07/12/DataStructure-Search/5.png" style="width:50%"></p>
<p><img src="/2020/07/12/DataStructure-Search/6.png" style="width:40%"></p>
<p><strong>平均查找效率</strong>：成功——$log_2(n+1)$</p>
<p><strong>顺序查找适用于顺序存储和链式存储，序列有序无序皆可；折半查找只适用于顺序存储，且要求序列一定有序</strong></p>
<h1 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h1><p>索引序列查找，吸取了顺序查找和折半查找的各自优点，既有动态结构，又适用于快速查找。</p>
<p><strong>分块</strong>：<strong>块内无序块间有序</strong></p>
<ul>
<li>将查找表分成若干子块，<strong>块内的元素可以无序，但是快间有序的</strong>，即对于所有块有<strong>第<code>i</code>块的最大关键字小于第<code>i+1</code>块的所有记录的关键字</strong>。</li>
<li>建立索引表，索引表中每个元素含有<strong>各块的最大关键字和各块中第一个元素的地址</strong>，索引表<strong>按照关键字有序排列</strong>。</li>
</ul>
<p><img src="/2020/07/12/DataStructure-Search/7.png" style="width:60%"></p>
<p><strong>查找</strong>：<strong>两步</strong></p>
<ol>
<li>在索引表中<strong>确定待查记录所在的块</strong>，可以顺序查找也可以折半查找索引表。</li>
<li>在<strong>块内进行顺序查找</strong>。</li>
</ol>
<p><strong>平均查找长度</strong>：</p>
<p>分块查找的平均查找长度为索引查找（$LI$）和块内查找（$LS$）之和。</p>
<p>设长度为$n$的查找表均匀分为b块，每块记录有$s$个记录。</p>
<p>成功——$L_i+L_s$</p>
<ul>
<li><p><strong>若块内和块间均用顺序查找</strong>：成功——$L_i+L_s=\frac{s^2+2s+n}{2s}=\sqrt n +1$</p>
</li>
<li><p><strong>若块内采用顺序查找，块间使用折半查找</strong>：成功——$L_i+L_s=log_2(b+1)+\frac{s+1}{2}$</p>
</li>
</ul>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p><strong>B树的阶</strong>：又称为多路平衡查找树，B树中所有结点的<strong>孩子结点数</strong>的最大值成为B树的阶。</p>
<p><strong>特性</strong>：一棵$m$阶$B$树或为空树，或为满足以下条件的$m$叉树：</p>
<p><img src="/2020/07/12/DataStructure-Search/9.png" style="width:60%"></p>
<ol>
<li>树中每个节点至多有$m$棵子树（即至多含有$m-1$个关键字）</li>
<li>若根节点不是终端节点，则至少有两棵子树</li>
<li>除根节点之外，所有的非叶子结点至少有$m/2$取上界棵子树（即$m/2$取上界$-1$个关键字）</li>
<li>非叶结点的结构：</li>
</ol>
<p><img src="/2020/07/12/DataStructure-Search/8.png" style="width:60%"></p>
<p>$K_i$($i\in 1,2,…,n$)为结点的关键字，$K_1&lt;K_2&lt;…&lt;K_n$，</p>
<p>$P_i(i=0,1,2,…,n)$为子树根节点的指针，$P_{i-1}$所指子树的关键字均小于$K_i$，$P_i$所指子树的关键字均大于$K_i$。</p>
<ol>
<li>所有叶结点都出现在同一层上，并不带任何信息</li>
</ol>
<p><strong>$n$个关键字，阶数为$m$，高度为$h$的$B$树：</strong></p>
<p><img src="/2020/07/12/DataStructure-Search/10.png" style="width:50%"></p>
<p><strong>查找</strong>：</p>
<p><img src="/2020/07/12/DataStructure-Search/11.png" style="width:50%"></p>
<ol>
<li>在$B$树中查找结点——<strong>磁盘</strong></li>
<li>在结点中找关键字——<strong>内存</strong></li>
</ol>
<p><strong>插入：</strong></p>
<ol>
<li><p><strong>定位</strong>：查找插入该关键字的位置，即<strong>最底层某个非叶子结点</strong>（规定一定是插入在最底层的某个非叶子结点内，不需要调整）</p>
</li>
<li><p><strong>插入</strong>：若插入后，不会破坏$m$阶二叉树的定义，<strong>即插入后结点关键字个数在属于区间[$m/2$上界$-1$，$m-1$]，则直接插入</strong>；</p>
<p><img src="/2020/07/12/DataStructure-Search/12.png" style="width:50%"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer——Week2</title>
    <url>/2020/07/11/Offer-Week2/</url>
    <content><![CDATA[<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><p>地上有一个<code>m</code>行和<code>n</code>列的方格，横纵坐标范围分别是<code>0∼m−1</code>和 <code>0∼n−1</code>。一个机器人从坐标<code>[0,0]</code>的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。但是不能进入<strong>行坐标和列坐标的数位之和大于<code>k</code>的格子</strong>。请问该机器人能够达到多少个格子？</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：k=<span class="number">7</span>, m=<span class="number">4</span>, n=<span class="number">5</span></span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h4 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：k=<span class="number">18</span>, m=<span class="number">40</span>, n=<span class="number">40</span></span><br><span class="line">输出：<span class="number">1484</span></span><br><span class="line">解释：当k为<span class="number">18</span>时，机器人能够进入方格（<span class="number">35</span>,<span class="number">37</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">7</span> = <span class="number">18</span>。</span><br><span class="line">      但是，它不能进入方格（<span class="number">35</span>,<span class="number">38</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">8</span> = <span class="number">19</span>。</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:</p>
<ol>
<li><code>0&lt;=m&lt;=50</code></li>
<li><code>0&lt;=n&lt;=50</code></li>
<li><code>0&lt;=k&lt;=100</code></li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>BFS，$O(nm)$</strong></p>
<p>这是一个典型的宽度优先搜索问题，我们从 (0, 0) 点开始，每次朝上下左右四个方向扩展新的节点即可。</p>
<p>扩展时需要<strong>注意新的节点需要满足如下条件</strong>：</p>
<ul>
<li>之前<strong>没有遍历过</strong>，这个可以用个<code>bool</code>数组来判断；</li>
<li><strong>没有走出边界</strong>；</li>
<li><strong>横纵坐标的各位数字之和小于<code>k</code></strong>；</li>
</ul>
<p>最后答案就是所有遍历过的合法的节点个数。</p>
<p><img src="/2020/07/11/Offer-Week2/q1.png"></p>
<p><img src="/2020/07/11/Offer-Week2/q2.png"></p>
<p><img src="/2020/07/11/Offer-Week2/q3.png"></p>
<p><img src="/2020/07/11/Offer-Week2/q4.png"></p>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>每个节点最多只会入队一次，所以时间复杂度<strong>不会超过方格中的节点个数</strong>。<br>最坏情况下会遍历方格中的所有点，所以时间复杂度就是$O(nm)$。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;				<span class="comment">// 计算 x 的数位之和</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">            res += x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; Q;		<span class="comment">// 建立搜索队列</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;				<span class="comment">// 向右和向下的方向数组</span></span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>; <span class="comment">// 遍历状态数组</span></span><br><span class="line">        Q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);					<span class="comment">// 加入起点</span></span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;					<span class="comment">// 起点状态为1</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;					<span class="comment">// 答案+1</span></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = Q.front();		<span class="comment">// 队首元素</span></span><br><span class="line">            Q.pop();						<span class="comment">// 弹出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = dx[i] + x;</span><br><span class="line">                <span class="keyword">int</span> ty = dy[i] + y;</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= m || ty &lt; <span class="number">0</span> || ty &gt;= n || vis[tx][ty] || <span class="built_in">get</span>(tx) + <span class="built_in">get</span>(ty) &gt; k) <span class="keyword">continue</span>;		 <span class="comment">// 大于阈值条件继续</span></span><br><span class="line">                Q.push(&#123;x, ty&#125;);				<span class="comment">// 满足条件加入队列 </span></span><br><span class="line">                vis[tx][ty] = <span class="number">1</span>;				<span class="comment">// 遍历状态</span></span><br><span class="line">                ans++;							<span class="comment">// 答案加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剪绳子——整数划分"><a href="#剪绳子——整数划分" class="headerlink" title="剪绳子——整数划分"></a>剪绳子——整数划分</h2><p>给你一根长度为$n$绳子，请把绳子剪成$m$段（$m$、$n$都是整数，$2≤n≤58$并且$m≥2$）。每段的绳子的长度记为$k[0]$、$k[1]$、……、$k[m]$。$k[0]$、$k[1]$、…、$k[m]$可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：8</span><br><span class="line">输出：18</span><br></pre></td></tr></table></figure>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>数学，$O(n)$</strong></p>
<p>这道题目是数学中一个很经典的问题。<br>下面我们给出证明：</p>
<p>首先把一个正整数$N$拆分成若干正整数只有有限种拆法，所以存在最大乘积。</p>
<ol>
<li>当$n \leq 3$时，按照规则应不切分，但由于题目要求必须剪成 $m&gt;1$段，因此必须剪出一段长度为$1$的绳子，即返回$1 \times (n−1)$。</li>
<li>当$n&gt;3$时，求$n$除以$3$的整数部分$a$和余数部分$b$（即$n = 3a + b$），并分为以下三种情况：<ul>
<li>当$b=0$时，直接返回$3^a$；</li>
<li>当$b=1$时，要将一个$1 + 3$转换为$2+2$，因此返回$3^{a-1}\times4$；</li>
<li>当$b = 2$时，返回$3^a \times 2$。</li>
</ul>
</li>
</ol>
<p>综上，<strong>选用尽量多的3，直到剩下2或者4时</strong>，用2。</p>
<p><img src="/2020/07/11/Offer-Week2/cut.png" style="width:50%"></p>
<h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>当$n$比较大时，$n$会被拆分成$⌈n/3⌉$个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 $O(n)$。</p>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n &gt; 0, n = n1 + n2 + ... + nk</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b ==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);				<span class="comment">// 情况1</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;	<span class="comment">// 情况2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;					<span class="comment">// 情况3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>输入一个32位整数，输出该数二进制表示中1的个数。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>负数在计算机中用其绝对值的补码来表示。</li>
</ul>
<h4 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">9</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">9</span>的二进制表示是<span class="number">1001</span>，一共有<span class="number">2</span>个<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<h4 id="样例2-1"><a href="#样例2-1" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">-2</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：<span class="number">-2</span>在计算机里会被表示成<span class="number">11111111111111111111111111111110</span>，</span><br><span class="line">      一共有<span class="number">31</span>个<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>位运算，$O(logn)$</strong></p>
<p>迭代进行如下两步，直到$n$变成$0$为止：</p>
<ol>
<li>如果$n$在二进制表示下末尾是$1$，则在答案中加$1$；</li>
<li>将$n$右移一位，也就是将$n$在二进制表示下的最后一位删掉；</li>
</ol>
<p>这里有个难点是<strong>如何处理负数</strong>。在C++中如果我们右移一个负整数，系统会自动在最高位补$1$，这样会导致$n$永远不为$0$，就死循环了。<br><strong>解决办法是把$n$强制转化成无符号整型</strong>，这样$n$的二进制表示不会发生改变，但在右移时系统会自动在最高位补$0$。</p>
<p><img src="/2020/07/11/Offer-Week2/w1.png"></p>
<p><img src="/2020/07/11/Offer-Week2/w2.png"></p>
<p><strong>$n\&amp;(n-1)$</strong></p>
<ul>
<li>$(n-1)$： 二进制数字<code>n</code>最右边的<code>1</code>变成<code>0</code>，此<code>1</code>右边的<code>0</code>都变成<code>1</code>。 </li>
<li>$n\&amp;(n-1)$：  二进制数字<code>n</code>最右边的<code>1</code>变成<code>0</code>，其余不变。 </li>
</ul>
<p><img src="/2020/07/11/Offer-Week2/ww1.png"></p>
<h4 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>每次会将$n$除以$2$，最多会除$logn$次，所以时间复杂度是$O(logn)$。</p>
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*有符号*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;  					<span class="comment">// 转化为无符号整数，表示一样，解释含义不一样</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) s += n &amp; <span class="number">1</span>, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/*无符号*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) res += n &amp; <span class="number">1</span>, n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* n&amp;(n-1)*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>实现函数<em>double Power(double base, int exponent)</em>，求<em>base</em>的 <em>exponent</em>次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>注意：</strong></p>
<ul>
<li>不会出现底数和指数同为0的情况</li>
<li>当底数为0时，指数一定为正</li>
</ul>
<h4 id="样例1-1"><a href="#样例1-1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">10</span> ，<span class="number">2</span></span><br><span class="line">输出：<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h4 id="样例2-2"><a href="#样例2-2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">10</span> ，<span class="number">-2</span>  </span><br><span class="line">输出：<span class="number">0.01</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>快速幂，$O(n)$</strong></p>
<blockquote>
<p>求 $x^n$ 最简单的方法是通过循环将$n$个$x$乘起来，依次求$x^1$, $x^2$, …, $x^{n-1}$, $x^n$，时间复杂度为$O(n)$。<strong>快速幂法</strong>可将时间复杂度降低至$O(log_2n)$，</p>
</blockquote>
<p><strong>快速幂（二进制）</strong></p>
<blockquote>
<p>利用十进制数字$n$的二进制表示，可对快速幂进行数学化解释。</p>
</blockquote>
<ul>
<li>对于任何一个十进制正整数$n$，设其二进制为”$b_m…b_3b_2n_1$“（$b_i$为二进制某位的值，$i\in[1,m]$），则有：<ul>
<li><strong>二进制转十进制</strong>： $n=1b_1+2b_2+4b_3+…+n^{m-1}b_m$（ <em>即二进制转十进制公式</em> ）</li>
<li><strong>幂的二进制展开</strong> ：$x^n=x^{1b_1+2b_2+4b_3+…+n^{m-1}b_m}=x^{1b_1}x{2b_2}x^{4b_3}…x^{2^{m-1}b_m}$</li>
</ul>
</li>
<li>根据以上推导，可把$x^{n}$转化为以下两个问题：<ul>
<li><strong>计算$x^1,x^2,x^4,…,x^{2^{m-1}}$的值</strong>：循环赋值操作$x=x^2$即可；</li>
<li><strong>获取二进制的各位$b_1,b_2,b_3,…,b_m$的值</strong>：循环执行一下操作：<ul>
<li><strong><code>n&amp;1</code>（与操作）</strong>：判断$n$二进制中最右边是否为1；</li>
<li><strong><code>n&gt;&gt;1</code>（移位操作）</strong>：$n$右移一位；</li>
</ul>
</li>
</ul>
</li>
<li>因此，应用以上操作，可在循环中依次计算$x^{2^0b_1},x{2^1b_2}x^{2^2b_3}…x^{2^{m-1}b_m}$的值，并将所有的$x^{2^{i-1}b_i}$累积相乘即可。<ul>
<li>当$b_i=0$时：$x^{2^{i-1}b_i}=1$；</li>
<li>$b_i=1$时：$x^{2^{i-1}b_i}=x^{2^{i-1}}$；</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/11/Offer-Week2/er1.png" style="width:50%"></p>
<p><strong>快速幂（二分法）</strong></p>
<blockquote>
<p> 快速幂实际上是二分思想的一种应用。 </p>
</blockquote>
<ul>
<li><strong>二分推导</strong>：$x^n=x^{n/2}\times x^{n/2}=(x^2)^{n/2}$，令$n/2$为整数，则需要分为奇数和偶数两种情况（设向下取整符号为“//”）：<ul>
<li>当$n$为偶数：$x^n=(x^2)^{n//2}$</li>
<li>当$n$为奇数：$x^n=(x^2)^{n//2}$，即会多出一项$x$</li>
</ul>
</li>
<li><strong>幂结果获取</strong>：<ul>
<li>根据二分推导，可通过循环 $x=x^2$操作，每次把幂从$n$降至$n//2$，直到将幂将为$0$</li>
<li>设$res=1$，则初始状态$x^n=x^n\times res$，则循环二分时，每当$n$为奇数时，将多出的一项$x$乘以$res$，则最终可化为$x^n=x^0\times res=res$，返回$res$即可</li>
</ul>
</li>
</ul>
<p><img src="/2020/07/11/Offer-Week2/er2.png" style="width:50%"></p>
<ul>
<li><strong>转化为位运算</strong>：<ul>
<li>向下整除$n//2$<strong>等价于</strong>右移一位$n&gt;&gt;1$；</li>
<li>取余数$n\%2$<strong>等价于</strong>判断二进制最右一位值$n\&amp;1$；</li>
</ul>
</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>当$x=0$时，直接返回$0$（避免后续$x=1/x$操作报错）</li>
<li>初始化$res=1$</li>
<li>当$n<0$时：把问题转化为$n>=0$的范围内，即执行$x=1/x$，$n=-n$；</0$时：把问题转化为$n></li>
<li>循环计算：当$x=0$时跳出：<ol>
<li>当$n\&amp;1=1$时：将当前$x$乘入$res$（即$res*=x$）</li>
<li>执行$x=x^2$（即$x*=x$）</li>
<li>执行$n$右移一位（即$n&gt;&gt;=1$）</li>
</ol>
</li>
<li>返回$res$</li>
</ol>
<h4 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>假设指数是$n$，则一共会循环$O(logn)$次，所以时间复杂度是$O(logn)$。</p>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">long</span> b = n;					<span class="comment">// 将n转化为长整型</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;			<span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)&#123;					<span class="comment">// 3.</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;				<span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;	<span class="comment">// 4.1</span></span><br><span class="line">            x *= x;						<span class="comment">// 4.2</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;					<span class="comment">// 4.3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;						<span class="comment">// 5.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="在-O-1-时间删除链表结点"><a href="#在-O-1-时间删除链表结点" class="headerlink" title="在$O(1)$时间删除链表结点"></a>在$O(1)$时间删除链表结点</h2><p>给定单向链表的一个节点指针，定义一个函数在$O(1)$时间删除该结点。</p>
<p>假设链表一定存在，并且该节点一定不是尾节点。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">6</span>-&gt;<span class="number">8</span></span><br><span class="line">删掉节点：第<span class="number">2</span>个节点即<span class="number">6</span>（头节点为第<span class="number">0</span>个节点）</span><br><span class="line">输出：新链表 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>链表，$O(1)$</strong></p>
<p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。我们可以换一种思路，<strong>将下一个节点的值复制到当前节点，然后将下一个节点删除即可</strong>。</p>
<h4 id="时间复杂度分析-4"><a href="#时间复杂度分析-4" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>只有常数次操作，所以时间复杂度$O(1)$。</p>
<h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* p = head;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>((p-&gt;next)-&gt;val==val)</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;next=q-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> q;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="删除排序链表中重复的结点"><a href="#删除排序链表中重复的结点" class="headerlink" title="删除排序链表中重复的结点"></a>删除排序链表中重复的结点</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。</p>
<h4 id="样例1-2"><a href="#样例1-2" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>线性扫描，O(n)</strong></p>
<p>为了方便处理边界情况，我们定义一个<strong>虚拟元素<code>dummy</code>指向链表头节点</strong>。然后从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p>
<h4 id="时间复杂度分析-5"><a href="#时间复杂度分析-5" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>整个链表只扫描一遍，所以时间复杂度是$O(n)$。</p>
<h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 凡是头结点可能会被删掉的，定义虚拟头结点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p>请实现一个函数用来匹配包含’<code>.</code> ‘和’<code>*</code>‘的正则表达式。模式中的字符’<code>.</code>‘表示任意一个字符，而’<code>*</code>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”<code>aaa</code>“与模式”<code>a.a</code>“和”<code>ab*ac*a</code>“匹配，但与”<code>aa.a</code>“和”<code>ab*a</code>“均不匹配。</p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><strong>动态规划，$O(nm)$</strong></p>
<p>状态表示：<code>f[i][j]​</code>表示<code>s[i,...]​</code>和<code>p[j,...]</code>相匹配<br>状态转移：</p>
<ol>
<li><code>p[i]</code>是正常字符串,<code>f[i][j]=s[i]==p[j]&amp;&amp;f[i+1][j+1]</code>;</li>
<li><code>p[j]</code>是’<code>.</code>‘,<code>f[i][j]=f[i+1][j+1]</code>;</li>
<li><code>p[j+1]</code>是’<code>*</code>‘,<code>f[i][j]=f[i][j+2] || f[i+1][j]</code></li>
</ol>
<h4 id="时间复杂度分析-6"><a href="#时间复杂度分析-6" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>$n$表示$s$的长度，$m$表示$p$的长度，总共$nm$个状态，状态转移复杂度 $O(1)$，所以总时间复杂度是$O(nm)$.</p>
<h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        m = p.<span class="built_in">size</span>();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> &amp;s, <span class="built_in">string</span> &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">        <span class="keyword">if</span> (y == m)</span><br><span class="line">            <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">        <span class="keyword">bool</span> first_match = x &lt; n &amp;&amp; (s[x] == p[y] || p[y] == <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">bool</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = dp(x, y + <span class="number">2</span>, s, p) || first_match &amp;&amp; dp(x + <span class="number">1</span>, y, s, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = first_match &amp;&amp; dp(x + <span class="number">1</span>, y + <span class="number">1</span>, s, p);</span><br><span class="line">        <span class="keyword">return</span> f[x][y] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>请实现一个函数用来<strong>判断字符串是否表示数值</strong>（包括整数和小数）。</p>
<p>例如，字符串<code>&quot;+100&quot;</code>,<code>&quot;5e2&quot;</code>,<code>&quot;-123&quot;</code>,<code>&quot;3.1416&quot;</code>和<code>&quot;-1E-16&quot;</code>都表示数值。</p>
<p>但是<code>&quot;12e&quot;</code>,<code>&quot;1a3.14&quot;</code>,<code>&quot;1.2.3&quot;</code>,<code>&quot;+-5&quot;</code>和<code>&quot;12e+4.3&quot;</code>都不是。</p>
<p><strong>注意</strong>:</p>
<ol>
<li>小数可以没有整数部分，例如<code>.123</code>等于<code>0.123</code>；</li>
<li>小数点后面可以没有数字，例如<code>233.</code>等于<code>233.0</code>；</li>
<li>小数点前面和后面可以有数字，例如<code>233.666</code></li>
<li>当e或E前面没有数字时，整个字符串不能表示数字，例如<code>.e1</code>、<code>e1</code>；</li>
<li>当e或E后面没有整数时，整个字符串不能表示数字，例如<code>12e</code>、<code>12e+5.4</code>;</li>
</ol>
<h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"0"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>模拟，字符串处理，$O(n)$</strong></p>
<ol>
<li>先去除行首和行尾空格；</li>
<li>行首如果有一个正负号，直接忽略；</li>
<li>如果字符串为空或只有一个<code>&#39;.&#39;</code>，则不是一个合法数；</li>
<li>循环整个字符串，去掉一下几种情况：<ol>
<li><code>&#39;.&#39;</code>或<code>&#39;e&#39;</code>多于1个</li>
<li><code>&#39;.&#39;</code>在<code>&#39;e&#39;</code>后面出现</li>
<li><code>&#39;e&#39;</code>后面或前面为空，或者<code>&#39;e&#39;</code>前面紧跟<code>&#39;.&#39;</code></li>
<li><code>&#39;e&#39;</code>后面紧跟正负号，但正负号后面为空</li>
</ol>
</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener"><strong>有限状态自动机</strong></a></p>
<p><strong>字符类型</strong>： 空格 「<code>`」、数字「</code>0—9<code>」 、正负号 「</code>+-<code>」 、小数点 「</code>.<code>」 、幂符号 「</code>e`」 。 </p>
<p><strong>状态定义</strong>： 按照字符串从左到右的顺序，定义以下 9 种状态：</p>
<ol>
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
</ol>
<p><strong>结束状态</strong>：合法状态为2、3、7、8</p>
<p><img src="/2020/07/11/Offer-Week2/DFA1.PNG"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><strong>初始化</strong>：<ol>
<li><strong>状态转移表</strong>$states$： 设$states[i]$，其中$i$为所处状态， $states[i]$使用<strong>哈希表存储可转移至的状态</strong>。键值对 $(key, value)$含义：若输入$key$，则可从状态$i$转移至状态$value$。</li>
<li><strong>当前状态</strong>$p$： 起始状态初始化为$p=0$。</li>
</ol>
</li>
<li><strong>状态转移循环</strong>：遍历字符串$s$的每个字符$c$：<ol>
<li><strong>记录字符类型</strong>$t$： 分为四种情况。<ul>
<li>当$c$为<strong>正负号时</strong>，执行<code>t = &#39;s&#39;</code>;</li>
<li>当$c$为<strong>数字时</strong>，执行<code>t = &#39;d&#39;</code>;</li>
<li>当$c$为<strong><code>.</code>,<code>e</code>,<code>E</code>, 空格时</strong>，执行<code>t = c</code>（即用字符本身表示字符类型）;</li>
<li>否则，执行<code>t = &#39;?&#39;</code>，代表为不属于判断范围的非法字符，后续直接返回<code>false</code>。</li>
</ul>
</li>
<li><strong>终止条件</strong>： 若字符类型<code>t</code>不在哈希表$states[p]$中，说明无法转移至下一状态，因此直接返回false`。</li>
<li><strong>状态转移</strong>： 状态$p$转移至$states[p][t]$ 。</li>
</ol>
</li>
<li><strong>返回值</strong>： 跳出循环后，若状态$p \in {2, 3, 7, 8}$，说明结尾合法，返回<code>true</code>，否则返回<code>false</code>。</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>整个字符串值遍历一遍，所以时间复杂度是$O(n)$</p>
<h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">' '</span>) i ++ ;  		<span class="comment">// 删除前面空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">' '</span>) j -- ;        		<span class="comment">// 删除后面空格</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s = s.substr(i, j - i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span> || s[<span class="number">0</span>] == <span class="string">'+'</span>) s = s.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// // +,-,.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dot ++ ;</span><br><span class="line">                <span class="keyword">if</span> (e || dot &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;      		<span class="comment">// 2323.2323.23,232e.232</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'e'</span> || s[i] == <span class="string">'E'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                e ++ ;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == s.<span class="built_in">size</span>() || !i || e &gt; <span class="number">1</span> || i == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'.'</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>; 							<span class="comment">// e121212,2323e,1212e1212e</span></span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">'+'</span> || s[i + <span class="number">1</span>] == <span class="string">'-'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 1212e+</span></span><br><span class="line">                    i ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。使得<strong>所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分</strong>。</p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>双指针扫描，$O(n)$</strong></p>
<p>用两个指针<strong>分别从首尾开始，往中间扫描</strong>。扫描时<strong>保证第一个指针前面的数都是奇数，第二个指针后面的数都是偶数</strong>。</p>
<ol>
<li><strong>初始化</strong>：<code>i</code>,<code>j</code>双指针，分别指向数组<code>nums</code>左右两端；</li>
<li><strong>循环交换</strong>： 当<code>i=j</code>时跳出；<ol>
<li>指针<code>i</code>遇到奇数则执行<code>i=i+1</code>跳过，直到找到偶数；</li>
<li>指针<code>j</code>遇到偶数则执行<code>j=j−1</code>跳过，直到找到奇数；</li>
<li>交换<code>nums[i]</code>和<code>nums[j]</code>值；</li>
</ol>
</li>
<li><strong>返回值</strong>： 返回已修改的<code>nums</code>数组。</li>
</ol>
<p>可始终保证： 指针<code>i</code>左边都是奇数，指针<code>j</code>右边都是偶数 。</p>
<p><img src="/2020/07/11/Offer-Week2/1.png" style="width:50%"></p>
<h4 id="时间复杂度分析-7"><a href="#时间复杂度分析-7" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>当两个指针相遇时，走过的总路程长度是$n$，所以时间复杂度是$O(n)$。</p>
<h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="built_in">array</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[l] % <span class="number">2</span> == <span class="number">1</span>) l ++ ;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">array</span>[r] % <span class="number">2</span> == <span class="number">0</span>) r -- ;</span><br><span class="line">             <span class="keyword">if</span> (l &lt; r) swap(<span class="built_in">array</span>[l], <span class="built_in">array</span>[r]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><p>输入一个链表，输出该链表中倒数第<code>k</code>个结点。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>k &gt;= 0</code>;</li>
<li>如果k大于链表长度，则返回 <code>NULL</code>;</li>
</ul>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span> ，k=<span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>链表，$O(n)$</strong></p>
<p>由于单链表不能索引到前驱节点，所以只能<strong>从前往后</strong>遍历。</p>
<ol>
<li>先遍历统计链表长度，记为<code>n</code> ；</li>
<li>设置一个指针走<code>(n−k)</code>步，即可找到链表倒数第<code>k</code>个节点。 </li>
</ol>
<p><strong>双指针法：</strong></p>
<p><img src="/2020/07/11/Offer-Week2/2.png" style="width:50%"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><strong>初始化</strong>： 前指针<code>former</code>、后指针<code>latter</code>，双指针都指向头节点<code>head</code>。</li>
<li><strong>构建双指针距离</strong>： 前指针<code>former</code>先向前走<code>k</code>步（结束后，双指针<code>former</code>和<code>latter</code>间相距<code>k</code>步）。</li>
<li><strong>双指针共同移动</strong>： 循环中，双指针<code>former</code>和<code>latter</code>每轮都向前走一步，直至<code>former</code>走过链表尾节点时跳出（跳出后，<code>latter</code>与尾节点距离为<code>k−1</code>，即<code>latter</code>指向倒数第<code>k</code>个节点）。</li>
<li><strong>返回值</strong>： 返回<code>latter</code>即可。</li>
</ol>
<h4 id="时间复杂度分析-8"><a href="#时间复杂度分析-8" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>链表总共遍历两次，所以时间复杂度是$O(n)$。</p>
<h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; ++i) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 双指针*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* former = head;</span><br><span class="line">        ListNode* latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            former = former-&gt;next;</span><br><span class="line">            latter = latter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h2><p>给定一个链表，若其中包含环，则输出环的入口节点。若其中不包含环，则输出<code>null</code>。</p>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><p><img src="/2020/07/11/Offer-Week2/3.png" style="width:50%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定如上所示的链表：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">输入：<span class="number">2</span>（<span class="number">2</span>表示编号是<span class="number">2</span>的节点，节点编号从<span class="number">0</span>开始。所以编号是<span class="number">2</span>的节点就是val等于<span class="number">3</span>的节点）</span><br><span class="line">输出：环的入口节点<span class="number">3.</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p><strong>链表，快慢指针扫描——Floyd算法，$O(n)$</strong></p>
<ol>
<li>走<code>a+nb</code>步一定是在环入口</li>
<li>第一次相遇时慢指针已经走了<code>nb</code>步</li>
</ol>
<p>这类链表题目一般都是使用<strong>双指针法</strong>解决的，例如<strong>寻找距离尾部第K个节点</strong>、<strong>寻找环入口</strong>、<strong>寻找公共尾部入口</strong>等。 </p>
<p><img src="/2020/07/11/Offer-Week2/p11.png"></p>
<p><img src="/2020/07/11/Offer-Week2/p12.png"></p>
<p><img src="/2020/07/11/Offer-Week2/p13.png"></p>
<p><img src="/2020/07/11/Offer-Week2/p14.png" style="width:75%"></p>
<ol>
<li><p><strong>双指针第一次相遇：</strong> 设两指针 <code>fast</code>，<code>slow</code> 指向链表头部 <code>head</code>，<code>fast</code> 每轮走<code>2</code>步，<code>slow</code> 每轮走<code>1</code>步；</p>
<ol>
<li><p><strong>第一种结果：</strong> <strong><code>fast</code> 指针走过链表末端，说明链表无环</strong>，直接返回 <code>null</code>；（TIPS：<strong>若有环，两指针一定会相遇</strong>。因为每走<code>1</code>轮，<code>fast</code> 与 <code>slow</code> 的间距<code>+1</code>，<code>fast</code> 终会追上 <code>slow</code>； ）</p>
</li>
<li><p><strong>第二种结果：</strong> 当<code>fast == slow</code>时， 两指针在环中 <strong>第一次相遇</strong> 。下面分析此时<code>fast</code> 与 <code>slow</code>走过的 <strong>步数关系</strong> ： </p>
<ul>
<li><p>设链表共有<code>a+b</code>个节点，其中<strong>链表头部到链表入口有<code>a</code>个节点</strong>（不计链表入口节点），<strong>链表环有<code>b</code>个节点</strong>（这里需要注意，<code>a</code>和<code>b</code>是未知数，例如图解上链表<code>a=4</code>,<code>b=5</code>）；设两指针分别走了<code>f</code>，<code>s</code>步，则有：</p>
<ol>
<li><strong><code>fast</code> 走的步数是<code>slow</code>步数的<code>2</code>倍</strong>，即<code>f=2s</code>；（<strong>解析：</strong> <code>fast</code> 每轮走<code>2</code>步）</li>
<li><strong><code>fast</code>比<code>slow</code>多走了<code>n</code>个环的长度</strong>，即<code>f=s+nb</code>；（ <strong>解析</strong>： 双指针都走过<code>a</code>步，然后在环内绕圈直到重合，重合时<strong><code>fast</code>比<code>slow</code>多走环的长度整数倍</strong> ）；</li>
</ol>
</li>
<li><p>以上两式相减得：<code>f=2nb</code>，<code>s=nb</code>，即<code>fast</code>和<code>slow</code>指针分别走了<strong><code>2n</code>，<code>n</code> 环的周长</strong> （注意： <code>n</code>是未知数，不同链表的情况不同）。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>目前情况分析：</strong> </p>
<ol>
<li>如果让指针从链表头部一直向前走并统计步数<code>k</code>，那么<strong>所有走到链表入口节点时的步数是：<code>k=a+nb</code></strong>。</li>
<li>而目前，<code>slow</code>指针走过的步数为<code>nb</code>步。因此，我们只要想办法让 <code>slow</code>再走<code>a</code>步停下来，就可以到环的入口。</li>
<li>但是我们不知道<code>a</code>的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：<strong>此指针和<code>slow</code>一起向前走<code>a</code>步后，两者在入口节点重合</strong>。那么从哪里走到入口节点需要<code>a</code>步？答案是链表头部<code>head</code>。</li>
</ol>
</li>
<li><p><strong>双指针第二次相遇：</strong> </p>
<ol>
<li><code>slow</code>指针 <strong>位置不变</strong> ，将<code>fast</code>指针重新<strong>指向链表头部节点</strong> ；<code>slow</code>和<code>fast</code>同时每轮向前走<code>1</code>步； （ <strong>TIPS</strong>：此时<code>f=0</code>，<code>s=nb</code>； ）</li>
<li>当 <code>fast</code> 指针走到<code>f=a</code>步时，<code>slow</code> 指针走到步<code>s = a+nb</code>，此时 <strong>两指针重合，并同时指向链表环入口</strong> 。 </li>
</ol>
</li>
<li><p><strong>返回<code>slow</code>指针指向的节点。</strong></p>
</li>
</ol>
<h4 id="时间复杂度分析-9"><a href="#时间复杂度分析-9" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p><strong>第二次相遇中</strong>，慢指针须走步数<code>a&lt;a+b</code>；<strong>第一次相遇中</strong>，慢指针须走步数<code>a+b−x&lt;a+b</code>，其中<code>x</code>为<strong>双指针重合点与环入口距离</strong>；因此总体为线性复杂度$O(n)$</p>
<h4 id="C-代码-10"><a href="#C-代码-10" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">// 判断链表是否为空</span></span><br><span class="line">        ListNode *fast = head, *slow = head;			<span class="comment">// 初始化快慢指针</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; slow)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;			<span class="comment">// 慢指针走一步</span></span><br><span class="line">            fast = fast-&gt;next;			<span class="comment">// 快指针走两步</span></span><br><span class="line">            <span class="keyword">if</span> (fast) fast = fast-&gt;next; 			<span class="comment">// 快指针是否走出链表结尾</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)			<span class="comment">// 第一次快慢指针相遇</span></span><br><span class="line">            &#123;</span><br><span class="line">                fast = head;				<span class="comment">// 从头开始</span></span><br><span class="line">                <span class="keyword">while</span> (fast != slow)</span><br><span class="line">                &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;				<span class="comment">// 第二次相遇则返回慢指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer——Week1</title>
    <url>/2020/07/09/Offer-Week1/</url>
    <content><![CDATA[<h2 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h2><p>给定一个长度为 $n$的整数数组 <code>nums</code>，数组中<strong>所有的数字都在<code>0~n−1​</code>的范围内</strong>。</p>
<p>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。</p>
<p>请找出数组中任意一个重复的数字。</p>
<p><strong>注意</strong>：如果某些数字不在<code>0~n−1​</code>范围内，或数组中不包含重复数字，则返回<code>-1</code>；</p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>]。</span><br><span class="line">返回 <span class="number">2</span> 或 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先遍历一遍数组，如果存在某个数不在0到n-1的范围内，则返回<code>-1</code>。</li>
<li>把每个数放到对应的位置上，即让<code>nums[i] = i</code>。</li>
</ol>
<p>从前往后遍历数组中的所有数，假设当前遍历到的数是<code>nums[i]=x</code>，那么：</p>
<ul>
<li>如果<code>x != i &amp;&amp; nums[x] == x</code>，则说明<code>x</code>出现了多次，直接返回<code>x</code>即可；</li>
<li>如果<code>nums[x] != x</code>，那我们就把<code>x</code>交换到正确的位置上，即<code>swap(nums[x], nums[i])</code>，交换完之后如果<code>nums[i] != i</code>，则重复进行该操作。由于每次交换都会将一个数放在正确的位置上，所以<code>swap</code>操作最多会进行<code>n</code>次，不会发生死循环。</li>
</ul>
<p>循环结束后，如果没有找到任何重复的数，则返回<code>-1</code>。</p>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>每次<code>swap</code>操作都会将一个数放在正确的位置上，最后一次<code>swap</code>会将两个数同时放到正确位置上，一共只有<code>n</code>个数和<code>n</code>个位置，所以<code>swap</code>最多会进行<code>n−1</code>次。所以总时间复杂度是 $O(n)$。</p>
<h4 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();					        <span class="comment">// 计算数组长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> || nums[i] &gt;= n)<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 特例判断	</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)&#123;				 <span class="comment">// nums[i]没在正确位置</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])			<span class="comment">// 存在重复数字</span></span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    swap(nums[i], nums[nums[i]]);		<span class="comment">// 交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不修改数组找出重复数字"><a href="#不修改数组找出重复数字" class="headerlink" title="不修改数组找出重复数字"></a>不修改数组找出重复数字</h2><p>给定一个长度为<code>n+1</code>的数组<code>nums</code>，数组中所有的数均在<strong><code>1∼n</code>的范围内</strong>，其中<code>n≥1</code>。</p>
<p>请找出数组中任意一个重复的数，但<strong>不能修改输入的数组</strong>。</p>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 3, 5, 4, 3, 2, 6, 7]。</span><br><span class="line">返回 2 或 3。</span><br></pre></td></tr></table></figure>
<p><strong>思考题</strong>：如果只能使用<code>O(1)</code>的额外空间，该怎么做呢？</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>分治法，抽屉原理，$O(nlogn)$</strong></p>
<blockquote>
<p>抽屉原理：<code>n+1</code>个苹果放在<code>n</code>个抽屉里，那么至少有一个抽屉中会放两个苹果。</p>
</blockquote>
<p>用在这个题目中就是，一共有<code>n+1</code>个数，每个数的取值范围是<code>1</code>到<code>n</code>，所以至少会有一个数出现两次。</p>
<p>将每个数的取值的区间<code>[1, n]</code>划分成<code>[1, n/2]</code>和<code>[n/2+1, n]</code>两个子区间，然后<strong>分别统计两个区间中数的个数</strong>。</p>
<p>注意这里的<strong>区间是指数的取值范围</strong>，而不是数组下标。划分之后，左右两个区间里一定<strong>至少存在一个区间，区间中数的个数大于区间长度</strong>。</p>
<p>因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。</p>
<p>依次类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。</p>
<h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ol>
<li>时间复杂度：每次会将区间长度缩小一半，一共会缩小$O(logn)$次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是$O(n)$。所以总时间复杂度是$O(nlogn)$。</li>
<li>空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是$O(1)$。</li>
</ol>
<h4 id="C-代码-1"><a href="#C-代码-1" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 划分的区间：[l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid;<span class="comment">// 统计左边个数</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p>
<p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入数组：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]，</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>]，</span><br><span class="line">  [<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>]，</span><br><span class="line">  [<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>]</span><br><span class="line">]</span><br><span class="line">如果输入查找数值为<span class="number">7</span>，则返回<span class="literal">true</span>，</span><br><span class="line">如果输入查找数值为<span class="number">5</span>，则返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>单调性扫描，$O(n+m)$</strong></p>
<p>核心在于发现每个子矩阵<strong>右上角的数</strong>的性质：</p>
<ul>
<li>如下图所示，x左边的数都小于等于x，x下边的数都大于等于x。</li>
</ul>
<p><img src="/2020/07/09/Offer-Week1/1.png"></p>
<p>因此我们可以从整个<strong>矩阵的右上角开始枚举</strong>，假设当前枚举的数是$x$：</p>
<ul>
<li>如果$x$ 等于<code>target</code>，则说明我们找到了目标值，返回<code>true</code>；</li>
<li>如果$x$小于<code>target</code>，则$x$左边的数一定都小于<code>target</code>，我们可以直接排除当前一整行的数；</li>
<li>如果$x$大于<code>target</code>，则$x$下边的数一定都大于<code>target</code>，我们可以直接排序当前一整列的数；</li>
</ul>
<p>排除一整行就是让枚举的点的<strong>横坐标加一</strong>，排除一整列就是让<strong>纵坐标减一</strong>。<br>当我们排除完整个矩阵后仍没有找到目标值时，就说明目标值不存在，返回<code>false</code>。</p>
<h4 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>每一步会<strong>排除一行或者一列</strong>，矩阵一共有$n$行，$m$列，所以最多会进行$n+m$步。所以时间复杂度是$O(n+m)$。</p>
<h4 id="C-代码-2"><a href="#C-代码-2" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;		</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”<code>%20</code>“。</p>
<p>你可以假定输入字符串的长度最大是<code>1000</code>。<br>注意输出字符串的长度可能大于<code>1000</code>。 </p>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>线性扫描，$O(n)$</strong></p>
<p>从前往后枚举原字符串：</p>
<ul>
<li>如果遇到空格，则在<code>string</code>类型的答案中添加 “<code>%20</code>“；</li>
<li>如果遇到其他字符，则直接将它添加在答案中；</li>
</ul>
<h4 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>原字符串只会被遍历常数次，所以总时间复杂度是$O(n)$。</p>
<h4 id="C-代码-3"><a href="#C-代码-3" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : s)</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="string">' '</span>)</span><br><span class="line">                res += <span class="string">"%20"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p>
<p>返回的结果用数组存储。</p>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">返回：[<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>遍历链表，$O(n)$</strong></p>
<p>单链表只能从前往后遍历，不能从后往前遍历。</p>
<p>因此我们先<strong>从前往后遍历一遍输入的链表</strong>，<strong>将结果记录在答案数组中</strong>。<br>最后再将<strong>得到的数组逆序</strong>即可。</p>
<h4 id="时间复杂度分析-4"><a href="#时间复杂度分析-4" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>链表和答案数组仅被遍历了常数次，所以总时间复杂度是$O(n)$。</p>
<h4 id="C-代码-4"><a href="#C-代码-4" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p>
<p><strong>注意</strong>:</p>
<ul>
<li>二叉树中每个节点的值都互不相同；</li>
<li>输入的前序遍历和中序遍历一定合法；</li>
</ul>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定：</span><br><span class="line">前序遍历是：[<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>]</span><br><span class="line">中序遍历是：[<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>]</span><br><span class="line">返回：[<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, null, null, <span class="number">15</span>, <span class="number">7</span>, null, null, null, null]</span><br><span class="line">返回的二叉树如下所示：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>递归，$O(n)$</strong></p>
<p>递归建立整棵二叉树：<strong>先递归创建左右子树，然后创建根节点，并让指针指向两棵子树</strong>。</p>
<p>具体步骤如下：</p>
<ol>
<li>先利用<strong>前序遍历找根节点</strong>：前序遍历的<strong>第一个数</strong>，就是根节点的值；</li>
<li>在<strong>中序遍历中找到根节点的位置<code>k</code></strong>，则<code>k</code><strong>左边是左子树</strong>的中序遍历，<strong>右边是右子树</strong>的中序遍历；</li>
<li>假设左子树的中序遍历的长度是<code>l</code>，则在前序遍历中，根节点后面的<code>l</code>个数，是左子树的前序遍历，剩下的数是右子树的前序遍历；</li>
<li>有了左右子树的前序遍历和中序遍历，我们可以先递归创建出左右子树，然后再创建根节点。</li>
</ol>
<h4 id="时间复杂度分析-5"><a href="#时间复杂度分析-5" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>我们在初始化时，用<strong>哈希表(<code>unordered_map&lt;int,int&gt;</code>)</strong>记录每个值在中序遍历中的位置，这样我们在递归到每个节点时，在中序遍历中查找根节点位置的操作，只需要$O(1)$的时间。此时，创建每个节点需要的时间是$O(1)$，所以总时间复杂度是 $O(n)$。</p>
<h4 id="C-代码-5"><a href="#C-代码-5" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;							<span class="comment">// 开哈希表</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;				<span class="comment">// 全局变量</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span> </span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) </span><br><span class="line">            hash[inorder[i]] = i;    			<span class="comment">// 初始化哈希表</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[pl]);	<span class="comment">// 根节点</span></span><br><span class="line">        <span class="keyword">int</span> k = hash[root-&gt;val];			<span class="comment">// 根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 前序和后序遍历的新的范围</span></span><br><span class="line">        <span class="keyword">auto</span> left = dfs(pl + <span class="number">1</span>, pl + k - il, il, k - <span class="number">1</span>);	</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(pl + k - il +<span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        root-&gt;left = left,root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h2><p>给定一棵二叉树的其中一个节点，请<strong>找出中序遍历序列的下一个节点</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li>
<li>二叉树一定不为空，且给定的节点一定不是空节点；</li>
</ul>
<h4 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假定二叉树是：[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, null, null, null, null]， 给出的是值等于<span class="number">2</span>的节点。</span><br><span class="line">则应返回值等于<span class="number">3</span>的节点。</span><br><span class="line">解释：该二叉树的结构如下，<span class="number">2</span>的后继节点是<span class="number">3</span>。</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><strong>模拟，$O(h)$</strong></p>
<p>求二叉树中给定节点的后继，分情况讨论即可，如下图所示：</p>
<p><img src="/2020/07/09/Offer-Week1/2.png" style="width:50%"></p>
<ol>
<li>如果一个<strong>结点有右子树，那么它的下一个结点就是它的右子树的最左子结点</strong>。也就是说从右子结点出发一直沿着指向左子树结点的指针，我们就能找到它的下一个结点。例如，图中结点<code>b</code>的下一个结点是<code>h</code>，结点<code>a</code>的下一个结点是<code>f</code>。 </li>
<li>如果<strong>结点是它父结点的左子结点，那么它的下一个结点就是它的父结点</strong>。例如，图中结点<code>d</code>的下一个结点是<code>b</code>，<code>f</code>的下一个结点是<code>c</code>。</li>
<li>如果一个<strong>结点既没有右子树，并且它还是父结点的右子结点</strong>，这种情形就比较复杂。  我们可以<strong>沿着指向父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点</strong>。如果这样的结点存在，那么这个结点的父结点就是我们要找的下一个结点。例如，为了找到结点<code>g</code>的下一个结点，我们沿着指向父结点的指针向上遍历，先到达结点<code>c</code>。由于结点<code>c</code>是父结点<code>a</code>的右结点，我们继续向上遍历到达结点<code>a</code>。由于结点<code>a</code>是树的根结点。它没有父结点。因此结点<code>g</code>没有下一个结点。 </li>
</ol>
<h4 id="时间复杂度分析-6"><a href="#时间复杂度分析-6" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是 $O(h)$，其中<code>h</code>是树的高度。</p>
<h4 id="C-代码-6"><a href="#C-代码-6" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;left) p = p-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的后继"><a href="#二叉搜索树的后继" class="headerlink" title="二叉搜索树的后继"></a>二叉搜索树的后继</h2><p>设计一个算法，找出<strong>二叉搜索树</strong>中指定节点的<strong>后继</strong>。</p>
<p>如果指定节点没有对应的后继，则返回<code>null</code>。</p>
<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,null,null,<span class="number">1</span>], p = <span class="number">6</span></span><br><span class="line">      <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"> /   </span><br><span class="line"><span class="number">1</span></span><br><span class="line">输出: null</span><br></pre></td></tr></table></figure>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>BST+递归</strong></p>
<p>首先本题中的二叉树是<strong>二叉搜索树</strong>，也就是<strong>中序遍历是单调递增的</strong>，所以我们可以利用这个性质来简化查找过程：</p>
<ul>
<li>如果结点<code>p</code>的值大于等于<code>root</code>的值，说明<code>p</code>的后继结点在<code>root</code>右子树中，那么就递归到右子树中查找。</li>
<li>如果结点<code>p</code>的值小于<code>root</code>的值，说明<code>p</code>在<code>root</code>左子树中，而它的后继结点有两种可能，要么也在左子树中，要么就是<code>root</code>：<ul>
<li>如果左子树中找到了后继结点，那就直接返回答案。</li>
<li>如果左子树中没有找到后继结点，那就说明<code>p</code>的右儿子为空，那么<code>root</code> 就是它的后继结点。</li>
</ul>
</li>
</ul>
<p><strong>BST+非递归</strong></p>
<ul>
<li><strong>如果<code>p</code>有右儿子，那么它的后继结点就是右子树的最左边的儿子</strong>。</li>
<li><strong>如果<code>p</code>没有右儿子</strong>，那么它的后继结点就是，<strong>沿着<code>p</code>往上到<code>root</code>的路径中，第一个左儿子在路径上的结点</strong>。因为这个结点的左子树中<code>p</code>是最右边的结点，是最大的，所以它就是<code>p</code>的后继结点。因为是二叉搜索树，我们就可以从根结点开始往<code>p</code>走，根据结点值的大小决定走的方向。</li>
</ul>
<h4 id="C-代码-7"><a href="#C-代码-7" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root = <span class="literal">NULL</span> || p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt;= root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> inorderSuccessor(root-&gt;right, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* left = inorderSuccessor(root-&gt;left, p);</span><br><span class="line">            <span class="keyword">return</span> left ? left : root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 非递归*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* res = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val) &#123;		<span class="comment">// 根据大小判断走向</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p> 请用栈实现一个队列，支持如下四种操作： </p>
<ul>
<li><code>push(x)</code> – 将元素x插到队尾；</li>
<li><code>pop()</code> – 将队首的元素弹出，并返回该元素；</li>
<li><code>peek()</code> – 返回队首元素；</li>
<li><code>empty()</code> – 返回队列是否为空；</li>
</ul>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">queue</span>.pop();</span><br></pre></td></tr></table></figure>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>栈，队列，$O(n)$</strong></p>
<p>我们用两个栈来做，<strong>一个主栈，用来存储数据</strong>；<strong>一个辅助栈，用来当缓存</strong>。</p>
<ul>
<li><code>push(x)</code>，我们直接将<code>x</code><strong>插入主栈中</strong>即可。</li>
<li><code>pop()</code>，此时我们需要<strong>弹出最先进入栈的元素，也就是栈底元素</strong>。我们可以<strong>先将所有元素从主栈中弹出，压入辅助栈中</strong>。则<strong>辅助栈的栈顶元素就是我们要弹出的元素，将其弹出即可</strong>。然后再<strong>将辅助栈中的元素全部弹出，压入主栈中</strong>。</li>
<li><code>peek()</code>，可以用和<code>pop()</code>操作类似的方式，得到最先压入栈的元素。</li>
<li><code>empty()</code>，直接判断主栈是否为空即可。</li>
</ul>
<h4 id="时间复杂度分析-7"><a href="#时间复杂度分析-7" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ul>
<li><code>push()</code>：$O(1)$；</li>
<li><code>pop()</code>: 每次需要将主栈元素全部弹出，再压入，所以需要$O(n)$的时间；</li>
<li><code>peek()</code>：类似于<code>pop()</code>，需要$O(n)$的时间；</li>
<li><code>empty()</code>：$O(1)$；</li>
</ul>
<h4 id="C-代码-8"><a href="#C-代码-8" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1,stack2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果第二个栈为空</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteItem = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>输入一个整数<code>n</code>，求斐波那契数列的第<code>n</code>项。</p>
<p>假定从<code>0</code>开始，第<code>0</code>项为<code>0</code>。(<code>n&lt;=39</code>)</p>
<h4 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入整数 n=<span class="number">5</span> </span><br><span class="line">返回 <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p><strong>递归，$O(n)$</strong></p>
<p>用两个变量滚动式得往后计算，<code>a</code>表示第<code>n−1</code>项，<code>b</code>表示第<code>n</code>项。<br>则令<code>c=a+b</code>表示第<code>n+1</code>项，然后让<code>a</code>,<code>b</code>顺次往后移一位。</p>
<h4 id="时间复杂度分析-8"><a href="#时间复杂度分析-8" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>总共需要计算<code>n</code>次，所以时间复杂度是<code>O(n)</code>。</p>
<h4 id="C-代码-9"><a href="#C-代码-9" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划5行解决</span></span><br><span class="line">        <span class="comment">// 声明n+1+1大小的vector（第一个+1是要存储0至n共n+1个数据；第二个+1是考虑n==0的情况，保证v[1]不越界）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span> + <span class="number">1</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            v[i] = (v[i - <span class="number">1</span>] + v[i - <span class="number">2</span>]) % <span class="number">1000000007</span>; <span class="comment">//注意别忘记取余</span></span><br><span class="line">        <span class="keyword">return</span> v[n];                     <span class="comment">//直接返回最后一个数，即最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素，即寻找 <strong>右排序数组</strong> 的首个元素 <code>numbers[x]</code> ，称<code>x</code>为 <strong>旋转点</strong> 。</p>
<p>例如数组<code>{3,4,5,1,2}</code>为<code>{1,2,3,4,5}</code>的一个旋转，该数组的最小值为1。数组可能包含重复项。</p>
<p><strong>注意</strong>：数组内所含元素非负，若数组大小为0，请返回-1。</p>
<h4 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：nums=[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p><strong>二分，$O(n)$</strong></p>
<p>为了便于分析，我们先将数组中的数画在二维坐标系中，横坐标表示数组下标，纵坐标表示数值，如下所示：</p>
<p><img src="/2020/07/09/Offer-Week1/3.png"></p>
<p>图中水平的实线段表示相同元素。我们发现<strong>除了最后水平的一段（黑色水平那段）之外，其余部分满足二分性质</strong>：竖直虚线左边的数满足<code>nums[i]≥nums[0]</code>；而竖直虚线右边的数不满足这个条件。<br>分界点就是整个数组的最小值。所以我们<strong>先将最后水平的一段删除即可</strong>。</p>
<p>另外，不要忘记处理数组<strong>完全单调的特殊情况</strong>：</p>
<ul>
<li>当我们删除最后水平的一段之后，如果剩下的最后一个数大于等于第一个数，则说明数组完全单调。</li>
</ul>
<p><img src="/2020/07/09/Offer-Week1/4.png" style="width:60%"></p>
<ol>
<li><p><strong>循环二分</strong>： 设置<code>i</code>, <code>j</code> 指针分别指向 <code>numbers</code>数组左右两端，<code>m = (i + j) // 2</code>为每次二分的中点（ “<code>//</code>“ 代表向下取整除法，因此恒有$i \leq m &lt; j$），可分为以下三种情况：</p>
<ol>
<li>当<code>numbers[m] &gt; numbers[j]</code>时：<code>m</code>一定在左排序数组中，即旋转点<code>x</code>一定在 <code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</li>
<li>当<code>numbers[m] &lt; numbers[j]</code>时：<code>m</code>一定在 右排序数组中，即旋转点<code>x</code>一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>； </li>
<li>当<code>numbers[m] == numbers[j]</code>时： 无法判断<code>m</code>在哪个排序数组中，即无法判断旋转点<code>x</code>在<code>[i, m]</code>还是<code>[m + 1, j]</code>区间中。解决方案： 执行<code>j = j - 1</code>缩小判断范围 （分析见以下内容） 。</li>
</ol>
</li>
<li><p><strong>返回值</strong>： 当<code>i = j</code>时跳出二分循环，并返回<code>numbers[i]</code>即可。</p>
</li>
</ol>
<h4 id="时间复杂度分析-9"><a href="#时间复杂度分析-9" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>二分的时间复杂度是<code>O(logn)</code>，删除最后水平一段的时间复杂度最坏是<code>O(n)</code>，所以总时间复杂度是<code>O(n)</code>。</p>
<h4 id="C-代码-10"><a href="#C-代码-10" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) --n;	    <span class="comment">// 处理最后一段水平相等的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];		<span class="comment">// 判断第二部分是否存在</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;				<span class="comment">// 开始二分</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;		<span class="comment">// [l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p>
<p>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。</p>
<p>如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入的路径不为空；</li>
<li>所有出现的字符均为大写英文字母；</li>
</ul>
<h4 id="样例-11"><a href="#样例-11" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">matrix=</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"E"</span>],</span><br><span class="line">  [<span class="string">"S"</span>,<span class="string">"F"</span>,<span class="string">"C"</span>,<span class="string">"S"</span>],</span><br><span class="line">  [<span class="string">"A"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"E"</span>]</span><br><span class="line">]</span><br><span class="line">str=<span class="string">"BCCE"</span> , <span class="keyword">return</span> <span class="string">"true"</span> </span><br><span class="line">str=<span class="string">"ASAE"</span> , <span class="keyword">return</span> <span class="string">"false"</span></span><br></pre></td></tr></table></figure>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p><strong>DFS，$O(n^23^k)$</strong></p>
<p>在深度优先搜索中，最重要的就是<strong>考虑好搜索顺序</strong>。</p>
<p>我们先枚举单词的起点，然后依次枚举单词的每个字母。<br>过程中需要<strong>将已经使用过的字母改成一个特殊字母，以避免重复使用字符</strong>。</p>
<h4 id="时间复杂度分析-10"><a href="#时间复杂度分析-10" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>单词起点一共有$n^2$ 个，单词的每个字母一共有上下左右四个方向可以选择，<strong>但由于不能走回头路，所以除了单词首字母外，仅有三种选择</strong>。所以总时间复杂度是$O(n^23^k)$。</p>
<h4 id="C-代码-11"><a href="#C-代码-11" class="headerlink" title="C++代码"></a>C++代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, <span class="keyword">word</span>, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] != <span class="keyword">word</span>[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> t = board[x][y];</span><br><span class="line">        board[x][y] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; board.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; board[a].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, <span class="keyword">word</span>, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h2><p>二分模板一共有两个，分别适用于不同情况。<br><strong>算法思路</strong>：假设目标值在闭区间<code>[l, r]</code>中， 每次将区间长度缩小一半，当<code>l = r</code>时，我们就找到了目标值。</p>
<h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时，其更新操作是<code>r = mid</code>或者<code>l = mid + 1;</code>，计算<code>mid</code>时不需要加<code>1</code>。</p>
<h4 id="C-代码模板："><a href="#C-代码模板：" class="headerlink" title="C++ 代码模板："></a>C++ 代码模板：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>当我们将区间<code>[l, r]</code>划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时，其更新操作是<code>r = mid - 1</code>或者<code>l = mid;</code>，此时为了防止死循环，计算<code>mid</code>时需要加<code>1</code>。</p>
<h4 id="C-代码模板：-1"><a href="#C-代码模板：-1" class="headerlink" title="C++ 代码模板："></a>C++ 代码模板：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>C++错题及知识点回顾</title>
    <url>/2020/07/08/C-exercise/</url>
    <content><![CDATA[<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>  #define是C语言中提供的宏定义命令 ，它用来<strong>将一个标识符定义为一个字符串</strong>，该标识符被称为宏名，被定义的字符串称为<strong>替换文本</strong>。 </p>
<p>该命令有两种格式：一种是<strong>简单</strong>的宏定义，另一种是<strong>带参数</strong>的宏定义。 </p>
<p><strong><em>重要：</em></strong></p>
<ol>
<li><strong>宏替换只作替换，不做计算，不做表达式求解</strong> </li>
<li>宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值） </li>
</ol>
<blockquote>
<p><strong>例题1：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M N+ 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM ( M+1 )*M/2</span></span><br><span class="line">main()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"%d\n"</span> ,NUM ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：$8$</p>
<p>解题：$NUM$——$(M+1)\cdot M/2$，$M$——$N+1$，</p>
<p>$NUM$=$(N+1+1)\cdot N+1/2=(N+1+1)\cdot 2+1/2=8.5$，即：$8$</p>
<p><strong>例题2：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SUM(x) 3*x*x+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">5</span>,j=<span class="number">8</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,SUM(i+j));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：$64$</p>
<p>解答：$SUM(i+j)=3\cdot i+j\cdot i+j+1=3\cdot 5+8\cdot 5+8+1=64$</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ol>
<li>算术运算符。</li>
<li>关系运算符。</li>
<li>逻辑运算符。</li>
<li>位运算符。</li>
<li>赋值运算符。</li>
<li>杂项运算符。</li>
</ol>
<p><img src="/2020/07/08/C-exercise/01.png"></p>
<p><img src="/2020/07/08/C-exercise/02.png"></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p> 位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">p</th>
<th style="text-align:center">q</th>
<th style="text-align:center">p&amp;q</th>
<th style="text-align:center">p\</th>
<th style="text-align:center">q</th>
<th>p^q</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line">-----------------</span><br><span class="line"> </span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line">A|B = <span class="number">0011</span> <span class="number">1101</span></span><br><span class="line">A^B = <span class="number">0011</span> <span class="number">0001</span></span><br><span class="line">~A  = <span class="number">1100</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure>
<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">如果同时存在于两个操作数中，二进制AND运算符复制一位到结果中。</td>
<td style="text-align:center">(A&amp;B)将得到12，即为0000 1100</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td style="text-align:center">如果存在于任一操作数中，二进制OR运算符复制一位到结果中。</td>
<td>(A\</td>
<td>B)将得到61，即为0011 1101</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制 异或运算符复制一位到结果中。</td>
<td style="text-align:center">(A^B)将得到49，即为0011 0001</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">二进制补码运算符是一元运算符，具有”翻转”位效果。</td>
<td style="text-align:center">(~A)将得到-61，即为1100 0011，2的补码形式，带符号的二进制数。</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td style="text-align:center">A&lt;&lt;2将得到240，即为1111 0000</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td style="text-align:center">A&gt;&gt;2将得到15，即为0000 1111</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>例题1：</strong></p>
<p> 7&amp;3+12的值是15 。（错误）</p>
<p>解答：算数运算符的优先级高于位运算。先算：$3+12=15$，$7——0111$，$15——1111$，$7\&amp;15=0111=7$。</p>
<p><strong>例题2：</strong></p>
<p>如下函数，在32bits系统<code>foo(2^31-3)</code>的值是？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line">   return x &amp; -x</span><br></pre></td></tr></table></figure>
<p>结果为：$1$</p>
<p>解答：32位系统中，</p>
<p>$2^{31}=10000000,00000000,00000000,00000000$</p>
<p>$2^{31}-3=01111111,1111111,1111111,1111101$</p>
<p>$2^{31}-3=1000000,0000000,0000000,00000010$，反码</p>
<p>$-(2^{31}-3)=01111111，11111111，11111111，11111101$，$2^{31}-3$的反码$+1$</p>
<p>$-(2^{31}-3)=10000000,00000000,00000000,00000011$，补码</p>
<p>$2^{31}-3 \&amp; -(2^{31}-3)=00000000,00000000,00000000,00000001=1$</p>
</blockquote>
<p>反转位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">	n = (n &gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">	n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">	n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">	n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）</p>
<p>0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1）</p>
<p>0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现)</p>
<p>0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现)</p>
<p>0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现)</p>
<p>0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x &amp; 0x55555555) &lt;&lt; 1——奇数位移到偶数位</span><br><span class="line">(x &gt;&gt; 1) &amp; 0x55555555)——先右移一位，等于拿到奇数位</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法——排序</title>
    <url>/2020/06/30/Algorithm-Sort/</url>
    <content><![CDATA[<p><img src="/2020/06/30/Algorithm-Sort/top.png" style="width:50%"></p>
<a id="more"></a>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote>
<p><strong>定义：</strong>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>运行时间与输入无关</li>
<li>数据移动时最少的</li>
</ul>
<p><img src="/2020/06/30/Algorithm-Sort/1.png" style="width:50%"></p>
<p><img src="/2020/06/30/Algorithm-Sort/2.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[k])</span><br><span class="line">                    k=j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( k != i ) &#123;</span><br><span class="line">                nums[k]=nums[k]+nums[i];</span><br><span class="line">                nums[i]=nums[k]-nums[i];</span><br><span class="line">                nums[k]=nums[k]-nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该算法将第<code>i</code>小的元素放到<code>a[i]</code> 之中。数组的第<code>i</code> 个位置的左边是<code>i</code>个最小的元素且它们不会再被访问。</p>
<h1 id="插入排序（-O-n-2-）"><a href="#插入排序（-O-n-2-）" class="headerlink" title="插入排序（$O(n^2)$）"></a>插入排序（$O(n^2)$）</h1><blockquote>
<p><strong>定义：</strong>将一个待排序的序列插入到一个前面已排好序的子序列当中。</p>
<p>为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li><strong>插入排序所需的时间取决于输入中元素的初始顺序</strong></li>
</ul>
<p><img src="/2020/06/30/Algorithm-Sort/3.png" style="width:50%"></p>
<p><strong>步骤：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/1_1.png" style="width:50%"></p>
<ul>
<li>初始L[1]是一个已经排好序的子序列</li>
<li>对于元素<code>L[i](L[2]~L[])</code>插入到前面已经排好序的子序列当中</li>
</ul>
<ol>
<li>查找出<code>L[i]</code>在<code>L[1,...,i-1]</code>中的插入位置<code>k</code></li>
<li>将<code>L[k,...,i-1]</code>中的所有元素后移一个位置</li>
<li>将<code>L[i]</code>复制到<code>l[k]</code></li>
</ol>
<p><strong>代码1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span> &amp;&amp; nums[j]&lt;nums[j<span class="number">-1</span>];--j)&#123;</span><br><span class="line">                nums[j]=nums[j]+nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j<span class="number">-1</span>]=nums[j]-nums[j<span class="number">-1</span>];</span><br><span class="line">                nums[j]=nums[j]-nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>代码2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];				<span class="comment">// A[0]作为哨兵元素</span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>].key&lt;A[j].key;j--)	<span class="comment">// 为哨兵找到合适的位置</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">        A[j+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/30/Algorithm-Sort/1_2.png" style="width:30%"></p>
<p>对于<code>1</code> 到<code>N-1</code> 之间的每一个<code>i</code>，将<code>a[i]</code> 与<code>a[0]</code> 到<code>a[i-1]</code> 中比它小的所有元素依次有序地交换。在索引<code>i</code> 由左向右变化的过程中，它左侧的元素总是有序的，所以当<code>i</code> 到达数组的右端时排序就完成了。</p>
<p><strong>要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素（这样访问数组的次数就能减半）</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/4.png" style="width:30%"></p>
<p><strong>性质：</strong></p>
<ol>
<li>对于长度为<code>N</code>的数组，选择排序需要大约$N^2/2$次比较和$N$ 次交换。</li>
<li>对于随机排列的长度为<code>N</code>且主键不重复的数组，平均情况下插入排序需要～ $N^2/4$ 次比较以及～ $N^2/4$ 次交换。最坏情况下需要～ $N^2/2$ 次比较和～ $N^2/2$ 次交换，最好情况下需要$N-1$次比较和$0$ 次交换。</li>
<li>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</li>
<li>对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。</li>
</ol>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        </span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>;					<span class="comment">// 折半查找</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid].key&gt;A[<span class="number">0</span>].key)</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;++j)		<span class="comment">// 元素移动</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p><strong>定义：</strong>基于插入排序的快速排序算法</p>
<p>希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>使数组中任意间隔为<code>h</code>的元素都是有序的。这样的数组被称为<code>h</code>有序数组。实现希尔排序的一种方法是对于每个<code>h</code>，用插入排序将<code>h</code>个子数组独立地排序。</p>
<p>但因为子数组是相互独立的，一个更简单的方法是在<code>h</code>-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由1 改为<code>h</code>即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。</p>
</blockquote>
<p><img src="/2020/06/30/Algorithm-Sort/5.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;n/<span class="number">3</span>)</span><br><span class="line">            h=<span class="number">3</span>*h+<span class="number">1</span>;		<span class="comment">// 1，4，13，40，121...</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h &amp;&amp; nums[j]&lt;nums[j-h];j-=h)&#123;</span><br><span class="line">                    nums[j]=nums[j]+nums[j-h];</span><br><span class="line">                	nums[j-h]=nums[j]-nums[j-h];</span><br><span class="line">                	nums[j]=nums[j]-nums[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/30/Algorithm-Sort/6.png" style="width:50%"></p>
<p><img src="/2020/06/30/Algorithm-Sort/7.png" style="width:50%"></p>
<p><strong>性质：</strong></p>
<ol>
<li>算法的性能不仅取决于<code>h</code>，还取决于<code>h</code>之间的数学性质，比如它们的公因子等。</li>
<li>希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。</li>
<li>使用递增序列1, 4, 13, 40, 121, 364…的希尔排序所需的比较次数不会超出N 的若干倍乘以递增序列的长度。</li>
</ol>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<p><strong>定义：</strong>将两个有序的数组归并成一个更大的有序数组。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。</p>
<p>能够保证将任意长度为<code>N</code>的数组排序所需时间和$NlogN$成正比；它的主要缺点则是它所需的额外空间和<code>N</code>成正比。</p>
</blockquote>
<p><img src="/2020/06/30/Algorithm-Sort/8.png" style="width:50%"></p>
<h2 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h2><blockquote>
<p><strong>定义：</strong>将两个不同的有序数组归并到第三个数组中。创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入这个数组中。</p>
<p><strong>思路：</strong>归并排序利用了分治的思想来对序列进行排序。对一个长为 $n$ 的待排序的序列，我们将其分解成两个长度为$ \frac{n}{2} $ 的子序列。 每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序。</p>
</blockquote>
<p><strong>算法：</strong></p>
<p> 定义 <code>mergeSort(nums, l, r)</code> 函数表示对 <code>nums</code> 数组里<code>[l,r]</code>的部分进行排序，整个函数流程如下： </p>
<ol>
<li><p>递归调用函数 <code>mergeSort(nums, l, mid)</code> 对 <code>nums</code> 数组里<code>[l,mid]</code>部分进行排序；</p>
</li>
<li><p>递归调用函数 <code>mergeSort(nums, mid + 1, r)</code> 对 <code>nums</code> 数组里<code>[mid+1,r]</code>部分进行排序；</p>
</li>
<li><p>此时 <code>nums</code> 数组里<code>[l,mid]</code>和<code>[mid+1,r]</code>两个区间已经有序，我们对两个有序区间线性归并即可使<code>nums</code> 数组里<code>[l,r]</code>部分有序。</p>
<p> 线性归并的过程并不难理解，由于两个区间均有序，所以我们维护两个指针 <code>i</code>和<code>j</code>表示当前考虑到<code>[l，mid]</code>里的第<code>i</code>个位置和<code>[mid+1，r]</code>里的第<code>j</code>个位置。</p>
<p> 如果 <code>nums[i] &lt; nums[j]</code> ， 那么我们就将<code>nums[i]</code>放进临时数组<code>tmp</code>中并让<code>i+1</code>，即指针后移。否则我们将<code>nums[j]</code>放入临时数组<code>tmp</code>中并让<code>j+1</code>。 如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入 <code>tmp</code> 数组中即可。 </p>
<p> 这样能保证我们每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后<code>[l,r]</code>即为有序的。</p>
<p> 函数递归调用的入口为 <code>mergeSort(nums, 0, nums.length - 1)</code>，递归结束当且仅当 <code>l &gt;= r</code>。 </p>
</li>
</ol>
<p><strong>归并结果：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/9.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=lo,j=mid+<span class="number">1</span>;			<span class="comment">// 将左边和右边归并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;++k)&#123;</span><br><span class="line">        aux[k]=a[k];			<span class="comment">// 复制数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) <span class="comment">// 归并回到a[lo..hi]</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi ) a[k] = aux[i++];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">		<span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(nums, l, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) tmp[cnt++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) tmp[cnt++] = nums[j++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) nums[i + l] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.resize((<span class="keyword">int</span>)nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><blockquote>
<p><strong>思路：</strong>如果它能将两个子数组排序，它就能够通过归并两个子数组来将整个数组排序。</p>
</blockquote>
<p><strong>归并结果：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/10.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;			<span class="comment">// 归并辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;	<span class="comment">// 一次性分配空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi])</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=lo+(hi-lo)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,mid);			<span class="comment">// 将左边排序</span></span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);		<span class="comment">// 将右边排序</span></span><br><span class="line">        merge(a,lo,mid,hi);		<span class="comment">// 原地归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排序轨迹：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/11.png" style="width:30%"></p>
<h2 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h2><blockquote>
<p><strong>思路：</strong>分治法，实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。</p>
<p>首先我们进行的是两两归并（把每个元素想象成一个大小为1 的数组），然后是四四归并（将两个大小为2 的数组归并成一个有4个元素的数组），然后是八八的归并，一直下去。</p>
</blockquote>
<p><strong>归并结果：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/12.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=a.length;</span><br><span class="line">        aux=<span class="keyword">new</span> Cpmparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;N;sz+=sz)&#123;				<span class="comment">// sz子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo=<span class="number">0</span>;lo&lt;N=sz;lo+=sz+sz)&#123;	<span class="comment">// lo：</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排序轨迹：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/14.png" style="width:30%"></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote>
<p><strong>定义：</strong>它将一个数组分成两个子数组，将两部分独立地排序。</p>
<p><strong>思路：</strong>分治法，与归并排序互补：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序（递归发生在处理整个数组之前）；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了（递归发生在处理整个数组之后）。</p>
</blockquote>
<p><strong>示意图：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/15.png" style="width:50%"></p>
<p><strong>排序结果：</strong></p>
<p><img src="/2020/06/30/Algorithm-Sort/16.png" style="width:50%"></p>
<p><strong>伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i, j, base, temp;</span><br><span class="line">	i = left, j = right;</span><br><span class="line">	base = arr[left];  <span class="comment">//取最左边的数为基准数</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//基准数归位</span></span><br><span class="line">	arr[left] = arr[i];</span><br><span class="line">	arr[i] = base;</span><br><span class="line">	quickSort(left, i - <span class="number">1</span>, arr);<span class="comment">//递归左边</span></span><br><span class="line">	quickSort(i + <span class="number">1</span>, right, arr);<span class="comment">//递归右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/30/Algorithm-Sort/17.png" style="width:50%"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——串</title>
    <url>/2020/06/30/DataStructure-String/</url>
    <content><![CDATA[<p><img src="/2020/06/30/DataStructure-String/top.png" style="width:50%"></p>
<a id="more"></a>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p><strong>定义：</strong>由0个或多个字符组成的有限序列，记为</p>
<p><img src="/2020/06/30/DataStructure-String/1.png" style="width:30%"></p>
<ol>
<li>若两个串的长度相等且每个对应位置的字符都相等时，称这两个串时相等的</li>
<li><strong>子串</strong>：串中任意个连续的字符组成的子序列成为字串</li>
<li><strong>主串</strong>：包含子串的串为主串</li>
</ol>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="定长顺序存储结构"><a href="#定长顺序存储结构" class="headerlink" title="定长顺序存储结构"></a>定长顺序存储结构</h3><p><img src="/2020/06/30/DataStructure-String/2.png" style="width:50%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 25</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];	<span class="comment">// 字符类型数组</span></span><br><span class="line">    <span class="keyword">int</span> length;			<span class="comment">// 数组长度，超过部分舍去</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<p><strong>\\0</strong>：字符串的结束</p>
<h3 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;HSting;</span><br></pre></td></tr></table></figure>
<p>malloc()/free()</p>
<h3 id="块链存储结构"><a href="#块链存储结构" class="headerlink" title="块链存储结构"></a>块链存储结构</h3><p>利用链表来存储字符串</p>
<p><img src="/2020/06/30/DataStructure-String/3.png" style="width:50%"></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>最小操作子集</strong></p>
<ul>
<li><p><strong>赋值（<code>StrAssign(&amp;T, chars)</code>）</strong></p>
</li>
<li><p><strong>比较（<code>StrCompare(S, T)</code>）</strong></p>
</li>
<li><p><strong>串长（<code>StrLength(S)</code>）</strong></p>
</li>
<li><p><strong>子串（<code>SubString(&amp;Sub, S, pos, length)</code>）</strong></p>
</li>
<li><p><strong>联接（<code>Concat(&amp;T, S1, S2)</code>）</strong></p>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><img src="/2020/06/30/DataStructure-String/4.png" style="width:50%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">            <span class="keyword">return</span> i-T.length;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/30/DataStructure-String/5.png" style="width:70%"></p>
<h3 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h3><ol>
<li><p><strong>前缀</strong>：除最后一个字符外，字符串所有头部子串</p>
</li>
<li><p><strong>后缀</strong>：除第一个字符外，字符串所有的尾部子串</p>
</li>
<li><p><strong>部分匹配值</strong>：字符串前缀和后缀最长相等前后缀的长度——<strong>移动步长</strong></p>
<p><img src="/2020/06/30/DataStructure-String/6.png" style="width:30%"></p>
<p><img src="/2020/06/30/DataStructure-String/7.png" style="width:50%"></p>
</li>
<li><p>next数组存储</p>
<p><img src="/2020/06/30/DataStructure-String/8.png" style="width:50%"></p>
<p><img src="/2020/06/30/DataStructure-String/9.png" style="width:50%"></p>
<p><strong>右移：1）第一个元素右移后变为-1；2）最后一个元素右移后直接舍去</strong></p>
<p><img src="/2020/06/30/DataStructure-String/10.png" style="width:50%"></p>
</li>
<li><p><img src="/2020/06/30/DataStructure-String/11.png" style="width:50%"></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/30/DataStructure-String/12.png" style="width:50%"></p>
<p><strong>KMP</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> next[], <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode探索——栈和队列</title>
    <url>/2020/06/23/leetcode-explore-stackqueue/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li><strong>实现</strong></li>
</ul>
<p>动态数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        data.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回栈顶</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        data.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最小栈——借助辅助栈</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; x_stack;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_stack;</span><br><span class="line">    MinStack()&#123;</span><br><span class="line">        min_stack.push(INT_MAX);		<span class="comment">// 最小栈的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        x_stack.push(x);</span><br><span class="line">        min_stack.push(<span class="built_in">min</span>(x,min_stack.top());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> pop()&#123;</span><br><span class="line">        x_stack.pop();</span><br><span class="line">        min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> top()&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> getMin()&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有效的括号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span>(str.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(idx&lt;str.<span class="built_in">size</span>())&#123;		<span class="comment">// 依次入栈</span></span><br><span class="line">            <span class="keyword">if</span>(s.empty())</span><br><span class="line">                s.push(str[idx++]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[idx]==<span class="string">')'</span>&amp;&amp;s.top()==<span class="string">'('</span> || str[idx]==<span class="string">'&#125;'</span>&amp;&amp;s.top()==<span class="string">'&#123;'</span> || str[idx]==<span class="string">']'</span>&amp;&amp;s.top()==<span class="string">'['</span>)		<span class="comment">// 匹配， 则弹出</span></span><br><span class="line">                    s.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s.push(str[idx]);	<span class="comment">// 继续入栈</span></span><br><span class="line">                </span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 执行完毕栈为空，返回true</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 反之返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>每日气温——单调栈</li>
</ul>
<ol>
<li>遍历每日温度，维护一个单调栈<ol>
<li>若栈为空或者当日温度小于等于栈顶温度则直接入栈</li>
<li>反之，若当日温度大于栈顶温度，说明栈顶元素的升温已经找到，则将该元素出栈，计算其与当日相差天数即可</li>
</ol>
</li>
<li>注意题目要求是升温的天数，而不是升温后的温度，因此栈中应该存储下表，而非温度</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n=T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;T[i]&gt;T[s.top()])&#123;</span><br><span class="line">                <span class="keyword">int</span> previousIndex =s.top();</span><br><span class="line">                ans[previousIndex]=i-previousIndex;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>逆波兰表达式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">string2int</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;&amp;m_sta,<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;m_sta;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            s=tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">"+"</span>||s==<span class="string">"-"</span>||s==<span class="string">"*"</span>||s==<span class="string">"/"</span>)</span><br><span class="line">                compute(m_sta,s);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m_sta.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=string2int(m_sta.top());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">stringstream</span> str;</span><br><span class="line">    str&lt;&lt;x;</span><br><span class="line">    str&gt;&gt;s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string2int</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">stringstream</span> str;</span><br><span class="line">    str&lt;&lt;s;</span><br><span class="line">    str&gt;&gt;x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt;&amp;m_sta,<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=string2int(m_sta.top());</span><br><span class="line">    m_sta.pop();</span><br><span class="line">    <span class="keyword">int</span> b=string2int(m_sta.top());</span><br><span class="line">    m_sta.pop();</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"+"</span>)</span><br><span class="line">        ans=int2string(b+a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"-"</span>)</span><br><span class="line">        ans=int2string(b-a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"*"</span>)</span><br><span class="line">        ans=int2string(b*a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans=int2string(b/a);</span><br><span class="line">    m_sta.push(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode探索——二叉树</title>
    <url>/2020/06/23/leetcode-explore-binarytree/</url>
    <content><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li>二叉树的前序遍历**</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        temp = preorderTraversal(root-&gt;left);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        temp = preorderTraversal(root-&gt;right);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>二叉树的中序遍历</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        temp=inorderTraversal(root-&gt;left);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        temp=inorderTraversal(root-&gt;right);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>二叉树的后序遍历</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        temp=postorderTraversal(root-&gt;left);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        temp=postorderTraversal(root-&gt;right);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());  </span><br><span class="line">        </span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>二叉树的层次遍历</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;     <span class="comment">// 初始化队列</span></span><br><span class="line">        q.push(root);           <span class="comment">// 根结点入队列 第一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            res.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;currentLevelSize;++i)&#123;        <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)                         <span class="comment">// 第二步</span></span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.push(node-&gt;right);                <span class="comment">// 第三步</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的深度与路径"><a href="#二叉树的深度与路径" class="headerlink" title="二叉树的深度与路径"></a>二叉树的深度与路径</h2><ul>
<li>二叉树最大深度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自顶向下</span></span><br><span class="line"><span class="keyword">int</span> answer;		       <span class="comment">// 初始化answer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = <span class="built_in">max</span>(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;                                 </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left_depth = maximum_depth(root-&gt;left);</span><br><span class="line">	<span class="keyword">int</span> right_depth = maximum_depth(root-&gt;right);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(left_depth, right_depth) + <span class="number">1</span>;	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=maxDepth(root-&gt;left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r=maxDepth(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l&gt;r?l:r;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对称二叉树</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (!root) ? <span class="literal">true</span> : dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p1, TreeNode* p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p1 || !p2) <span class="keyword">return</span> !p1 &amp;&amp; !p2; <span class="comment">//一个为空返回false，两个为空返回true</span></span><br><span class="line">        <span class="keyword">return</span> p1-&gt;val == p2-&gt;val &amp;&amp; dfs(p1-&gt;left, p2-&gt;right) &amp;&amp; dfs(p1-&gt;right, p2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>路径总和</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;			<span class="comment">// 树为空</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)		<span class="comment">// 树只有一个根节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h2><ul>
<li><strong>从中序与后序遍历序列构造二叉树</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从前序与中序遍历序列构造二叉树</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,inorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> pre_start,<span class="keyword">int</span> pre_end,<span class="keyword">int</span> inorder_start,<span class="keyword">int</span> inorder_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_start &gt; pre_end || inorder_start &gt; inorder_end)&#123;<span class="keyword">return</span> <span class="literal">NULL</span>&#125;;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[pre_start]);  	<span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre_start==pre_end)&#123;<span class="keyword">return</span> root;&#125;			<span class="comment">// 只有一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index=inorder_start;</span><br><span class="line">        <span class="keyword">while</span>(pre[pre_start]!=inorder[index])&#123;</span><br><span class="line">            index++;									<span class="comment">// 记录中序遍历序列中根节点的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left=helper(pre,inorder,pre_start+<span class="number">1</span>,pre_start+<span class="number">1</span>+index<span class="number">-1</span>-inorder_start,inorder_start,index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(pre,inorder,pre_start+<span class="number">1</span>+<span class="number">1</span>+index<span class="number">-1</span>-inorder_start,pre_end,index+<span class="number">1</span>,inorder_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从前序和后序遍历序列构造二叉树</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/2020/06/23/DataStructure-StackQueue01/</url>
    <content><![CDATA[<p><img src="/2020/06/23/DataStructure-StackQueue01/01.png" style="width:50%"></p>
<a id="more"></a>
<h1 id="栈（stack）——后进先出（LIFO）"><a href="#栈（stack）——后进先出（LIFO）" class="headerlink" title="栈（stack）——后进先出（LIFO）"></a>栈（stack）——后进先出（LIFO）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>只允许在<strong>一端</strong>进行插入或删除操作的<strong>受限线性表</strong></p>
<p><strong>栈顶（top）</strong>：可以出栈的一端</p>
<p><strong>栈底（bottom）</strong>：无法出入栈的一端</p>
<p><strong>入栈</strong>：$s=(a_1,a_2,a_3,a_4,a_5)$，出栈：$(a_5,a_4,a_3,a_2,a_1)$</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>初始化（InitStack(&amp;S)）</strong>——初始化一个空栈S</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判空（StackEmpty(S)）</strong>——判断一个栈是否为空，若栈为空则返回true，否则返回false</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进栈（Push(&amp;S,x)）</strong>——若栈S未满，则将x加入栈使之成为新的<strong>栈顶</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top]=x;		<span class="comment">// 先对top加1操作，再进行赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出栈（Pop(&amp;S,&amp;x)）——会删除</strong>——若栈S非空，则弹出<strong>栈顶</strong>元素，并用x返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top--];		<span class="comment">// 先给x赋值，再对top减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读取栈顶（GetTop(S,&amp;x)）——不会删除</strong>——读取栈顶元素，若栈S非空则用x返回栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><img src="/2020/06/23/DataStructure-StackQueue01/0203.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack<span class="number">'</span></span><br></pre></td></tr></table></figure>
<h4 id="共享栈——将两个栈底设置在共享空间的两端，栈顶向空间中间延伸"><a href="#共享栈——将两个栈底设置在共享空间的两端，栈顶向空间中间延伸" class="headerlink" title="共享栈——将两个栈底设置在共享空间的两端，栈顶向空间中间延伸"></a>共享栈——将两个栈底设置在共享空间的两端，栈顶向空间中间延伸</h4><p><strong>判空</strong>：0号栈<code>top==-1</code>，1号栈<code>top==MaxSize</code></p>
<p><strong>栈满</strong>：<code>top1-top0==1</code></p>
<p><strong>优点</strong>：存取复杂度$O(1)$，但空间利用更有效</p>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p><strong>定义</strong>：采用链式存储的栈（类似单链表，表头节点为栈顶，<strong>所有操作在表头进行</strong>）</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/04.png" style="width:60%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure>
<h1 id="队列（Queue）——先进先出（FIFO）"><a href="#队列（Queue）——先进先出（FIFO）" class="headerlink" title="队列（Queue）——先进先出（FIFO）"></a>队列（Queue）——先进先出（FIFO）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>只能在表的一端进行插入，在另一端进行删除的线性表</p>
<p><strong>队头操作</strong>：出队</p>
<p><strong>队尾操作</strong>：入队</p>
<h2 id="基本操作（循环队列）"><a href="#基本操作（循环队列）" class="headerlink" title="基本操作（循环队列）"></a>基本操作（循环队列）</h2><p><strong>初始化（InitQueue(&amp;Q)）</strong>——初始化队列，构造一个空队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判空（QueueEmpty(Q)）</strong>——判断队列是否为空，若为空返回true，否则返回false</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入队（EnQueue(&amp;Q,x)）</strong>——若队列Q非空，则将x加入使之成为新的队尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出队（DeQueue(&amp;Q,&amp;x)）</strong>——若队列Q非空，则删除对头元素，并用x返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读取队头（GetHead(Q,&amp;X)）</strong>——读取队头元素，若队列非空则用x返回队头元素</p>
<p><strong>销毁队列（ClearQueue(&amp;Q)）</strong>销毁队列，并释放队列Q占用的内存空间</p>
<h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><strong>定义</strong>：采用顺序存储的队列，front——队头，rear——队尾后一个</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/05.png" style="width:40%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p><strong>front指向队头——rear指向队尾下一个</strong></p>
<p><strong>初始化：front、rear=0</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/06.png" style="width:70%"></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><strong>定义</strong>：把存储队列的顺序队列在逻辑上视为一个环（将最后一个元素的后一个单元与第一个元素链接）——<strong>取余</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/07.png" style="width:70%"></p>
<p><strong>判空</strong>：<code>Q.front==Q.rear</code></p>
<p><strong>判满</strong>：<code>Q.front==Q.rear</code></p>
<p>但是出现了重复！！！</p>
<p><strong>方法1：</strong>牺牲一个存储单元</p>
<p><strong>判空</strong>：<code>Q.front==Q.rear</code></p>
<p><strong>判满</strong>：<code>Q.front==(Q.rea+1)%NaxSize</code></p>
<p><strong>方法2：</strong>增加一个变量代表元素个数</p>
<p><strong>判空</strong>：<code>Q.size==0</code></p>
<p><strong>判满</strong>：<code>Q.size==MaxSize</code></p>
<p><strong>方法3：</strong>增加tag标识</p>
<p><strong>判空</strong>：<code>Q.front==Q.rear&amp;&amp;tag==0</code></p>
<p><strong>判满</strong>：<code>Q.front==Q.rear&amp;&amp;tag==1</code></p>
<h2 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p><strong>定义</strong>：用链式存储的队列——带有头节点的链式队列</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/09.png" style="width:30%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p><strong>初始化InitQueue(&amp;Q)</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/09.png" style="width:30%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=(LinkNode*)<span class="built_in">malloc</span>(sizrof(LinkNode));</span><br><span class="line">    Q.rear=Q.front;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>判空isEmpty(Q)</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/09.png" style="width:30%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入队EnQueue(&amp;Q, x)</strong></p>
<p><strong>尾插法</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/10.png" style="width:40%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出队</strong></p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/11.png" style="width:50%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkqUEUE &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)			<span class="comment">// 如果只有一个元素</span></span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><strong>定义：</strong>允许两端都可以进行入队和出队操作的队列</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/13.png" style="width:60%"></p>
<p>屏蔽一端的插入和删除操作，得到一个栈！！！</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/14.png" style="width:60%"></p>
<p><strong>连续输入和输出</strong></p>
<p><strong>栈——逆序</strong>；</p>
<p><strong>队列——顺序</strong></p>
<p><strong>非连续输入和输出</strong></p>
<p><strong>合法的序列：</strong>出栈序列中每一个元素后面所有比它小的元素组成一个递减序列</p>
<p><img src="/2020/06/23/DataStructure-StackQueue01/12.png" style="width:55%"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h3><ul>
<li><strong>括号匹配</strong></li>
</ul>
<p><strong>算法思想</strong>：</p>
<ol>
<li>初始化一个空栈，顺序读入括号</li>
<li>若是右括号，则与栈顶元素进行匹配<ol>
<li>若匹配，则弹出栈顶元素并进行下一个元素</li>
<li>若不匹配，则该序列不合法</li>
</ol>
</li>
<li>若是左括号，则压入栈中</li>
<li>若全部元素遍历完毕，栈中非空序列不合法</li>
</ol>
<ul>
<li><strong>表达式求值：[(A+B)*C]-[E-F]</strong></li>
</ul>
<p><strong>表达式分类</strong>：</p>
<ol>
<li><strong>前缀表达式</strong>：+AB</li>
<li><strong>中缀表达式</strong>：A+B</li>
<li><strong>后缀表达式</strong>：AB+</li>
</ol>
<p>例如：[(A+B)*C]-[E-F]</p>
<p><strong>前缀表达式</strong>：+AB—&gt;* +AB C—&gt;* +AB C    -EF—&gt;<strong>-* +AB C -EF</strong></p>
<p><strong>后缀表达式</strong>：AB+—&gt;AB+C*—&gt;AB+C*  EF-—&gt;<strong>AB+C* EF—</strong></p>
<p><strong>算法思想</strong>：（中缀转后缀）</p>
<ol>
<li>数字直接加入后缀表达式</li>
<li>运算符时：<ol>
<li>若为’(‘，入栈；</li>
<li>若为’)’，则一次把栈中的运算符加入后缀表达式，直到出现’(‘，并从栈中删除’(‘;</li>
<li>若为’+’，’-‘，’*‘，’/‘，<ol>
<li>栈空，入栈；</li>
<li>栈顶元素为’(‘时，入栈；</li>
<li>高于栈顶元素优先级，入栈；</li>
<li>否则，一次弹出运算符，直到一个优先级比它低的运算符或’(‘为止；</li>
</ol>
</li>
<li>遍历完成，若栈非空依次弹出所有元素。</li>
</ol>
</li>
</ol>
<p><strong>递归</strong></p>
<p>递归表达式+递归出口</p>
<p>缺点：</p>
<ol>
<li>在递归调用过程中，系统为每层返回点、局部变量、传入实参等开辟递归工作栈来进行数据存储，递归次数过多容易造成栈溢出</li>
<li>通常情况下递归的效率并不高</li>
</ol>
<p><strong>递归算法转换为非递归算法时，需要借助栈</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——图的存储与操作</title>
    <url>/2020/06/12/DataStructure-Graph02/</url>
    <content><![CDATA[<h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><ol>
<li>结点数为$n$的图$G=(V,E)$的邻接矩阵$A$是$n\times n$的。</li>
<li>将$G$的顶点编号为$V_1$，$V_2$，$V_3$，…，$V_n$（数组下标）</li>
<li>若&lt;$V_i,V_j$&gt;$\in E$，则$A[i][j]=1$，否则$A[i][j]=0$。</li>
</ol>
<script type="math/tex; mode=display">
A[i][j]=\begin{cases}
1 & 若(V_i,V_j)或<V_i,V_j>是E(G)中的边 \\
0 & 若(V_i,V_j)或<V_i,V_j>不是E(G)中的边
\end{cases}</script><h3 id="无向图-amp-有向图"><a href="#无向图-amp-有向图" class="headerlink" title="无向图&amp;有向图"></a>无向图&amp;有向图</h3><div class="table-container">
<table>
<thead>
<tr>
<th>无向图</th>
<th>有向图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/wuxiang.png" style="width: 30%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/youxiang.png" style="width: 30%"></td>
</tr>
<tr>
<td>$V={A,B,C,D,E}$<br>$E={(A,B),(A,C),(A,E),(B,C),(C,D),(C,E)}$</td>
<td>$V={A,B,C,D,E}$<br>$E$={&lt;$B$,$A$&gt;,&lt;$A$,$C$&gt;,&lt;$A$,$E$&gt;,&lt;$B$,$C$&gt;,&lt;$C$,$D$&gt;,&lt;$C$,$E$&gt;}</td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/wuxiang1.png" style="width: 30%"><br><img src="/2020/06/12/DataStructure-Graph02/youxiang2.png" style="width: 50%"><img src="/2020/06/12/DataStructure-Graph02/wuxiang3.png" style="width: 50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/youxiang1.png" style="width: 30%"><br><img src="/2020/06/12/DataStructure-Graph02/youxiang2.png" style="width: 50%"><img src="/2020/06/12/DataStructure-Graph02/youxiang3.png" style="width: 50%"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="网"><a href="#网" class="headerlink" title="网"></a>网</h3><ol>
<li>结点数为$n$的图$G=(V,E)$的邻接矩阵$A$是$n\times n$的。</li>
<li>将$G$的顶点编号为$V_1$，$V_2$，$V_3$，…，$V_n$（数组下标）</li>
<li>若&lt;$V_i,V_j$&gt;$\in E$，则$A[i][j]=w_{i,j}$，否则$A[i][j]=\infty$。</li>
</ol>
<script type="math/tex; mode=display">
A[i][j]=\begin{cases}
w_{i,j} & 若(V_i,V_j)或<V_i,V_j>是E(G)中的边 \\
A[i][j]=\infty & 若(V_i,V_j)或<V_i,V_j>不是E(G)中的边
\end{cases}</script><div class="table-container">
<table>
<thead>
<tr>
<th>无向网</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/wuxiangnet.png" style="width: 15%"></td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/nety.png" style="width: 15%"><br><img src="/2020/06/12/DataStructure-Graph02/metrixy.png" style="width: 25%"></td>
</tr>
<tr>
<td>1. 邻接矩阵法的空间复杂度为$O(n^2)$，适用于稠密图<br>2. 无向图的邻接矩阵为对称矩阵<br>3. 无向图中第$i$行（或第$j$列）非$0$元素（非正无穷）的个数为第$i$个顶点的度；<br>4. 有向图中第$i$行（第$j$列）非$0$元素（非正无穷）的个数为第$i$个顶点的出度（入度）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="邻接矩阵运算"><a href="#邻接矩阵运算" class="headerlink" title="邻接矩阵运算"></a>邻接矩阵运算</h3><p><strong>设图$G$的邻接矩阵为$A$，矩阵运算$A^n$的含义？</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$A^2$的含义</th>
<th>$A^n$的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/AN1.png" style="width: 100%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/AN2.png" style="width: 100%"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><ol>
<li><strong>定义：</strong>为每个顶点建立一个单链表存放与它相邻的边</li>
<li><strong>顶点表：</strong>采用<strong>顺序存储</strong>，每个数组存放顶点的数据和边表的头指针</li>
<li><strong>边表（出边表）：</strong>采用<strong>链式存储</strong>，单链表中存放与一个顶点相邻的所有边，一个链表节点表示一条从该顶点到链表节点顶点的边（有向图有方向）</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>顶点表节点</th>
<th>边表节点</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/node_list.png" style="width: 100%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/node_list.png" style="width: 100%"></td>
</tr>
</tbody>
</table>
</div>
<p>需要有边的存在则建立，可节省空间</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>有向图</th>
<th>无向图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/eg.png" style="width: 100%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/eg1.png" style="width: 100%"></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>代码定义：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 边表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;				<span class="comment">// 边的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">next</span>;</span>	<span class="comment">// 下一条边</span></span><br><span class="line">    <span class="comment">// InforType info;		// 边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">// 顶点节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;		<span class="comment">// 顶点数据</span></span><br><span class="line">    ArcNode* first;			<span class="comment">// 边表头节点</span></span><br><span class="line">&#125;VNode,Adjust[MaxVertexNum];</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdiList vetices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>特点：</strong>无向图——存储空间$O(|V|+|2E|)$；有向图——存储空间$O(|V|+|E|)$；适用于稀疏图；邻接表不唯一</li>
</ol>
<p><img src="/2020/06/12/DataStructure-Graph02/com.png" style="width: 50%"></p>
<h2 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h2><p><strong>定义：</strong>有向图的一种链式存储结构，为了快速寻找出边和入边。即保存出边，又保存入边</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>顶点表节点</th>
<th>边表节点</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph02/node_cro.png" style="width: 70%"></td>
<td><img src="/2020/06/12/DataStructure-Graph02/arc_cro.png" style="width: 100%"></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2020/06/12/DataStructure-Graph02/gra_cro.png" style="width: 50%"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tailvex,headvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">hlink</span>,*<span class="title">tlink</span>;</span></span><br><span class="line">    <span class="comment">// InforType info;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode* firstin,*firstout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VNode xlist[MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;GLGraph;</span><br></pre></td></tr></table></figure>
<h2 id="邻接多重表法"><a href="#邻接多重表法" class="headerlink" title="邻接多重表法"></a>邻接多重表法</h2><h1 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——图的基本概念</title>
    <url>/2020/06/12/DataStructure-Graph01/</url>
    <content><![CDATA[<p><img src="/2020/06/12/DataStructure-Graph01/graph1.png" style="width:35%"></p>
<a id="more"></a>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><strong>定义：图</strong>$G$有顶点集$V$和边集$E$组成，记为$G=(V,E)$，其中$V(G)$表示图$G$中顶点的<strong>有限非空集</strong>；$E(G)$表示图$G$中顶点之间的关系（边）集合。<br><img src="/2020/06/12/DataStructure-Graph01/graph2.png" style="width:20%"></li>
<li>顶点集：$V={A，B，C，D，E}$，$|V|=5$</li>
<li>边集：$E={（A，B），（A，C），（A，E），（B，C），（C，D），（C，E）}$，$|E|=6$<br><strong>线性表、树可以为空，但是图不能为空！</strong></li>
<li><strong>术语：</strong>$|V|$表示图$G$中顶点的个数，也称图$G$的阶；$|E|$表示图$G$中边的条数</li>
<li><strong>顶点的度：</strong>以该顶点为端点的边的数目</li>
</ol>
<h1 id="无向图-amp-有向图"><a href="#无向图-amp-有向图" class="headerlink" title="无向图&amp;有向图"></a>无向图&amp;有向图</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>无向图</strong></th>
<th><strong>有向图</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph3.png" style="width: 60%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph4.png" style="width: 65%"></td>
</tr>
<tr>
<td>无向边：$v$——$w$<br>无序对：$(v, w)=(w, v)$，$v,w$互为邻接点。</td>
<td>有向边：$v$——&gt;$w$<br>有序对：&lt;$v,w$&gt;$\neq$ &lt;$w,v$&gt;，$v$邻接到$w$，$w$邻接自$v$。</td>
</tr>
<tr>
<td><strong>顶点的度</strong></td>
<td></td>
</tr>
<tr>
<td>以$v$为端点的边的个数——$TD(v)$<br>$n$顶点，$e$条边无向图度的总数：$\sum_{i=1}^nTD(v_i)=2e$</td>
<td><strong>出度</strong>：以$v$为起点的有向边的条数——$OD(v)$<br><strong>入度</strong>：以$v$为终点的有向边的条数——$ID(v)$<br><strong>顶点$v$的度</strong>：$TD(v)=ID(v)+OD(v)$<br>$n$顶点，$e$条边有向图出度、入度满足：$\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e$</td>
</tr>
<tr>
<td><strong>连通</strong></td>
<td><strong>强连通</strong></td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_lt.png" style="width: 35%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt.png" style="width: 35%"></td>
</tr>
<tr>
<td>若从顶点$v$到顶点$w$有<strong>路径</strong>（不一定是边）存在，则称$v$和$w$是连通</td>
<td>若从顶点$v$到顶点$w$和顶点$w$到顶点$v$都有<strong>路径</strong>（不一定是边）存在，则称$v$和$w$是强连通</td>
</tr>
<tr>
<td><strong>连通图</strong></td>
<td><strong>强连通图</strong></td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_lt_eg.png" style="width: 35%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt_eg.png" style="width: 35%"></td>
</tr>
<tr>
<td>任意两个结点之间都是连通的</td>
<td>任意两个结点之间都是强连通的</td>
</tr>
<tr>
<td>$n$个顶点最少有$(n-1)$条边</td>
<td>$n$个顶点最少有$n$条边</td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_lt_less.png" style="width: 35%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt_less.png" style="width: 35%"></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h1 id="简单图-amp-多重图"><a href="#简单图-amp-多重图" class="headerlink" title="简单图&amp;多重图"></a>简单图&amp;多重图</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>简单图</strong></th>
<th><strong>多重图</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph5.png" style="width: 60%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph6.png" style="width: 60%"></td>
</tr>
<tr>
<td>无重复边，不存在结点到自身</td>
<td>存在重复边，或存在结点到自身的边</td>
</tr>
</tbody>
</table>
</div>
<h1 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>无向完全图</strong></th>
<th><strong>有向完全图</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph7.png" style="width:30%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph8.png" style="width:30%"></td>
</tr>
<tr>
<td>任意两个顶点之间都存在边</td>
<td>任意两个顶点之间都存在方向相反的弧</td>
</tr>
<tr>
<td>$n$个顶点有$n(n-1)/2$条边</td>
<td>$n$个顶点有$n(n-1)$条边</td>
</tr>
</tbody>
</table>
</div>
<h1 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h1><ol>
<li><strong>定义：</strong>设有两个图$G=(V,E)$和$G’=(V’,E’)$，若V’是V的子集，且$E’$是$E$的子集，则称$G’$是$G$的子图（原图也是其子图，只有顶点没有边也称为子图）；且若$V(G)=V(G’)$则称$G’$为$G$的生成子图。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>图</th>
<th>子图</th>
<th>生成子图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil_1.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil_2.png" style="width:50%"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="连通分量与-amp-强连通分量："><a href="#连通分量与-amp-强连通分量：" class="headerlink" title="连通分量与&amp;强连通分量："></a>连通分量与&amp;强连通分量：</h2><p>连通分量——极大连通子图</p>
<p>强连通分量——极大强连通子图</p>
<p><strong>定义：</strong>对于$G$的一个（强）连通子图$G’$，如果不存在$G$的另一个（强）连通子图$G’’$，使得$G’\subset G’’$，则称$G’$为$G$的（强）连通分量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>无向图</th>
<th>有向图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil.png" style="width:30%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt_eg.png" style="width:30%"></td>
</tr>
<tr>
<td><strong>连通分量</strong></td>
<td><strong>强连通分量</strong></td>
</tr>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil_sub.png" style="width:70%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt_sub.png" style="width:70%"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>非连通图的连通分量有多个，连通图的连通分量就是自身。</strong></p>
<h2 id="生成树、生成森林"><a href="#生成树、生成森林" class="headerlink" title="生成树、生成森林"></a>生成树、生成森林</h2><p><strong>连通图只能生成生成树，非连通图只能生成生成森林。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>连通图</th>
<th>极小连通子图：连通子图且包含边最少</th>
<th>生成树：连通图包含全部顶点的一个极小连通子图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_min.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_tree.png" style="width:100%"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>$n$个顶点图的生成树有$n-1$条边</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>非连通图</th>
<th>连通分量</th>
<th>生成森林：非连通图所有连通分量的生成树组成生成森林</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/flt.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/flt_ltf.png" style="width:70%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/flt_ltf_s.png" style="width:100%"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="网"><a href="#网" class="headerlink" title="网"></a>网</h1><p><strong>定义</strong>：为边增加权重（分析路径问题）</p>
<p><img src="/2020/06/12/DataStructure-Graph01/net.png" style="width:50%"></p>
<h1 id="稠密图-amp-稀疏图"><a href="#稠密图-amp-稀疏图" class="headerlink" title="稠密图&amp;稀疏图"></a>稠密图&amp;稀疏图</h1><p><strong>稠密稀疏的界定：</strong>$|E|&lt;|V|\cdot log(|V|)$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>稠密图——边多</th>
<th>稀疏图——边少</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/choumi.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/xishu.png" style="width:50%"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="有向树"><a href="#有向树" class="headerlink" title="有向树"></a>有向树</h1><p><strong>定义：</strong>一个顶点的入度为$0$，其余顶点的入度均为$1$的有向图</p>
<p><img src="/2020/06/12/DataStructure-Graph01/youxiangshu.png" style="width:30%"></p>
<p><strong>与树的区别：</strong>树的度为孩子结点的个数，有向树的度是出度+入度，有向树实则为图。</p>
<h1 id="路径-amp-路径长度-amp-回路"><a href="#路径-amp-路径长度-amp-回路" class="headerlink" title="路径&amp;路径长度&amp;回路"></a>路径&amp;路径长度&amp;回路</h1><p><strong>路径定义：</strong>图中顶点$v$到顶点$w$的顶点序列，序列中顶点不重复的路径称为<strong>简单路径</strong>。</p>
<p><strong>路径长度：</strong>路径上边的数目，若该路径最短则称其为<strong>距离</strong>。</p>
<p><strong>回路：</strong>第一个顶点和最后一个顶点相同的路径。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>无向图</th>
<th>有向图</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_chil.png" style="width:50%"></td>
<td><img src="/2020/06/12/DataStructure-Graph01/graph_qlt_eg.png" style="width:50%"></td>
</tr>
<tr>
<td>$A$——&gt;$D$的一条路径：$A$——&gt;$C$——&gt;$D$<br>$D$——&gt;$A$的一条路径：$D$——&gt;$C$——&gt;$A$<br>路径长度：2<br>一条回路：$A$——&gt;$C$——&gt;$E$——&gt;$A$</td>
<td>$A$——&gt;$D$的一条路径：$A$——&gt;$E$——&gt;$D$<br>$D$——&gt;$A$的一条路径：$NULL$<br>路径长度：2<br>一条回路：$A$——&gt;$B$——&gt;$A$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——哈夫曼树</title>
    <url>/2020/06/11/DataStructure-Huffman/</url>
    <content><![CDATA[<h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><ol>
<li><strong>路径长度：</strong>路径上所经历<strong>边</strong>的<strong>个数</strong></li>
<li><strong>结点的权：</strong>结点被赋予的数值</li>
<li><strong>树的带权路径长度：</strong>WPL，书中所有<strong>叶结点</strong>的带权路径长度之和，记为：</li>
</ol>
<script type="math/tex; mode=display">
WPL=\sum_{i=0}^{n} w_i l_i</script><p><img src="/2020/06/11/DataStructure-Huffman/WPL.png" style="width: 20%"></p>
<p><strong>叶节点个数相同，但是树的带权路径长度不一定相同！</strong></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><strong>定义：</strong>最优二叉树，含有$n$个带权叶子结点<strong>带权路径长度最小</strong>的二叉树</p>
<p><img src="/2020/06/11/DataStructure-Huffman/Huff_wpl.png" style="width: 20%"></p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><ol>
<li>将$n$个结点作为$n$棵仅含有一个根结点的二叉树，构成森林$F$;</li>
<li>生成一个新的结点，并从$F$中找出权值最小的两颗树作为它们的左子树和右子树，且新结点的权值为两棵子树根结点的权值之和；</li>
<li>从$F$中删除这两个数，并将新生成的数假如到$F$中；</li>
<li>重复步骤2、3，直到$F$中只有一棵树为止。</li>
</ol>
<p><img src="/2020/06/11/DataStructure-Huffman/create_1.png" style="width: 20%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/create_2.png" style="width: 20%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/create_3.png" style="width: 15%"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>每个初始结点都会成为叶子结点，双支结点都为新生成的结点</li>
<li>权值越大离根结点越近，反之离根结点越远</li>
<li>哈夫曼树中没有结点的度为$1$（叶子节点：$0$，分支结点：$2$）</li>
<li>$n$个叶子结点的哈夫曼树的结点总数为$2n-1$,其中度为$2$的结点数位$n-1$</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>对于一个字符串序列，用二进制来表示字符。</p>
<p><strong>固定长度编码：</strong>每一个字符对应的二进制长度相同</p>
<blockquote>
<p>HelloWorld</p>
<p>000001010010011100011101010110</p>
<p>000——H；001——e；010——l ；011——o</p>
<p>100——W；101——r；110——d</p>
</blockquote>
<p><strong>可变长度编码：</strong>每一个字符对应二进制长度可变</p>
<blockquote>
<p>HelloWorld</p>
<p><strong>00</strong>01001101110000</p>
<p><strong>ll/H</strong></p>
<p>00——H；01——e；0——l；1——o；</p>
<p>10——W；11——r；000——d；</p>
</blockquote>
<p><strong>前缀编码：</strong>没有一个编码是另一个编码的前缀</p>
<blockquote>
<p>HelloWorld</p>
<p>000001111101110001110111010</p>
<p>000——H；001——e；11——l；011——o；</p>
<p>100——W；101——r；010——d；</p>
</blockquote>
<h3 id="哈夫曼树——编码"><a href="#哈夫曼树——编码" class="headerlink" title="哈夫曼树——编码"></a>哈夫曼树——编码</h3><blockquote>
<p>出现次数：</p>
<p>A：2；B：3；C：6；D：9；E：10</p>
<p>利用哈夫曼树的构造过程，将所有的边赋予左边的边$0$、右边的边$1$：A——110；B——111；C——10；D——00；E——01</p>
<p><img src="/2020/06/11/DataStructure-Huffman/code_1.png" style="width: 30%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/code_2.png" style="width: 30%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/code_3.png" style="width: 30%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/code_4.png" style="width: 30%"></p>
<p><img src="/2020/06/11/DataStructure-Huffman/code_5.png" style="width: 30%"></p>
<p><strong>出现次数越多的结点越靠近根结点，因此编码更短；反之越远离根结点，编码长度越长。</strong></p>
<p><strong>哈夫曼树并不唯一，所以每个字符对应的哈夫曼编码也不唯一（左右子树可以交换），但带权路径长度相同且最优</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title>写给大忙人看的操作系统（转自labuladong）</title>
    <url>/2020/06/09/OS-labuladong/</url>
    <content><![CDATA[<p>以下文章来源于Java建设者 ，作者cxuan</p>
<p><strong>来源公众号：Java建设者</strong></p>
<p><strong>作者：cxuan</strong></p>
<p>文章主要结构图如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5icGrask9qcr1ia4yicuBiasiaSpIQ90bechxr2EqqWBzxC3gyKWcV3XkBEw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5U8YCWSeNkgKSOxna1ibTZLLP3Kg61RX79icPJf1NzTQv8DLmfIrMNticg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>然而，程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p>
<p>我们一般常见的操作系统主要有 <strong>Windows、Linux、FreeBSD 或 OS X</strong> ，这种带有图形界面的操作系统被称为 <code>图形用户界面(Graphical User Interface, GUI)</code>，而基于文本、命令行的通常称为 <code>Shell</code>。下面是我们所要探讨的操作系统的部件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5qxtz1fZXfcQrkMViclryH8H2bichd7gR7LIK5W6xK9eHHYIpO467yf3g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>这是一个操作系统的简化图，最下面的是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中，内核态也称为 <code>管态</code> 和 <code>核心态</code>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p>
<p><code>用户接口程序(shell 或者 GUI)</code>处于用户态中，并且它们位于用户态的最低层，允许用户运行其他程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p>
<h2 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h2><p>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。因此，操作系统因此必须足够了解硬件的运行，这里我们先简要介绍一下现代计算机中的计算机硬件。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL58hXWAFwgrdk2NcFkz4dAdrRYwByNfMLriaUib5DibaH8mZE4mQ23dzx6A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O 设备都和总线串联起来并通过总线与其他设备进行通信。现代操作系统有着更为复杂的结构，会设计很多条总线，我们稍后会看到。暂时来讲，这个模型能够满足我们的讨论。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p>
<p>每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些<code>寄存器</code>来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</p>
<p>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是 <code>程序计数器(program counter)</code>，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。</p>
<p>另一个寄存器是 <code>堆栈指针(stack pointer)</code>，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</p>
<p>还有一个寄存器是 <code>PSW(Program Status Word)</code> 程序状态字寄存器，这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW 在系统调用和 I / O 中起着重要作用。</p>
<p>操作系统必须了解所有的寄存器。在<code>时间多路复用(time multiplexing)</code> 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。</p>
<p>为了提升性能， CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个 CPU 可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2 条指令。像这样的组织形式被称为 <code>流水线(pipeline)。</code></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5wOKI6FQqnpOA6bQIgDicCPK1qM8CUWVBdJjCXJicsvlLlarlaSZOxstA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>比流水线更先进的设计是 <code>超标量(superscalar)</code>CPU，下面是超标量 CPU 的设计</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5FZvibkLLBGCmHT4iboKcwDKPIeHvqoaN4dj4kOuD4uyb1VjCGpn5h9MA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</p>
<p>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有<code>两种模式</code>，即前面已经提到的内核态和用户态。通常情况下，<code>PSW 寄存器</code>中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。</p>
<p>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW 模式的二进制位为内核态也是禁止的。</p>
<p>为了获取操作系统的服务，用户程序必须使用 <code>系统调用(system call)</code>，系统调用会转换为内核态并且调用操作系统。<code>TRAP</code> 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</p>
<p>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等你。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</p>
<h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><p>Intel Pentinum 4也就是奔腾处理器引入了被称为<code>多线程(multithreading)</code> 或 <code>超线程(hyperthreading, Intel 公司的命名)</code> 的特性，x86 处理器和其他一些 CPU 芯片就是这样做的。包括 <strong>SSPARC、Power5、Intel Xeon 和 Intel Core 系列</strong> 。近似地说，多线程允许 CPU 保持两个不同的线程状态并且在<code>纳秒级(nanosecond)</code> 的时间完成切换。线程是一种轻量级的进程，我们会在后面说到。例如，如果一个进程想要从内存中读取指令(这通常会经历几个时钟周期)，多线程 CPU 则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。</p>
<p>对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的 CPU。比如一个有两个 CPU 的操作系统，并且每个 CPU 运行两个线程，那么这对于操作系统来说就可能是 4 个 CPU。</p>
<p>除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5e2aNTKWx1XicytnVbicqicSLhFInoKLlzoJ7aIPPYia0DOX4Jna2R6o6wA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL59Mb6mu885OXTF4SXhVGRWOZpLHeGsuyDfdcTEUiaosTfial3mnAUp92A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>如果要说在绝对核心数量方面，没有什么能赢过现代 <code>GPU(Graphics Processing Unit)</code>，GPU 是指由成千上万个微核组成的处理器。它们擅长处理大量并行的简单计算。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5IZ6jC7hQmMbic0qPlcbibshF9HB2G1C86nibS6IQzyXoznoWTwOoKKh3A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>位于寄存器下面的是<code>高速缓存</code>，它多数由硬件控制。主存被分割成<code>高速缓存行(cache lines)</code> 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是<code>高速缓存命中(cache hit)</code>。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p>
<p>缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。</p>
<blockquote>
<p>“</p>
<p>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 <code>丢失</code>。</p>
</blockquote>
<p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权，缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 <code>/home/ast/projects/minix3/src/kernel/clock.c</code> 这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个 Web 页面(URL) 的地址转换为网络地址(IP地址)后，这个转换结果也可以缓存起来供将来使用。</p>
<p>在任何缓存系统中，都会有下面这几个噬需解决的问题</p>
<ul>
<li>何时把新的内容放进缓存</li>
<li>把新的内容应该放在缓存的哪一行</li>
<li>在需要空闲空间时，应该把哪块内容从缓存中移除</li>
<li>应该把移除的内容放在某个较大存储器的何处</li>
</ul>
<p>并不是每个问题都与每种缓存情况有关。对于 CPU 缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。</p>
<p>缓存是解决问题的一种好的方式，所以现代 CPU 设计了两种缓存。第一级缓存或者说是 <code>L1 cache</code> 总是位于 CPU 内部，<strong>用来将已解码的指令调入 CPU 的执行引擎</strong>。对于那些频繁使用的关键字，多数芯片有第二个 L1 cache 。典型的 L1 cache 的大小为 16 KB。另外，往往还设有二级缓存，也就是 <code>L2 cache</code>，用来存放最近使用过的关键字，一般是兆字节为单位。L1 cache 和 L2 cache 最大的不同在于是否存在延迟。访问 L1 cache 没有任何的延迟，然而访问 L2 cache 会有 1 - 2 个时钟周期的延后。</p>
<blockquote>
<p>“</p>
<p>什么是时钟周期？计算机处理器或 CPU 的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz）或千兆赫（GHz）。例如，一个4 GHz处理器每秒执行4,000,000,000个时钟周期。</p>
<p>计算机处理器可以在每个时钟周期执行一条或多条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的 CPU 在每个时钟周期只能执行一条指令，而现代处理器在每个时钟周期可以执行多条指令。</p>
</blockquote>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>在上面的层次结构中再下一层是<code>主存</code>，这是内存系统的主力军，主存通常叫做 <code>RAM(Random Access Memory)</code>，由于 1950 年代和 1960 年代的计算机使用微小的可磁化铁氧体磁芯作为主存储器，因此旧时有时将其称为核心存储器。所有不能再高速缓存中得到满足的内存访问请求都会转往主存中。</p>
<p>除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。<code>ROM(Read Only Memory)</code> 中的内容一旦存储后就不会再被修改。它非常快而且便宜。（如果有人问你，有没有什么又快又便宜的内存设备，那就是 ROM 了）在计算机中，用于启动计算机的引导加载模块（也就是 bootstrap ）就存放在 ROM 中。另外，一些 I/O 卡也采用 ROM 处理底层设备控制。</p>
<p><code>EEPROM(Electrically Erasable PROM,)</code> 和 <code>闪存(flash memory)</code> 也是非易失性的，但是与 ROM 相反，它们可以擦除和重写。不过重写它们需要比写入 RAM 更多的时间，所以它们的使用方式与 ROM 相同，但是与 ROM 不同的是他们可以通过重写字段来纠正程序中出现的错误。</p>
<p>闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于 RAM 和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。</p>
<p>还有一类是 CMOS，它是易失性的。许多计算机都会使用 CMOS 存储器保持当前时间和日期。</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>下一个层次是<code>磁盘(硬盘)</code>，磁盘同 RAM 相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。磁盘访问慢的原因是因为磁盘的构造不同</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5wmq2mRfJHFbxJCoJW7r2rmENcEYvl1edDv6Q4MUCgowmufYYKgtrkA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，它们以 5400rpm、7200rpm、10800rpm 或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片 33 转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为<code>磁道(track)</code>。把一个给定臂的位置上的所有磁道合并起来，组成了一个<code>柱面(cylinder)</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5JYk79fyC0Mne9cskyLF9Bpc2snsGRoqm9SNP4yKk9r8j8QqZ8fRaMg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>每个磁道划分若干扇区，扇区的值是 512 字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是<code>50MB/s</code>，而高速磁盘的速率是 <code>160MB/s</code>。</p>
<blockquote>
<p>“</p>
<p>需要注意，<code>固态硬盘(Solid State Disk, SSD)</code>不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在<code>存储器（闪存）</code>中，与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p>
</blockquote>
<p>许多计算机支持一种著名的<code>虚拟内存</code>机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。其方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在 RAM 中的物理地址。这种映像由 CPU 中的一个称为 <code>存储器管理单元(Memory Management Unit, MMU)</code> 的部件来完成。</p>
<p><img src="/2020/06/09/OS-labuladong/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>缓存和 MMU 的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为 <code>上下文切换(context switch)</code>，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p>
<h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><p>CPU 和存储器不是操作系统需要管理的全部，<code>I/O</code> 设备也与操作系统关系密切。可以参考上面这个图片，I/O 设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。</p>
<p>在许多情况下，实际控制设备的过程是非常复杂而且存在诸多细节。因此控制器的工作就是为操作系统提供一个更简单（但仍然非常复杂）的接口。也就是屏蔽物理细节。<strong>任何复杂的东西都可以加一层代理来解决，这是计算机或者人类社会很普世的一个解决方案</strong></p>
<p>I/O 设备另一部分是设备本身，设备本身有一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。例如，标准化后任何一个 SATA 磁盘控制器就可以适配任意一种 SATA 磁盘，所以标准化是必要的。<code>ATA</code> 代表 <code>高级技术附件(AT Attachment)</code>，而 SATA 表示<code>串行高级技术附件(Serial ATA)</code>。</p>
<blockquote>
<p>“</p>
<p>AT 是啥？它是 IBM 公司的第二代个人计算机的<code>高级</code>技术成果，使用 1984 年推出的 6MHz 80286 处理器，这个处理器是当时最强大的。</p>
</blockquote>
<p>像是高级这种词汇应该慎用，否则 20 年后再回首很可能会被无情打脸。</p>
<p>现在 SATA 是很多计算机的标准硬盘接口。由于实际的设备接口隐藏在控制器中，所以操作系统看到的是对控制器的接口，这个接口和设备接口有很大区别。</p>
<p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为 <code>设备驱动程序(device driver)</code>。每个控制器厂家都应该针对不同的操作系统提供不同的设备驱动程序。</p>
<p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径</p>
<ul>
<li>第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是 <code>UNIX</code> 系统采用的工作方式</li>
<li>第二个途径是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是 <code>Windows</code> 采用的工作方式</li>
<li>第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如 USB 和 IEEE 1394 都需要动态可装载的设备驱动程序。</li>
</ul>
<p>每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了 <code>I/O 端口空间</code> 。</p>
<p>在一些计算机中，设备寄存器会被映射到操作系统的可用地址空间，使他们能够向内存一样完成读写操作。在这种计算机中，不需要专门的 I/O 指令，用户程序可以被硬件阻挡在外，防止其接触这些存储器地址（例如，采用基址寄存器和变址寄存器）。在另一些计算机中，设备寄存器被放入一个专门的 I/O 端口空间，每个寄存器都有一个端口地址。在这些计算机中，特殊的 <code>IN</code> 和 <code>OUT</code> 指令会在内核态下启用，它能够允许设备驱动程序和寄存器进行读写。前面第一种方式会限制特殊的 I/O 指令但是允许一些地址空间；后者不需要地址空间但是需要特殊的指令，这两种应用都很广泛。</p>
<p><strong>实现输入和输出的方式有三种</strong>。</p>
<ul>
<li>在最简单的方式中，用户程序会发起系统调用，内核会将其转换为相应驱动程序的程序调用，然后设备驱动程序启动 I/O 并循环检查该设备，看该设备是否完成了工作（一般会有一些二进制位用来指示设备仍在忙碌中）。当 I/O 调用完成后，设备驱动程序把数据送到指定的地方并返回。然后操作系统会将控制权交给调用者。这种方式称为 <code>忙等待(busy waiting)</code>，这种方式的缺点是要一直占据 CPU，CPU 会一直轮询 I/O 设备直到 I/O 操作完成。</li>
<li>第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发生中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个 <code>中断</code> 通知操作完成。</li>
</ul>
<p>在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5tHSTJvCfYZAo56ygWChBXicb2aKouc4j8hMrd2hKl5ae9og51NlGcoQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>如上图所示，这是一个三步的 I/O 过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤 2 中使用某些总线向中断控制器发送信号。如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在 CPU 的一个引脚上面声明。这就是步骤3</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL54Fclic0WFzxsDka8PciapQ5IHvjLqswMo38ibjIm95ic60Gk18ElmVJxVw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在第四步中，中断控制器把该设备的编号放在总线上，这样 CPU 可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。</p>
<p>一旦 CPU 决定去实施中断后，程序计数器和 PSW 就会被压入到当前堆栈中并且 CPU 会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作<code>中断向量(interrupt vector)</code>。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和 PSW 寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令，这个过程如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5icyvR90uwjydWjUniahJhYMV5JtiasNj5QJJQrmlcuGV7XL3PVQibGg6FA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ul>
<li>实现 I/O 的第三种方式是使用特殊的硬件：<code>直接存储器访问(Direct Memory Access, DMA)</code> 芯片。它可以控制内存和某些控制器之间的位流，而无需 CPU 的干预。CPU 会对 DMA 芯片进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向。当 DMA 芯片完成后，会造成中断，中断过程就像上面描述的那样。我们会在后面具体讨论中断过程</li>
</ul>
<p>当另一个中断处理程序正在运行时，中断可能（并且经常）发生在不合宜的时间。因此，CPU 可以禁用中断，并且可以在之后重启中断。在 CPU 关闭中断后，任何已经发出中断的设备，可以继续保持其中断信号处理，但是 CPU 不会中断，直至中断再次启用为止。如果在关闭中断时，已经有多个设备发出了中断信号，中断控制器将决定优先处理哪个中断，通常这取决于事先赋予每个设备的优先级，最高优先级的设备优先赢得中断权，其他设备则必须等待。</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>上面的结构（简单个人计算机的组件图）在小型计算机已经使用了多年，并用在早期的 IBM PC 中。然而，随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括 IBM PC 总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理 I/O 设备以及 CPU 到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现。</p>
<p><img src="/2020/06/09/OS-labuladong/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>上图中的 x86 系统包含很多总线，<strong>高速缓存、内存、PCIe、PCI、USB、SATA 和 DMI</strong>，每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是 <code>PCIe(Peripheral Component Interconnect Express)</code> 总线。</p>
<p>Intel 发明的 PCIe 总线也是作为之前古老的 PCI 总线的继承者，而古老的 PCI 总线也是为了取代古董级别的 <code>ISA(Industry Standard Architecture)</code> 总线而设立的。数十 Gb/s 的传输能力使得 PCIe 比它的前身快很多，而且它们本质上也十分不同。直到发明 PCIe 的 2004 年，大多数总线都是并行且共享的。<code>共享总线架构(shared bus architeture)</code> 表示多个设备使用一些相同的电线传输数据。因此，当多个设备同时发送数据时，此时你需要一个决策者来决定谁能够使用总线。而 PCIe 则不一样，它使用专门的端到端链路。传统 PCI 中使用的<code>并行总线架构(parallel bus architecture)</code> 表示通过多条电线发送相同的数据字。例如，在传统的 PCI 总线上，一个 32 位数据通过 32 条并行的电线发送。而 PCIe 则不同，它选用了<code>串行总线架构(serial bus architecture)</code> ，并通过单个连接（称为通道）发送消息中的所有比特数据，就像网络数据包一样。这样做会简化很多，因为不再确保所有 32 位数据在同一时刻准确到达相同的目的地。通过将多个数据通路并行起来，并行性仍可以有效利用。例如，可以使用 32 条数据通道并行传输 32 条消息。</p>
<p>在上图结构中，CPU 通过 DDR3 总线与内存对话，通过 PCIe 总线与外围图形设备 （GPU）对话，通过 <code>DMI(Direct Media Interface)</code>总线经集成中心与所有其他设备对话。而集成控制中心通过串行总线与 USB 设备对话，通过 SATA 总线与硬盘和 DVD 驱动器对话，通过 PCIe 传输以太网络帧。</p>
<p>不仅如此，每一个核</p>
<p><code>USB(Univversal Serial Bus)</code> 是用来将所有慢速 I/O 设备（比如键盘和鼠标）与计算机相连的设备。USB 1.0 可以处理总计 12 Mb/s 的负载，而 USB 2.0 将总线速度提高到 480Mb/s ，而 USB 3.0 能达到不小于 5Gb/s 的速率。所有的 USB 设备都可以直接连接到计算机并能够立刻开始工作，而不像之前那样要求重启计算机。</p>
<p><code>SCSI(Small Computer System Interface)</code> 总线是一种高速总线，用在高速硬盘，扫描仪和其他需要较大带宽的设备上。现在，它们主要用在服务器和工作站中，速度可以达到 640MB/s 。</p>
<h3 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h3><p>那么有了上面一些硬件再加上操作系统的支持，我们的计算机就可以开始工作了，那么计算机的启动过程是怎样的呢？下面只是一个简要版的启动过程</p>
<p>在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有 BIOS 芯片、I/O 控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。</p>
<p>在母板上有一个称为 <code>基本输入输出系统(Basic Input Output System, BIOS)</code>的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、磁盘I/O 以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS 中发现错误时，可以由操作系统进行更新。</p>
<p>在计算机<code>启动(booted)</code>时，BIOS 开启，它会首先检查所安装的 RAM 的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被重新配置。</p>
<p>蓝后，BIOS 通过尝试存储在 <code>CMOS</code> 存储器中的设备清单尝试启动设备</p>
<blockquote>
<p>“</p>
<p>CMOS是 <code>Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）</code>的缩写。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的 <code>RAM</code> 芯片。因为可读写的特性，所以在电脑主板上用来保存 BIOS 设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p>
<p>而对 BIOS 中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入 BIOS 设置程序，方便地对系统进行设置。因此 BIOS 设置有时也被叫做 CMOS 设置。</p>
</blockquote>
<p>用户可以在系统启动后进入一个 BIOS 配置程序，对设备清单进行修改。然后，判断是否能够从外部 <code>CD-ROM</code> 和 USB 驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。</p>
<p>然后操作系统会询问 BIOS 获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入 <code>CD-ROM</code> 驱动（由设备制造商提供）或者从 Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。</p>
<h2 id="操作系统博物馆"><a href="#操作系统博物馆" class="headerlink" title="操作系统博物馆"></a>操作系统博物馆</h2><p>操作系统已经存在了大半个世纪，在这段时期内，出现了各种类型的操作系统，但并不是所有的操作系统都很出名，下面就罗列一些比较出名的操作系统</p>
<h3 id="大型机操作系统"><a href="#大型机操作系统" class="headerlink" title="大型机操作系统"></a>大型机操作系统</h3><p>高端一些的操作系统是大型机操作系统，这些大型操作系统可在大型公司的数据中心找到。这些计算机的 I/O 容量与个人计算机不同。一个大型计算机有 1000 个磁盘和数百万 G 字节的容量是很正常，如果有这样一台个人计算机朋友会很羡慕。大型机也在高端 Web 服务器、大型电子商务服务站点上。</p>
<h3 id="服务器操作系统"><a href="#服务器操作系统" class="headerlink" title="服务器操作系统"></a>服务器操作系统</h3><p>下一个层次是服务器操作系统。它们运行在服务器上，服务器可以是大型个人计算机、工作站甚至是大型机。它们通过网络为若干用户服务，并且允许用户共享硬件和软件资源。服务器可提供打印服务、文件服务或 Web 服务。Internet 服务商运行着许多台服务器机器，为用户提供支持，使 Web 站点保存 Web 页面并处理进来的请求。典型的服务器操作系统有 Solaris、FreeBSD、Linux 和 Windows Server 201x</p>
<h3 id="多处理器操作系统"><a href="#多处理器操作系统" class="headerlink" title="多处理器操作系统"></a>多处理器操作系统</h3><p>获得大型计算能力的一种越来越普遍的方式是将多个 CPU 连接到一个系统中。依据它们连接方式和共享方式的不同，这些系统称为并行计算机，多计算机或多处理器。他们需要专门的操作系统，不过通常采用的操作系统是配有通信、连接和一致性等专门功能的服务器操作系统的变体。</p>
<p>个人计算机中近来出现了多核芯片，所以常规的台式机和笔记本电脑操作系统也开始与小规模多处理器打交道，而核的数量正在与时俱进。许多主流操作系统比如 Windows 和 Linux 都可以运行在多核处理器上。</p>
<h3 id="个人计算机系统"><a href="#个人计算机系统" class="headerlink" title="个人计算机系统"></a>个人计算机系统</h3><p>接下来一类是个人计算机操作系统。现代个人计算机操作系统支持多道处理程序。在启动时，通常有几十个程序开始运行，它们的功能是为单个用户提供良好的支持。这类系统广泛用于字处理、电子表格、游戏和 Internet 访问。常见的例子是 Linux、FreeBSD、Windows 7、Windows 8 和苹果公司的 OS X 。</p>
<h3 id="掌上计算机操作系统"><a href="#掌上计算机操作系统" class="headerlink" title="掌上计算机操作系统"></a>掌上计算机操作系统</h3><p>随着硬件越来越小化，我们看到了平板电脑、智能手机和其他掌上计算机系统。掌上计算机或者 <code>PDA(Personal Digital Assistant)，个人数字助理</code> 是一种可以握在手中操作的小型计算机。这部分市场已经被谷歌的 <code>Android</code> 系统和苹果的 <code>IOS</code>主导。</p>
<h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统用来控制设备的计算机中运行，这种设备不是一般意义上的计算机，并且不允许用户安装软件。典型的例子有微波炉、汽车、DVD 刻录机、移动电话以及 MP3 播放器一类的设备。所有的软件都运行在 ROM 中，这意味着应用程序之间不存在保护，从而获得某种简化。主要的嵌入式系统有 Linux、QNX 和 VxWorks</p>
<h3 id="传感器节点操作系统"><a href="#传感器节点操作系统" class="headerlink" title="传感器节点操作系统"></a>传感器节点操作系统</h3><p>有许多用途需要配置微小传感器节点网络。这些节点是一种可以彼此通信并且使用无线通信基站的微型计算机。这类传感器网络可以用于建筑物周边保护、国土边界保卫、森林火灾探测、气象预测用的温度和降水测量等。</p>
<p>每个传感器节点是一个配有 CPU、RAM、ROM 以及一个或多个环境传感器的实实在在的计算机。节点上运行一个小型但是真是的操作系统，通常这个操作系统是事件驱动的，可以响应外部事件。</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>另一类操作系统是实时操作系统，这些系统的特征是将时间作为关键参数。例如，在工业过程控制系统中，工厂中的实时计算机必须收集生产过程的数据并用有关数据控制机器。如果某个动作必须要在规定的时刻发生，这就是<code>硬实时系统</code>。可以在工业控制、民用航空、军事以及类似应用中看到很多这样的系统。另一类系统是 <code>软实时系统</code>，在这种系统中，虽然不希望偶尔违反最终时限，但仍可以接受，并不会引起任何永久性损害。数字音频或多媒体系统就是这类系统。智能手机也是软实时系统。</p>
<h3 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h3><p>最小的操作系统运行在智能卡上。智能卡是一种包含一块 CPU 芯片的信用卡。它有非常严格的运行能耗和存储空间的限制。有些卡具有单项功能，如电子支付；有些智能卡是面向 Java 的。这意味着在智能卡的 ROM 中有一个 Java 虚拟机（Java Virtual Machine, JVM）解释器。</p>
<h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从 <code>UNIX</code> 中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统一个很关键的概念就是 <code>进程(Process)</code>。进程的本质就是操作系统执行的一个程序。与每个进程相关的是<code>地址空间(address space)</code>，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括<code>寄存器(registers)</code>（寄存器一般包括<code>程序计数器(program counter)</code>和<code>堆栈指针(stack pointer)</code>）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。</p>
<p>对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web 浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了 CPU 分配的时间片，而 CPU 转而运行另外的程序。</p>
<p>像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。<strong>这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的</strong>。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的 <code>read</code>调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为 <code>进程表(process table)</code>，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。</p>
<p>所以，一个挂起的进程包括：进程的地址空间（往往称作<code>磁芯映像</code>， core image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。</p>
<p>与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为 <code>命令解释器(command interpreter)</code> 或 <code>shell</code> 的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell 必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。</p>
<p>如果一个进程能够创建一个或多个进程（称为<code>子进程</code>），而且这些进程又可以创建子进程，则很容易找到进程数，如下所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5Ziagj2xBia3oNeoqCEK9hiaxkpiaI5qx1uDWe0QpgVjeoLyZ2Lj7AQb2MA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>上图表示一个进程树的示意图，进程 A 创建了两个子进程 B 和进程 C，子进程 B 又创建了三个子进程 D、E、F。</p>
<p>合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为<code>进程间通信(interprocess communication)</code>。我们在后面会探讨进程间通信。</p>
<p>其他可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存），等待一个子进程结束，用另一个程序覆盖该程序。</p>
<p>有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。</p>
<p>在限定的时间到达后，操作系统会向进程发送一个 <code>警告信号(alarm signal)</code>。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。</p>
<p>系统管理器授权每个进程使用一个给定的 <code>UID(User IDentification)</code>。每个启动的进程都会有一个操作系统赋予的 UID，子进程拥有与父进程一样的 UID。用户可以是某个组的成员，每个组也有一个 <code>GID(Group IDentification)</code>。</p>
<p>在 UNIX 操作系统中，有一个 UID 是 <code>超级用户(superuser)</code>，或者 Windows 中的<code>管理员(administrator)</code>，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。</p>
<p>复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。</p>
<p>上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p>
<p>但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64 字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种<code>虚拟内存</code>的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他 I/O 设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。<strong>创建文件、删除文件、读文件和写文件</strong> 都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。</p>
<p>为了提供保存文件的地方，大多数个人计算机操作系统都有<code>目录(directory)</code> 的概念，从而可以把文件分组。比如，学生可以给每个课程都创建一个目录，用于保存该学科的资源，另一个目录可以存放电子邮件，再有一个目录可以存放万维网主页。这就需要系统调用创建和删除目录、将已有文件放入目录中，从目录中删除文件等。目录项可以是文件或者目录，目录和目录之间也可以嵌套，这样就产生了文件系统</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL505NvNm4B03kDvKHaYLmJibNgaIVbyVqgb19Ykrhg3jUNvicqY3ZORhtQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。</p>
<p>目录层结构中的每一个文件都可以通过从目录的顶部即 <code>根目录(Root directory)</code> 开始的<code>路径名(path name)</code> 来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用斜杠分隔符分开，在上面的大学院系文件系统中，文件 CS101 的路径名是 <code>/Faculty/Prof.Brown/Courses/CS101</code>。最开始的斜杠分隔符代表的是<code>根目录 /</code>，也就是文件系统的绝对路径。</p>
<blockquote>
<p>“</p>
<p>出于历史原因，Windows 下面的文件系统以 <code>\</code> 来作为分隔符，但是 Linux 会以 <code>/</code> 作为分隔符。</p>
</blockquote>
<p>在上面的系统中，每个进程会有一个 <code>工作目录(working directory)</code>，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。如果 <code>/Faculty/Prof.Brown</code> 是工作目录，那么 <code>/Courses/CS101</code> 与上面给定的绝对路径名表示的是同一个文件。进程可以通过使用系统调用指定新的工作目录，从而变更其工作目录。</p>
<p>在读写文件之前，首先需要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作<code>文件描述符(file descriptor)</code>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p>
<p>在 UNIX 中，另一个重要的概念是 <code>特殊文件(special file)</code>。提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是<code>块儿特殊文件(block special file)</code> 和 <code>字符特殊文件(character special file)</code>。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调起和其他接受或输出字符流的设备。按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如，/devv/lp 是打印机。</p>
<p>还有一种与进程和文件相关的特性是管道，<code>管道(pipe)</code> 是一种虚文件，他可以连接两个进程</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL53CtFrbyZBRibaB7L1aTrAa0l7jqEpmlsscg5odGtSUsib7XByl9OjBWQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程 B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>计算机中含有大量的信息，用户希望能够对这些信息中有用而且重要的信息加以保护，这些信息包括电子邮件、商业计划等，管理这些信息的安全性完全依靠操作系统来保证。例如，文件提供授权用户访问。</p>
<p>比如 UNIX 操作系统，UNIX 操作系统通过对每个文件赋予一个 9 位二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个位子段，一个用于所有者，一个用于与所有者同组（用户被系统管理员划分成组）的其他成员，一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是著名的 <code>rwx位</code>。例如，保护代码 <code>rwxr-x--x</code> 的含义是所有者可以读、写或执行该文件，其他的组成员可以读或执行（但不能写）此文件、而其他人可以执行（但不能读和写）该文件。</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>操作系统是执行系统调用的代码。编辑器、编译器、汇编程序、链接程序、使用程序以及命令解释符等，尽管非常重要，非常有用，但是它们确实不是操作系统的组成部分。下面我们着重介绍一下 UNIX 下的命令提示符，也就是 <code>shell</code>，shell 虽然有用，但它也不是操作系统的一部分，然而它却能很好的说明操作系统很多特性，下面我们就来探讨一下。</p>
<p>shell 有许多种，例如 <strong>sh、csh、ksh 以及 bash</strong>等，它们都支持下面这些功能，最早起的 shell 可以追溯到 sh</p>
<p>用户登录时，会同时启动一个 shell，它以终端作为标准输入和标准输出。首先显示<code>提示符(prompt)</code>，它可能是一个<code>美元符号($)</code>，提示用户 shell 正在等待接收命令，假如用户输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>shell 会创建一个子进程，并运行 date 做为子进程。在该子进程运行期间，shell 将等待它结束。在子进程完成时，shell 会显示提示符并等待下一行输入。</p>
<p>用户可以将标准输出重定向到一个文件中，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date &gt; file</span><br></pre></td></tr></table></figure>
<p>同样的，也可以将标准输入作为重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort &lt;file1&gt; file2</span><br></pre></td></tr></table></figure>
<p>这会调用 sort 程序来接收 file1 的内容并把结果输出到 file2。</p>
<p>可以将一个应用程序的输出通过管道作为另一个程序的输入，因此有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file1 file2 file3 | sort &gt; &#x2F;dev&#x2F;lp</span><br></pre></td></tr></table></figure>
<p>这会调用 cat 应用程序来合并三个文件，将其结果输送到 sort 程序中并按照字典进行排序。sort 应用程序又被重定向到 /dev/lp ，显然这是一个打印操作。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。</p>
<p>多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。<strong>任何单 CPU 计算机一次执行执行一条指令</strong>。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。操作系统紧接着进行参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有<strong>系统调用能够进入内核态而过程调用则不能进入内核态</strong>。</p>
<p>为了能够了解具体的调用过程，下面我们以 <code>read</code> 方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; read(fd,buffer,nbytes);</span><br></pre></td></tr></table></figure>
<p>系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes 相同，但也可能更小。比如在读过程中遇到了文件尾的情况。</p>
<p>如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count 的值都会被置成 -1，然后在全局变量 <code>errno</code> 中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。</p>
<p>系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以 read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5icGqONTpl5fEhWM5iajDD6xZNUV6xzkHicCQceUz5oY2Is5n2rOibicam8w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>C 和 C++ 编译器使用逆序（必须把第一个参数赋值给 printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由 &amp; 指示），而不是缓冲的内容。然后是 C 调用系统库的 read 函数，这也是第四步。</p>
<p>在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个 <code>TRAP</code> 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP 指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p>
<p>TRAP 指令与过程调用指令存在两个方面的不同</p>
<ul>
<li>TRAP 指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式</li>
<li>其次，TRAP 指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一 8 位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。</li>
</ul>
<p>跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后<code>dispatch</code>给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据 TRAP 指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加<code>堆栈指针(increment stackpointer)</code>，用来清除调用 read 之前压入的参数。从而完成整个 read 调用过程。</p>
<p>在上面的第九步中我们说道，控制可能返回 TRAP 指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入 时候，进程会提醒操作系统，然后返回第 9 步继续运行。</p>
<p>下面，我们会列出一些常用的 <code>POSIX</code> 系统调用，POSIX 系统调用大概有 100 多个，它们之中最重要的一些调用见下表</p>
<p><strong>进程管理</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">调用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pid = fork()</td>
<td style="text-align:left">创建与父进程相同的子进程</td>
</tr>
<tr>
<td style="text-align:left">pid = waitpid(pid, &amp;statloc,options)</td>
<td style="text-align:left">等待一个子进程终止</td>
</tr>
<tr>
<td style="text-align:left">s = execve(name,argv,environp)</td>
<td style="text-align:left">替换一个进程的核心映像</td>
</tr>
<tr>
<td style="text-align:left">exit(status)</td>
<td style="text-align:left">终止进程执行并返回状态</td>
</tr>
</tbody>
</table>
</div>
<p><strong>文件管理</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">调用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fd = open(file, how,…)</td>
<td style="text-align:left">打开一个文件使用读、写</td>
</tr>
<tr>
<td style="text-align:left">s = close(fd)</td>
<td style="text-align:left">关闭一个打开的文件</td>
</tr>
<tr>
<td style="text-align:left">n = read(fd,buffer,nbytes)</td>
<td style="text-align:left">把数据从一个文件读到缓冲区中</td>
</tr>
<tr>
<td style="text-align:left">n = write(fd,buffer,nbytes)</td>
<td style="text-align:left">把数据从缓冲区写到一个文件中</td>
</tr>
<tr>
<td style="text-align:left">position = iseek(fd,offset,whence)</td>
<td style="text-align:left">移动文件指针</td>
</tr>
<tr>
<td style="text-align:left">s = stat(name,&amp;buf)</td>
<td style="text-align:left">取得文件状态信息</td>
</tr>
</tbody>
</table>
</div>
<p><strong>目录和文件系统管理</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">调用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">s = mkdir(nname,mode)</td>
<td style="text-align:left">创建一个新目录</td>
</tr>
<tr>
<td style="text-align:left">s = rmdir(name)</td>
<td style="text-align:left">删去一个空目录</td>
</tr>
<tr>
<td style="text-align:left">s = link(name1,name2)</td>
<td style="text-align:left">创建一个新目录项 name2,并指向 name1</td>
</tr>
<tr>
<td style="text-align:left">s = unlink(name)</td>
<td style="text-align:left">删去一个目录项</td>
</tr>
<tr>
<td style="text-align:left">s = mount(special,name,flag)</td>
<td style="text-align:left">安装一个文件系统</td>
</tr>
<tr>
<td style="text-align:left">s = umount(special)</td>
<td style="text-align:left">卸载一个文件系统</td>
</tr>
</tbody>
</table>
</div>
<p><strong>其他</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">调用</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">s = chdir(dirname)</td>
<td style="text-align:left">改变工作目录</td>
</tr>
<tr>
<td style="text-align:left">s = chmod(name,mode)</td>
<td style="text-align:left">修改一个文件的保护位</td>
</tr>
<tr>
<td style="text-align:left">s = kill(pid, signal)</td>
<td style="text-align:left">发送信号给进程</td>
</tr>
<tr>
<td style="text-align:left">seconds = time(&amp;seconds)</td>
<td style="text-align:left">获取从 1970 年1月1日至今的时间</td>
</tr>
</tbody>
</table>
</div>
<p>上面的系统调用参数中有一些公共部分，例如 pid 系统进程 id，fd 是文件描述符，n 是字节数，position 是在文件中的偏移量、seconds 是流逝时间。</p>
<p>从宏观角度上看，这些系统调所提供的服务确定了多数操作系统应该具有的功能，下面分别来对不同的系统调用进行解释</p>
<h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><p>在 UNIX 中，<code>fork</code> 是唯一可以在 POSIX 中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在 fork 之后，原有进程以及副本（父与子）就分开了。在 fork 过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 <code>进程标识符(Process IDentified,PID)</code>。使用返回的 PID，就可以看出来哪个是父进程和子进程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5X4ONhEjC5vLusxY83ZTjHjMfde3RLEYfDpKJLG3YxqH71CQeRibDJmA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在多数情况下， 在 fork 之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行 <code>waitpid</code> 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数 <code>statloc</code> 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。</p>
<p>那么 shell 该如何使用 fork 呢？在键入一条命令后，shell 会调用 fork 命令创建一个新的进程。这个子进程会执行用户的指令。通过使用 <code>execve</code> 系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明 fork、waitpid 和 execve 的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define TRUE 1</span><br><span class="line"></span><br><span class="line">&#x2F;* 一直循环下去 *&#x2F;</span><br><span class="line">while(TRUE)&#123;			</span><br><span class="line"></span><br><span class="line">&#x2F;* 在屏幕上显示提示符 *&#x2F;</span><br><span class="line">	type_prompt();			</span><br><span class="line">  </span><br><span class="line">  &#x2F;* 从终端读取输入 *&#x2F;</span><br><span class="line">	read_command(command,parameters)		</span><br><span class="line">  </span><br><span class="line">  &#x2F;* fork 子进程 *&#x2F;</span><br><span class="line">	if(fork() !&#x3D; 0)&#123;								</span><br><span class="line">  </span><br><span class="line">		&#x2F;* 父代码 *&#x2F;</span><br><span class="line">		&#x2F;* 等待子进程执行完毕 *&#x2F;</span><br><span class="line">		waitpid(-1, &amp;status, 0);								</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	</span><br><span class="line">		&#x2F;* 执行命令 *&#x2F;</span><br><span class="line">		&#x2F;* 子代码 *&#x2F;</span><br><span class="line">		execve(command,parameters,0)					</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，execve 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。</p>
<p>先看一个 shell 指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>
<p>此命令把 file1 复制到 file2 文件中，在 shell 执行 fork 之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。</p>
<p>cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main(argc,argv,envp)</span><br></pre></td></tr></table></figure>
<p>其中 argc 是命令行中参数数目的计数，包括程序名称。对于上面的例子，<code>argc</code> 是3。第二个参数<code>argv</code> 是数组的指针。该数组的元素 i 是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三个参数是指向环境的指针，该环境是一个数组，含有 <code>name = value</code> 的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给 execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。</p>
<p>可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX 的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下 <code>exit</code> ，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是 0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。</p>
<p>UNIX 中的进程将内存划分成三个部分：<code>text segment,文本区</code>，例如程序代码，<code>data segment，数据区</code>，例如变量，<code>stack segment</code>，栈区域。数据向上增长而堆栈向下增长，如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5du6GBHny15X7Tdj8ia1ZA1WdBJoRYXTiafhuOA6LklRO3reQ5E5RBzIA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用 <code>brk</code> 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是 POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 <code>malloc</code> 函数，而 malloc 的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。</p>
<h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><p>许多系统调用都与文件系统有关，要读写一个文件，必须先将其打开。这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称，而代码 <code>O_RDONLY</code>、 <code>O_WRONLY</code> 或 <code>O_RDWR</code> 的含义分别是只读、只写或者两者都可以，为了创建一个新文件，使用 <code>O_CREATE</code> 参数。然后可使用返回的文件描述符进行读写操作。接着，可以使用 close 关闭文件，这个调用使得文件描述符在后续的 open 中被再次使用。</p>
<p>最常用的调用还是 <code>read</code> 和 <code>write</code>，我们再前面探讨过 read 调用，write 具有与 read 相同的参数。</p>
<p>尽管多数程序频繁的读写文件，但是仍有一些应用程序需要能够随机访问一个文件的任意部分。与每个文件相关的是一个指向文件当前位置的指针。在顺序读写时，该指针通常指向要读出（写入）的下一个字节。<code>Iseek</code> 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p>
<p>Iseek 有三个参数，<code>position = iseek(fd,offset,whence)</code>，第一个是文件描述符，第二个是文件位置，第三个是说明该文件位置是相对于文件起始位置，当前位置还是文件的结尾。在修改了指针之后，Iseek 所返回的值是文件中的绝对位置。</p>
<p>UNIX 为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小，最后修改时间以及其他信息，程序可以通过 <code>stat</code> 系统调用查看这些信息。<code>s = stat(name,&amp;buf)</code>，第一个参数指定了被检查的文件；第二个参数是一个指针，该指针指向存放这些信息的结构。对于一个打开的文件而言，fstat 调用完成同样的工作。</p>
<h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><p>下面我们探讨目录和整个文件系统的系统调用，上面探讨的是和某个文件有关的系统调用。<code>mkdir</code> 和 <code>rmdir</code> 分别用于创建<code>s = mkdir(nname,mode)</code> 和删除 <code>s = rmdir(name)</code> 空目录，下一个调用是 <code>s = link(name1,name2)</code> 它的作用是允许同一个文件以两个或者多个名称出现，多数情况下是在不同的目录中使用 link ，下面我们探讨一下 link 是如何工作的</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5IkxIiavl4LUJSdic8BID3xZiaCqL2tpGD0F3iatNwmSOlJ6aLZevSYdVUA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>图中有两个用户 <code>ast</code> 和 <code>jim</code>，每个用户都有他自己的一个目录和一些文件，如果 ast 要执行一个包含下面系统调用的应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link(&quot;&#x2F;usr&#x2F;jim&#x2F;memo&quot;, &quot;&#x2F;usr&#x2F;ast&#x2F;note&quot;);</span><br></pre></td></tr></table></figure>
<p>jim 中的 memo 文件现在会进入到 ast 的目录中，在 note 名称下。此后，<code>/usr/jim/memo</code>和 <code>/usr/ast/note</code> 会有相同的名称。</p>
<blockquote>
<p>“</p>
<p>用户目录是保存在 /usr，/user，/home 还是其他位置，都是由本地系统管理员决定的。</p>
</blockquote>
<p>要理解 link 是如何工作的需要清楚 link 做了什么操作。UNIX 中的每个文件都有一个独一无二的版本，也称作 <code>i - number，i-编号</code>，它标示着不同文件的版本。这个 i - 编号是 <code>i-nodes,i-节点</code> 表的索引。每个文件都会表明谁拥有这个文件，这个磁盘块的位置在哪，等等。目录只是一个包含一组（i编号，ASCII名称）对应的文件。UNIX 中的第一个版本中，每个目录项都会有 16 个字节，2 个字节对应 i - 编号和 14 个字节对应其名称。现在需要一个更复杂的结构需要支持长文件名，但是从概念上讲一个目录仍是一系列（i-编号，ASCII 名称）的集合。在上图中，<code>mail</code> 的 i-编号为 16，依此类推。link 只是利用某个已有文件的 i-编号，创建一个新目录项（也许用一个新名称）。在上图 b 中，你会发现有两个相同的 70 i-编号的文件，因此它们需要有相同的文件。如果其中一个使用了 <code>unlink</code> 系统调用的话，其中一个会被移除，另一个将保留。如果两个文件都移除了，则 UNIX 会发现该文件不存在任何没有目录项（i-节点中的一个域记录着指向该文件的目录项），就会把该文件从磁盘中移除。</p>
<p>就像我们上面提到过的那样，<code>mount</code> 系统 <code>s = mount(special,name,flag)</code> 调用会将两个文件系统合并为一个。通常的情况是将根文件系统分布在硬盘（子）分区上，并将用户文件分布在另一个（子）分区上，该根文件系统包含常用命令的二进制（可执行）版本和其他使用频繁的文件。然后，用户就会插入可读取的 USB 硬盘。</p>
<p>通过执行 mount 系统调用，USB 文件系统可以被添加到根文件系统中，</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL52SzCznrtBqBMIOAHM8SINRuAbrC91coDQGFohOPC3o2PuniauxnFZPQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>如果用 C 语言来执行那就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount(&quot;&#x2F;dev&#x2F;sdb0&quot;,&quot;&#x2F;mnt&quot;,0)</span><br></pre></td></tr></table></figure>
<p>这里，第一个参数是 USB 驱动器 0 的块特殊文件名称，第二个参数是被安装在树中的位置，第三个参数说明将要安装的文件系统是可读写的还是只读的。</p>
<p>当不再需要一个文件系统时，可以使用 umount 移除之。</p>
<h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><p>除了进程、文件、目录系统调用，也存在其他系统调用的情况，下面我们来探讨一下。我们可以看到上面其他系统调用只有四种，首先来看第一个 chdir，chdir 调用更改当前工作目录，在调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chdir(&quot;&#x2F;usr&#x2F;ast&#x2F;test&quot;);</span><br></pre></td></tr></table></figure>
<p>后，打开 xyz 文件，会打开 <code>/usr/ast/test/xyz</code> 文件，工作目录的概念消除了总是需要输入长文件名的需要。</p>
<p>在 UNIX 系统中，每个文件都会有保护模式，这个模式会有一个<code>读-写-执行</code>位，它用来区分所有者、组和其他成员。<code>chmod</code> 系统调用提供改变文件模式的操作。例如，要使一个文件除了对所有者之外的用户可读，你可以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod(&quot;file&quot;,0644);</span><br></pre></td></tr></table></figure>
<p><code>kill</code> 系统调用是用户和用户进程发送信号的方式，如果一个进程准备好捕捉一个特定的信号，那么在信号捕捉之前，会运行一个信号处理程序。如果进程没有准备好捕捉特定的信号，那么信号的到来会杀掉该进程（此名字的由来）。</p>
<p>POSIX 定义了若干时间处理的进程。例如，<code>time</code> 以秒为单位返回当前时间，0 对应着 1970 年 1月 1日。在一台 32 位字的计算机中，time 的最大值是 (2^32) - 1秒，这个数字对应 136 年多一点。所以在 2106 年，32 位的 UNIX 系统会发飙。如果读者现在有 32 位 UNIX 系统，建议在 2106 年更换位 64 位操作系统（偷笑～）。</p>
<h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>上面我们提到的都是 UNIX 系统调用，现在我们来聊聊 Win 32 中的系统调用。Windows 和 UNIX 在各自的编程方式上有着根本的不同。UNIX 程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。Windows 系统则不同，Windows 应用程序通常是由事件驱动的。主程序会等待一些事件发生，然后调用程序去处理。最简单的事件处理是键盘敲击和鼠标滑过，或者是鼠标点击，或者是插入 USB 驱动，然后操作系统调用处理器去处理事件，更新屏幕和更新程序内部状态。这是与 UNIX 不同的设计风格。</p>
<p>当然，Windows 也有系统调用。在 UNIX 中，系统调用（比如 read）和系统调用所使用的调用库（例如 read）几乎是一对一的关系。而在 Windows 中，情况则大不相同。首先，函数库的调用和实际的系统调用几乎是不对应的。微软定义了一系列过程，称为 <code>Win32应用编程接口(Application Programming Interface)</code>，程序员通过这套标准的接口来实现系统调用。这个接口支持从 Windows 95 版本以来所有的 Windows 版本。</p>
<p>Win32 API 调用的数量是非常巨大的，有数千个多。但这些调用并不都是在内核态的模式下运行时，有一些是在用户态的模型下运行。Win32 API 有大量的调用，用来管理视窗、几何图形、文本、字体、滚动条、对话框、菜单以及 GUI 的其他功能。为了使图形子系统在内核态下运行，需要系统调用，否则就只有函数库调用。</p>
<p>我们把关注点放在和 Win32 系统调用中来，我们可以简单看一下 Win32 API 中的系统调用和 UNIX 中有什么不同（并不是所有的系统调用）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5Snbj3YdicaWu9ibdW3AZWvBeSHFas5XbhtTUwXupFXqdaJzrtCN61OBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>上表中是 UNIX 调用大致对应的 Win32 API 系统调用，简述一下上表。<code>CreateProcess</code> 用于创建一个新进程，它把 UNIX 中的 fork 和 execve 两个指令合成一个，一起执行。它有许多参数用来指定新创建进程的性质。Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。<code>WaitForSingleObject</code> 用于等待一个事件，等待的事件可以是多种可能的事件。如果有参数指定了某个进程，那么调用者将等待指定的进程退出，这通过 <code>ExitProcess</code> 来完成。</p>
<p>然后是6个文件操作，在功能上和 UNIX 的调用类似，然而在参数和细节上是不同的。和 UNIX 中一样，文件可以打开，读取，写入，关闭。<code>SetFilePointer</code> 和 <code>GetFileAttributesEx</code> 设置文件的位置并取得文件的属性。</p>
<p>Windows 中有目录，目录分别用 <code>CreateDirectory</code> 以及 <code>RemoveDirectory</code> API 调用创建和删除。也有对当前的目录的标记，这可以通过 <code>SetCurrentDirectory</code> 来设置。使用<code>GetLocalTime</code> 可获得当前时间。</p>
<p>Win32 接口中没有文件的链接、文件系统的 mount、umount 和 stat ，当然， Win32 中也有大量 UNIX 中没有的系统调用，特别是对 GUI 的管理和调用。</p>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>下面我们会探讨操作系统的几种结构，主要包括<strong>单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核</strong>等。下面以此来探讨一下</p>
<h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序。使用此技术时，如果系统中的每个过程都提供了前者所需的一些有用的计算，则它可以自由调用任何其他过程。在单体系统中，调用任何一个所需要的程序都非常高效，但是上千个不受限制的彼此调用往往非常臃肿和笨拙，而且单体系统必然存在单体问题，那就是只要系统发生故障，那么任何系统和应用程序将不可用，这往往是灾难性的。</p>
<p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p>
<p>对于单体系统，往往有下面几种建议</p>
<ul>
<li>需要有一个主程序，用来调用请求服务程序</li>
<li>需要一套服务过程，用来执行系统调用</li>
<li>需要一套服务程序，用来辅助服务过程调用</li>
</ul>
<p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5vM3QrmGhvukttVlbaMVApxgnesBic6mzOYRh501T5wYickcY4QGqzbaQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p>
<h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5nByKXFGaCSuQWoy2PH4ZQsbS7KwToxmMYppFN2rxicNic2lDgdSyQxOQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>分层系统是由 <code>E.W.Dijkstar</code> 和他的学生在荷兰技术学院所开发的 THE 系统。</p>
<p>把上面单体系统进一步通用化，就变为了一个层次式结构的操作系统，它的上层软件都是在下层软件的基础之上构建的。该系统分为六层，如下所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">层号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">操作员</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">用户程序</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">输入/输出管理</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">操作员-进程通信</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">存储器和磁鼓管理</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">处理器分配和多道程序编程</td>
</tr>
</tbody>
</table>
</div>
<p>处理器在 0 层运行，当中断发生或定时器到期时，由该层完成进程切换；在第 0 层之上，系统由一些连续的进程组成，编写这些进程时不用再考虑在单处理器上多进程运行的细节。内存管理在第 1 层，它分配进程的主存空间。第 1 层软件保证一旦需要访问某一页面，该页面必定已经在内存中，并且在页面不需要的时候将其移出。</p>
<p>第 2 层处理进程与操作员控制台（即用户）之间的通信。第 3 层管理 I/O 设备和相关的信息流缓冲区。第 4 层是用户程序层，用户程序不用考虑进程、内存、控制台或 I/O 设备管理等细节。系统操作员在第 5 层。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>在分层方式中，设计者要确定在哪里划分 <code>内核-用户</code> 的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。</p>
<p>所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 —- 微内核 —- 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p>
<p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5t14HcyUzW43xqOicx9cYAhT4IUyVKmibWZ96WCl36TI3Q9KpaQfq4pfQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p>
<p>位于用户态的驱动程序上面是<code>服务器</code>层，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程。服务器中有一个特殊的服务器称为 <code>再生服务器(reincarnation server)</code>，它的任务就是检查服务器和驱动程序的功能是否正确，一旦检查出来错误，它就会补上去，无需用户干预。这种方式使得系统具有可恢复性，并具有较高的可靠性。</p>
<p>微内核中的内核还具有一种 <code>机制</code> 与 <code>策略</code> 分离的思想。比如系统调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。这里，内核机制就是寻找最高的优先级进程并运行。而策略（赋予进程优先级）可以在用户态中的进程完成。在这种模式中，策略和机制是分离的，从而使内核变得更小。</p>
<h3 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p>
<p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdWiaexJhvU13C7OJUrpibcRL5gDoUrC9XjibE73Hyia6a7icmH1L4oWPSibb58IRjVLmKHhT8UvxMaCkFvg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p>
<p>越来越多的系统，包括家里的 PC，都成为客户端，而在某地运行的大型机器则成为服务器。许多 web 就是以这种方式运行的。一台 PC 向某个服务器请求一个 Web 页面，服务器把 Web 页面返回给客户端，这就是典型的客服-服务器模式</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong的算法小抄——（一）</title>
    <url>/2020/06/09/Algorithm-01/</url>
    <content><![CDATA[<p>最近发现一个很棒系列，labuladong大神的算法讲解，讲的很不错，开始学习并记录一些笔记吧！</p>
<p><strong>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）</strong>。</p>
<h1 id="数组遍历框架"><a href="#数组遍历框架" class="headerlink" title="数组遍历框架"></a>数组遍历框架</h1><p><strong>线性迭代结构：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i)</span><br><span class="line">        <span class="comment">// 迭代访问 arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>++i</code>和<code>i++</code>的效率有区别，前者直接返回<code>i+1</code>的结果，后者会生成一个临时变量，因此性能比前者较弱。</p>
</blockquote>
<h1 id="链表遍历框架"><a href="#链表遍历框架" class="headerlink" title="链表遍历框架"></a>链表遍历框架</h1><p><strong>兼具迭代和递归：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的单链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ListNode p = head; p != null; p = p.next)&#123;</span><br><span class="line">        <span class="comment">// 迭代访问p.val</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归访问head.val</span></span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><p><strong>非线性递归遍历结构：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的二叉树结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>扩展到$n$叉树：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本的n叉树结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求二叉树中最大路径和"><a href="#求二叉树中最大路径和" class="headerlink" title="求二叉树中最大路径和"></a>求二叉树中最大路径和</h2><p><strong>LeetCode-124，hard——求二叉树中最大路径和（后序遍历）：</strong></p>
<blockquote>
<p>给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1, 2, 3]</p>
<p>   1<br>  / \<br> 2   3</p>
<p>输出：6</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[-10, 9, 20, null, null, 15, 7]</p>
<p> -10<br>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<p>输出：42</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans =INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oneSideMax</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, oneSideMax(root-&gt;left));	<span class="comment">// 先访问左子树</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, oneSideMax(root-&gt;right));	<span class="comment">// 再访问右子树</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left+right+root-&gt;val);	<span class="comment">// 比较根结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>LeetCode-105，medium——根据前序遍历序列和中序遍历序列还原一棵二叉树（前序遍历）：</strong></p>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</blockquote>
<p>例如，给出</p>
<blockquote>
<p><strong>前序遍历</strong> preorder = [3, 9, 20, 15, 7]<br><strong>中序遍历</strong> inorder = [9, 3, 15, 20, 7]<br>返回如下的二叉树：</p>
<p>​    3</p>
<p>   / \<br>  9  20<br>    /  \<br>   15   7</p>
<p><strong>限制：</strong></p>
<p>0 &lt;= 节点个数 &lt;= 5000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preoeder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, Map&lt;Integer, Integer&gt; inMap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd) <span class="keyword">return</span> null;</span><br><span class="line">    </span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);	<span class="comment">// 前序遍历第一个结点是根结点</span></span><br><span class="line">    <span class="keyword">int</span> inRoot = inMap.<span class="built_in">get</span>(root.val);	<span class="comment">// 获取中序遍历中根结点的索引</span></span><br><span class="line">    <span class="keyword">int</span> numsLeft = inRoot - inStart;	<span class="comment">// 计算左子树的个数</span></span><br><span class="line">    </span><br><span class="line">    root.left = buildTree(preorder, preStart+<span class="number">1</span>, preStart + numsLeft, inorder, inStart, inRoot<span class="number">-1</span>, inMap);	<span class="comment">// 递归构建左子树</span></span><br><span class="line">    root.right = buildTree(preorder, preStart+numsLeft+<span class="number">1</span>, preEnd, inorder, inRoot+<span class="number">1</span>, inEnd, inMap);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="恢复一棵-BST"><a href="#恢复一棵-BST" class="headerlink" title="恢复一棵 BST"></a>恢复一棵 BST</h2><p><strong>LeetCode-99，hard——根据前序遍历序列和中序遍历序列还原一棵二叉树（中序遍历）</strong></p>
<blockquote>
<p>二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：[1, 3, null, null, 2]</p>
<p>   1<br>  /<br> 3<br>  \<br>   2</p>
<p>输出：[3, 1, null, null, 2]</p>
<p>   3<br>  /<br> 1<br>  \<br>   2</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：[3, 1, 4, null, null, 2]</p>
<p>  3<br> / \<br>1   4<br>   /<br>  2</p>
<p>输出：[2, 1, 4, null, null, 3]</p>
<p>  2<br> / \<br>1   4<br>   /<br>  3</p>
</blockquote>
<p><strong>进阶：</strong></p>
<blockquote>
<p>使用 O(n) 空间复杂度的解法很容易实现。<br>你能想出一个只使用常数空间的解决方案吗？</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二叉排序树的中序遍历序列是有序的，可以将该序列存放于一个数组。遍历该数组，找到顺序不一致的两个下标<code>i</code>和<code>j</code>，将<code>arr[i].val</code>和<code>arr[j].val</code>的值互换一下即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNide* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    traverse(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val &lt; prev-&gt;val)&#123;</span><br><span class="line">        s=(s==<span class="literal">NULL</span>)?prev:s;</span><br><span class="line">        t=node;</span><br><span class="line">    &#125;</span><br><span class="line">    prev=node;</span><br><span class="line">    traverse(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统——第一章 操作系统引论</title>
    <url>/2020/06/08/OS-Ch1-01/</url>
    <content><![CDATA[<h1 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h1><h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><p><strong>进程是一个程序的执行过程，执行前需要将该程序放到内存中，才能被CPU处理。</strong></p>
<p>操作系统提供的功能：CPU管理、存储器管理、文件管理、设备管理</p>
<p><strong>目标：</strong>安全性与高效性</p>
<p><strong>命令接口与程序接口：</strong></p>
<p><img src="/2020/06/08/OS-Ch1-01/1.png" style="width=40%"></p>
<p>联机命令接口=交互式命令接口</p>
<p>脱机命令接口=批处理命令接口</p>
<p>程序接口：.程序员调用dll实现创建窗口的功能（系统调用），智能通过用户程序<strong>间接使用</strong></p>
<blockquote>
<p><strong>有效性</strong></p>
<ol>
<li>提高系统资源利用率</li>
<li>提高系统吞吐量</li>
</ol>
<p><strong>方便性</strong></p>
<p><strong>可扩充性</strong></p>
<p><strong>开放性</strong></p>
</blockquote>
<p><strong>作用：</strong></p>
<blockquote>
<ol>
<li>作为用户与计算机硬件系统之间的接口<ul>
<li>命令方式</li>
<li>系统调用方式</li>
<li>图形、窗口方式</li>
</ul>
</li>
<li>作为计算机系统资源的管理者<ul>
<li>管理资源分为：处理器管理（分配和控制处理机）、存储器管理（内存的分配与回收）、I/O设备管理（I/O设备的分配与操纵）、文件管理（文件的存取、共享和保护）</li>
</ul>
</li>
<li>实现了对计算机资源的抽象</li>
</ol>
</blockquote>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><p><strong>并发性：</strong></p>
<blockquote>
<p>并行：并行性是指两个或多个事件在<strong>同一时刻发生</strong></p>
<p>并发：并发性是指两个或多个事件在<strong>同一时间间隔内发生</strong></p>
</blockquote>
<p><strong>引入进程——操作系统中可以拥有资源并作为独立运行的基本单位</strong></p>
<blockquote>
<p>目的：为了使多个程序能并发执行（进程作为分配资源的基本单位）</p>
</blockquote>
<p><strong>引入线程：</strong></p>
<blockquote>
<p>特征：一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源（线程作为独立运行和独立调度<br>的基本单位）</p>
</blockquote>
<p><strong>共享性</strong></p>
<blockquote>
<p>系统中的资源可供内存中<strong>多个并发执行的进程（线程）共同使用</strong>，相应地，把这种资源共同使用称为<strong>资源共享</strong>，或称为<strong>资源复用</strong>，两种资源共享的两种方式：</p>
<ul>
<li>互斥共享方式：仅当A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问（一段时间内<strong>只允许一个进程访问</strong>的资源称为<strong>临界资源</strong>或<strong>独占资源</strong>）</li>
<li>同时访问方式：允许在一段时间内由多个进程“同时”对它们进行访问，进程交替地对该资源进行访问</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-数组和字符串</title>
    <url>/2020/06/06/LeetCode-Array/</url>
    <content><![CDATA[<h1 id="寻找数组中心索引"><a href="#寻找数组中心索引" class="headerlink" title="寻找数组中心索引"></a>寻找数组中心索引</h1><h1 id="数组数组简介"><a href="#数组数组简介" class="headerlink" title="数组数组简介"></a>数组数组简介</h1><h2 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p>
<p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入：nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入：nums = [1, 2, 3]<br>输出：-1<br>解释：数组中不存在满足此条件的中心索引。</p>
</blockquote>
<p><strong>说明:</strong></p>
<ul>
<li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>计算整个数组的和<code>totalSum​</code>，循环记录前​<code>i</code>个数的和<code>curSum</code>。</li>
<li>如果：<code>totalSum-curSum-nums[i]==curSum​</code>，即：​<code>nums[i]​</code>前后数据和相等，​<code>nums[i]​</code>为中枢元素。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivoIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();		<span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; w : nums)</span><br><span class="line">            totalSum += w;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(totalSum - curSum - nums[i] == curSum)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curSum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-704题：二分查找"><a href="#LeetCode-704题：二分查找" class="headerlink" title="LeetCode-704题：二分查找"></a>LeetCode-704题：二分查找</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="/2020/06/06/LeetCode-Array/array1.png" alt></p>
<p>把待搜索区域分为3个部分：</p>
<ul>
<li><code>[mid]​</code>：直接返回；</li>
<li><code>[left,mid - 1]​</code>：设置边界<code>right = mid - 1​</code></li>
<li><code>[mid + 1, right]</code>：设置边界<code>left = mid + 1</code></li>
</ul>
<h2 id="二分查找扩展问题"><a href="#二分查找扩展问题" class="headerlink" title="二分查找扩展问题"></a>二分查找扩展问题</h2><ol>
<li>在有序数组中查找等于目标的元素的第1个索引或者最后1个下标；</li>
<li>在有序数组中查找第1个大于（等于）目标元素的下标；</li>
<li>在有序数组中查找第1个小于（等于）目标元素的下标；</li>
<li>在有序数组中查找最后1个大于（等于）目标元素的下标；</li>
<li>在有序数组中查找最后1个下于（等于）目标元素的下标。</li>
</ol>
<p>704题二分查找问题需要思考：</p>
<ul>
<li>返回<code>left</code>还是<code>right</code></li>
<li>看到了目标元素<code>target</code>以后，边界如何设置</li>
</ul>
<h3 id="排除法——另一种思路"><a href="#排除法——另一种思路" class="headerlink" title="排除法——另一种思路"></a>排除法——另一种思路</h3><p>考虑中间元素<code>nums[mid]</code>在什么情况下不是目标元素。把待搜索区间分为2部分，一部分<strong>一定不存在</strong>目标元素面临一部分<strong>可能存在</strong>目标元素。</p>
<p>根据中间元素<code>mid</code>被分到左边区间还是右边区间，有以下两种情况：</p>
<p><img src="/2020/06/06/LeetCode-Array/array2.png" alt></p>
<p>把待搜索区间分为2个部分：</p>
<ol>
<li><code>[left, mid]</code>，设置边界<code>right = mid</code></li>
<li><code>[mid + 1, right]</code>，设置边界<code>left= mid + 1</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(target &lt; mid)&#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/06/LeetCode-Array/array3.png" alt></p>
<p>把待搜索区间分为2个部分：</p>
<ol>
<li><code>[left, mid - 1]</code>，设置边界<code>right = mid - 1</code></li>
<li><code>[mid + 1, right]</code>，设置边界<code>left= mid</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(target &lt; mid)&#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    left = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="“排除法”（减治）一般步骤"><a href="#“排除法”（减治）一般步骤" class="headerlink" title="“排除法”（减治）一般步骤"></a>“排除法”（减治）一般步骤</h3><ol>
<li>把循环可以继续的条件写成<code>while(left &lt; right)</code>；</li>
<li>写<code>if</code>和<code>else</code>语句的时候，思考当<code>nums[mid]</code>满足什么性质时，<code>nums[i]</code>不是目标元素，解这判断<code>mid</code>的左边有没有可能存在目标元素，<code>mid</code>的右边有没有可能存在目标元素；</li>
<li>根据“边界收缩行为”修改中间数的行为：<ol>
<li><code>int mid = (left + right)  / 2</code>；在<code>left</code>和<code>right</code>较大的时候会发生整形溢出。建议的写法：<code>int mid = left + (right - left) / 2</code>；</li>
<li>“<code>/</code>“是整数除法，默认的取整行为是向下取整，那么它会带来一个问题：<code>int mid = left + (right - left) / 2</code>永远取不到右边界<code>right</code>，在面对<code>left = mid</code>和<code>right = mid - 1</code>这种边界收缩行为时，可能产生死循环。</li>
</ol>
</li>
<li>退出循环后，看是否需要对<code>nums[left]</code>是否是目标元素再做一次判断。</li>
</ol>
<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入：[1, 3, 5, 6],  5<br>输出：2</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入：[1, 3, 5, 6],  2<br>输出：1</p>
</blockquote>
<p><strong>示例 3:</strong></p>
<blockquote>
<p>输入：[1, 3, 5, 6],  7<br>输出：4</p>
</blockquote>
<p><strong>示例 4:</strong></p>
<blockquote>
<p>输入：[1, 3, 5, 6],  0<br>输出：0</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先，插入位置有可能在数组的末尾（题目中的示例 3），需要单独判断；</li>
<li>其次，如果待插入元素比最后一个元素严格小，并且在这个数组中有和插入元素一样的元素，返回任意一个位置即可；</li>
<li>否则，插入的位置应该是严格大于 target 的第 1 个元素的位置。</li>
</ol>
<p>因此，<strong>严格小于 <code>target</code> 的元素一定不是解</strong>。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 严格小于 target 的元素一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入:：[[1, 3], [2, 6], [8, 10], [15, 18]]<br>输出：[[1, 6], [8, 10], [15, 18]]<br>解释：区间 [1, 3] 和 [2, 6] 重叠, 将它们合并为 [1,6].</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入：[[1, 4], [4, 5]]<br>输出：[[1, 5]]<br>解释：区间 [1, 4] 和 [4, 5] 可被视为重叠区间。</p>
</blockquote>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的。用数组<code>merged</code>存储最终的答案。首先，将第一个区间加入<code>merged</code>数组中，并按顺序依次考虑之后的每个区间：</p>
<ul>
<li>如果当前区间的左端点在数组<code>merged</code>中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组<code>merged</code>的末尾；</li>
</ul>
<ul>
<li>否则，它们重合，我们需要用当前区间的右端点更新数组<code>merged</code>中最后一个区间的右端点，将其置为二者的较大值。</li>
</ul>
<p><img src="/2020/06/06/LeetCode-Array/array4.png" alt></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merged;</span><br><span class="line">        <span class="keyword">int</span> n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> L=intervals[i][<span class="number">0</span>], R=intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!merged.<span class="built_in">size</span>()||merged.back()[<span class="number">1</span>]&lt;L)&#123;</span><br><span class="line">                merged.push_back(&#123;L,R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                merged.back()[<span class="number">1</span>]=<span class="built_in">max</span>(R,merged.back()[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二维数组简介"><a href="#二维数组简介" class="headerlink" title="二维数组简介"></a>二维数组简介</h1><p>二维数据处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。</p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1, 2, 3],<br>  [4, 5, 6],<br>  [7, 8, 9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7, 4, 1],<br>  [8, 5, 2],<br>  [9, 6, 3]<br>]</p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><strong>归纳法——</strong>以$4\times 4$的矩阵为例（例2），数组下标的变化如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$[0,0]$——&gt;$[0,3]$</th>
<th>$[1,0]$——&gt;$[0,2]$</th>
<th>$[2,0]$——&gt;$[0,1]$</th>
<th>$[3,0]$——&gt;$[0,0]$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$[0,1]$——&gt;$[1,3]$</td>
<td>$[1,0]$——&gt;$[1,2]$</td>
<td>$[2,0]$——&gt;$[1,1]$</td>
<td>$[3,0]$——&gt;$[1,0]$</td>
</tr>
<tr>
<td>$[0,2]$——&gt;$[2,3]$</td>
<td>$[1,0]$——&gt;$[2,2]$</td>
<td>$[2,0]$——&gt;$[2,1]$</td>
<td>$[3,0]$——&gt;$[2,0]$</td>
</tr>
<tr>
<td>$[0,3]$——&gt;$[3,3]$</td>
<td>$[1,0]$——&gt;$[3,2]$</td>
<td>$[2,0]$——&gt;$[3,1]$</td>
<td>$[3,0]$——&gt;$[3,0]$</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，旋转之后的矩阵行、列之间的关系满足：</p>
<script type="math/tex; mode=display">
matrix_{new}[j][n-1-i]=matrix[i][j]</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> matrix_new = matrix;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                matrix_new[j][n<span class="number">-1</span>-i]=matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = matrix_new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h2 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a>对角线遍历</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——平衡二叉树</title>
    <url>/2020/06/06/DataStructure-BBiTree/</url>
    <content><![CDATA[<p><img src="/2020/06/06/DataStructure-BBiTree/AVL.png" alt></p>
<a id="more"></a>
<h1 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h1><p>任意结点的<strong>平衡因子</strong>的绝对值不超过1（左子树高度$-$右子树高度）。</p>
<p><strong>高度为$h$的最小平衡二叉树的结点数$N_h$</strong>：</p>
<p><img src="/2020/06/06/DataStructure-BBiTree/AVL1.png" alt></p>
<p>右子树可以有三种选择：$N_{h}$、$N_{h-1}$、$N_{h-2}$。</p>
<ul>
<li>如果是$N_{h}$，则加上根结点高度会超过$h$，不可能；</li>
<li>$h-1$层的结点数一定大于$h-2$层的结点数，因此最小的平衡二叉树应在$h-2$层的子树上。</li>
</ul>
<script type="math/tex; mode=display">
N_h=N_{h-1}+N_{h-2}+1</script><p>$N_0=0$，$N_1=1$。</p>
<h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>利用递归遍历的后序遍历过程：</p>
<ol>
<li>判断左子树是一棵平衡二叉树</li>
<li>判断右子树是一棵平衡二叉树</li>
<li>判断该结点为根的二叉树为平衡二叉树</li>
</ol>
<p><strong>判断条件</strong>：</p>
<p>若左子树和右子树均为平衡二叉树</p>
<p>且左子树与右子树高度的绝对值小于等于$1$，则平衡。</p>
<p><img src="/2020/06/06/DataStructure-BBiTree/AVL2.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl=<span class="number">0</span>,br=<span class="number">0</span>mhl=<span class="number">0</span>,hr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;bt-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        h=<span class="number">1</span>;</span><br><span class="line">        balance=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Judge_AVL(bt-&gt;lchild,bl,hl);</span><br><span class="line">        Judge_AVL(bt-&gt;rchild,br,hr);</span><br><span class="line">        <span class="keyword">if</span>(hl&gt;hr)</span><br><span class="line">            h=hl+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h=hr+<span class="number">1</span>；</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(hl-hr)&lt;<span class="number">2</span>&amp;&amp;bl=<span class="number">1</span>&amp;&amp;br=<span class="number">1</span>)</span><br><span class="line">            balance=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            balance=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>对二叉排序树进行优化：<strong>先插入，再调整</strong>，每次调整最小不平衡二叉树</p>
<p><img src="/2020/06/06/DataStructure-BBiTree/AVL3.png" alt></p>
<h2 id="LL平衡旋转（右单旋转）"><a href="#LL平衡旋转（右单旋转）" class="headerlink" title="LL平衡旋转（右单旋转）"></a>LL平衡旋转（右单旋转）</h2><p><strong>原因</strong>：在结点$A$的左孩子的左子树上插入了新结点。</p>
<p><strong>调整方法</strong>：<strong>右旋操作</strong>——将$A$的左孩子$B$代替$A$，将$A$结点称为$B$的右子树根结点，而$B$的原右子树则作为$A$的左子树。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL4_1.png"></center></td>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL4_2.png"></center></td>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL4_3.png"></center></td>
    </tr>
</table>



<h2 id="RR平衡旋转（左单旋转）"><a href="#RR平衡旋转（左单旋转）" class="headerlink" title="RR平衡旋转（左单旋转）"></a>RR平衡旋转（左单旋转）</h2><p><strong>原因</strong>：在结点$A$的右孩子的右子树上插入了新结点。</p>
<p><strong>调整方法</strong>：左旋操作——将$A$的右孩子$B$代替$A$，将$A$结点称为$B$的左子树根结点，而$B$的原左子树则作为$A$的右子树。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL5_1.png"></center></td>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL5_2.png"></center></td>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL5_3.png"></center></td>
    </tr>
</table>



<h2 id="LR平衡旋转（先左后右双旋转）"><a href="#LR平衡旋转（先左后右双旋转）" class="headerlink" title="LR平衡旋转（先左后右双旋转）"></a>LR平衡旋转（先左后右双旋转）</h2><p><strong>原因</strong>：在结点$A$的左孩子的右子树上插入了新结点。</p>
<p><strong>调整方法</strong>：<strong>先左后右双旋转</strong>——将$A$的左孩子$B$的右孩子结点$C$代替$B$，然后再将$C$结点向上代替$A$的位置。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL6.png"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL6_1.png"></center></td>
    </tr>
</table>



<h2 id="RL平衡旋转（先右后左双旋转）"><a href="#RL平衡旋转（先右后左双旋转）" class="headerlink" title="RL平衡旋转（先右后左双旋转）"></a>RL平衡旋转（先右后左双旋转）</h2><p><strong>原因</strong>：在结点$A$的右孩子的左子树上插入了新结点。</p>
<p><strong>调整方法</strong>：<strong>先右后左双旋转</strong>——将$A$的右孩子$B$的左孩子结点$C$代替$B$，然后再将$C$结点向上代替$A$的位置。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL7.png"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/06/06/DataStructure-BBiTree/AVL7_1.png"></center></td>
    </tr>
</table>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——二叉排序树</title>
    <url>/2020/06/06/DataStructure-BiTSort/</url>
    <content><![CDATA[<p><img src="/2020/06/06/DataStructure-BiTSort/bst1.png" alt> </p>
<a id="more"></a>
<h1 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h1><p>也称为<strong>二叉查找树</strong>。二叉排序树或者为空树，或者为非空树，当为非空树时，满足（递归定义）：</p>
<ol>
<li>若左子树非空，则左子树上所有结点关键字值均<strong>小于</strong>根结点的关键字；</li>
<li>若右子树非空，则右子树上所有结点关键字值均<strong>大于</strong>根结点的关键字；</li>
<li>左子树、右子树本身也分别是一棵二叉排序树。</li>
</ol>
<p><strong>组织内存索引</strong></p>
<ul>
<li>二叉排序树是适用于内存储器的一种重要树形索引（常用红黑树、伸展树等以维持平衡）</li>
<li>外存常用B/B+数</li>
</ul>
<p><strong>中序遍历序列</strong>：1、2、3、4、5、7、8、10、16（依次递增）</p>
<p><strong>左子树结点值$&lt;$根结点值$&lt;$右子树结点值</strong></p>
<p><strong>二叉排序树中序遍历序列是一个递增有序序列</strong></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><ol>
<li>二叉树非空时，查找根结点，若相等则查找成功；</li>
<li>若不等，则当小于根结点值时，查找左子树；当大于根结点值时，查找右子树；</li>
<li>当查找到叶子结点仍没找到相应的值，则查找失败。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key, BSNode *&amp;p)</span></span>&#123;		<span class="comment">// 指针引用</span></span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;data)&#123;</span><br><span class="line">        p=T;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ol>
<li>若二叉排序树为空，则直接插入结点；</li>
<li>若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根节点时，不进行插入。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, KeyType k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T=(BiTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><ol>
<li>读入一个元素并建立结点，若二叉树为空将其作为根结点；</li>
<li>若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时，不进行插入。</li>
</ol>
<p><img src="/2020/06/06/DataStructure-BiTSort/bst2.png" alt> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        BST_Insert(T,str[i]);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造二叉排序树时，即使插入的值相同，但如果插入顺序不同，则构造完成的二叉排序树也不同</strong></p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ol>
<li>若被删除的结点$z$是叶子结点，则直接删除；</li>
<li>若被删除的结点$z$有一棵子树，则让$z$的子树成为$z$父结点的子树，代替$z$结点；</li>
<li>若被删除的结点$z$有两棵子树，则让$z$的中序序列直接后继代替$z$，并删去直接后继结点。</li>
</ol>
<p><strong>中序遍历序列永远是递增的</strong></p>
<p><img src="/2020/06/06/DataStructure-BiTSort/bst3.png" alt> </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>在二叉排序树中删除并插入某个结点，得到的二叉排序树是否与原来相同？</strong></p>
<p><img src="/2020/06/06/DataStructure-BiTSort/bst4.png" alt title="删除叶子结点后再插入，二叉排序树不变"></p>
<p> <img src="/2020/06/06/DataStructure-BiTSort/bst5.png" alt title="删除非叶子结点后再插入，二叉排序树会改变"></p>
<h1 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h1><p><strong>平均查找长度</strong>（ASL）取决于树的高度：<strong>$O(log_2n)$</strong></p>
<p><strong>最坏的情况</strong>：<strong>$O(n)$</strong>，即构造序列有序的情况</p>
<p> <img src="/2020/06/06/DataStructure-BiTSort/bst6.png" alt></p>
<script type="math/tex; mode=display">
ASL=(1+2 \cdot 2+3)/4=2</script><p>$1$：表示只经历了一个根结点</p>
<p>$2\cdot 2$：表示有两个结点（1、4）经历了2个结点</p>
<p>$3$：表示只有一个结点（3）经历了3个结点</p>
<p>$4$：结点总数</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——树的应用并查集</title>
    <url>/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一种简单的几何表示：一个集合有若干个元素，该集合也被划分成若干个子集。通常用树的<strong>双亲表示法</strong>（用数组存放每个结点的元素，用伪指针存储该结点双亲结点的索引）作为并查集的存储结构。</p>
<p>通常用数组元素的下标表示元素名，用根结点的下标代表子集合名，根结点的双亲结点表示负数。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="初始化——Initial-s"><a href="#初始化——Initial-s" class="headerlink" title="初始化——Initial(s)"></a>初始化——Initial(s)</h2><p>功能：将集合$S$的每个元素都初始化为只有一个单元素的子集合。</p>
<h2 id="并——Union-S-Root1-Root2"><a href="#并——Union-S-Root1-Root2" class="headerlink" title="并——Union(S, Root1, Root2)"></a>并——Union(S, Root1, Root2)</h2><p>功能：把集合$S$中的子集合（互不相交）$Root2$并入子集合$Root1$。</p>
<h2 id="查——Find-S-x"><a href="#查——Find-S-x" class="headerlink" title="查——Find(S,x)"></a>查——Find(S,x)</h2><p>查找集合$S$中单元素$x$所在子集合，并返回该子集合的名字。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><script type="math/tex; mode=display">
S={0,1,2,3,4,5,6,7,8,9}</script><h2 id="S-0-0-，S-1-1-，S-2-2-，S-3-3-，S-4-04-，"><a href="#S-0-0-，S-1-1-，S-2-2-，S-3-3-，S-4-04-，" class="headerlink" title="$S_0={0}，S_1={1}，S_2={2}，S_3={3}，S_4={04}，$"></a>$S_0={0}，S_1={1}，S_2={2}，S_3={3}，S_4={04}，$</h2><p>$S_5={5}，S_6={6}，S_7={7}，S_8={8}，S_9={9}。$</p>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/array.png" alt title="双亲表示法"></p>
<p>$S_0={0，6，7，8}，S_1={1，4，9}，S_2={2，3，5}$</p>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/array1.png" alt title="双亲表示法：根结点绝对值表示该集合的元素个数"></p>
<h1 id="语言实现"><a href="#语言实现" class="headerlink" title="语言实现"></a>语言实现</h1><h2 id="Initial"><a href="#Initial" class="headerlink" title="Initial()"></a>Initial()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSet[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;		<span class="comment">// 初始化每个元素为子集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">        S[i]=<span class="number">-1</span>;			<span class="comment">// 将双亲结点的下标修改为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/initial.png" alt title="初始化并查集"></p>
<h2 id="Find"><a href="#Find" class="headerlink" title="Find()"></a>Find()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)		<span class="comment">// 双亲指针不断向上查找</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> x;			<span class="comment">// 返回该元素所在的根结点的数组下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/find.png" alt></p>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/find1.png" alt></p>
<h2 id="Union"><a href="#Union" class="headerlink" title="Union()"></a>Union()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/union.png" alt title="将1结点的双亲指针修改为0"></p>
<p><img src="/2020/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%B9%B6%E6%9F%A5%E9%9B%86/union1.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——树、森林、二叉树的转换</title>
    <url>/2020/06/05/DataStructure-ForestTree/</url>
    <content><![CDATA[<h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树转换二叉树"><a href="#树转换二叉树" class="headerlink" title="树转换二叉树"></a>树转换二叉树</h4><p>规则：<strong>左孩子右兄弟</strong>，每个结点左指针指向它的第一个孩子结点，右指针指向它在树中相邻兄弟结点。</p>
<p><img src="/2020/06/05/DataStructure-ForestTree/tree_bitree.png" alt="树" title="树"><img src="/2020/06/05/DataStructure-ForestTree/tree_bitree1.png" alt="二叉树" title="二叉树"></p>
<h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4><p>规则： 逆过程，将指针修改回来，指向其双亲结点。</p>
<h4 id="森林转换二叉树"><a href="#森林转换二叉树" class="headerlink" title="森林转换二叉树"></a>森林转换二叉树</h4><p><strong>二叉树转换森林是唯一的</strong></p>
<p>规则：将每一棵树转换为二叉树，将每棵二叉树的根依次作为上一棵二叉树的右子树。</p>
<p><img src="/2020/06/05/DataStructure-ForestTree/forest_tree.png" alt title="将每棵树转换为二叉树"><img src="/2020/06/05/DataStructure-ForestTree/forest_tree1.png" alt title="二叉树的根作为上一棵二叉树的右子树"></p>
<h4 id="二叉树转换森林"><a href="#二叉树转换森林" class="headerlink" title="二叉树转换森林"></a>二叉树转换森林</h4><p>规则：逆过程，先找到每一棵树，拆解。</p>
<h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>规则：按照某种方式访问树中的每个结点，且仅访问依次。</p>
<p><strong>先根遍历</strong>：若树非空，则先访问根结点，再按从左往右的顺序遍历根结点的每个子树，即：<strong>R、A、D、E、B、C、F、G、H、K——与二叉树先序遍历序列相同</strong>。</p>
<p><strong><font color="red" size="4">树的先根遍历序列与这棵树对应的二叉树先序遍历序列相同</font></strong></p>
<p><strong>后根遍历</strong>：若树非空，则先按从左往右的顺序遍历根结点的每棵子树，再访问根结点，即：<strong>D、E、A、B、G、H、K、F、C、R——与二叉树中序遍历序列相同</strong>。</p>
<p><strong><font color="red" size="4">树的后根遍历序列与这棵树对应的二叉树中序遍历序列相同</font></strong></p>
<p><strong>层次遍历</strong>：</p>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>若森林非空，则</p>
<ul>
<li>访问森林中第一棵树的根结点</li>
<li>先序遍历第一棵树的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的子树森林</li>
</ul>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>若森林非空，则</p>
<ul>
<li>中序遍历第一棵树的根结点的子树森林</li>
<li>访问森林中第一棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="/2020/06/05/DataStructure-ForestTree/forest.png" alt title="森林"></p>
<p><strong>先序遍历</strong>：A、D、E、B、C、F、G、H、K</p>
<p><strong><font color="red" size="4">森林的先序遍历序列与森林对应的二叉树先序遍历序列相同</font></strong></p>
<p><strong>中序遍历</strong>：D、E、A、B、G、H、K、F、C</p>
<p><strong><font color="red" size="4">森林的中序遍历序列与森林对应的二叉树先中序历序列相同</font></strong></p>
<h3 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>树</strong></th>
<th><strong>森林</strong></th>
<th><strong>二叉树</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
        <tag>森林</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——树的存储结构</title>
    <url>/2020/06/04/DataStructure-BiTree-Mem/</url>
    <content><![CDATA[<p><img src="/2020/06/04/DataStructure-BiTree-Mem/tree_parent_save.png" style="width: 40%"></p>
<a id="more"></a>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置，根结点的下表为$0$，其伪指针域为$-1$。</p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100						</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">// 每个结点					</span></span><br><span class="line">    ElemType data;			<span class="comment">// 结点数据					</span></span><br><span class="line">    <span class="keyword">int</span> parent;				<span class="comment">// 结点双亲</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line">				</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">// 树				</span></span><br><span class="line">    PNOde nodes[MAX_TREE_SIZE];		<span class="comment">// 结点结构体数组			</span></span><br><span class="line">    <span class="keyword">int</span> n;					<span class="comment">// 结点数量</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，$n$个结点具有$n$个孩子链表。</p>
<p> <img src="/2020/06/04/DataStructure-BiTree-Mem/tree_child.png" style="width: 40%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100				</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">// 孩子结点结构体			</span></span><br><span class="line">    <span class="keyword">int</span> child;			<span class="comment">// 孩子结点下标					</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span>	<span class="comment">// 下一个孩子结点的指针</span></span><br><span class="line">&#125;CNode;</span><br><span class="line">							</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">// 每一个结点存放的数据元素			</span></span><br><span class="line">    ElemType data;		<span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">child</span>;</span><span class="comment">// 对应的第一个孩子结点的指针——单链表头指针</span></span><br><span class="line">&#125;PNode;</span><br><span class="line">							</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">// 树结构			</span></span><br><span class="line">    PNode nodes[MAX_TREE_SIZE];	<span class="comment">// 结点数量</span></span><br><span class="line">    <span class="keyword">int</span> n;				<span class="comment">// 结点数组</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>以二叉链表作为树的存储结构，又称二叉树表示法（左孩子右兄弟）。</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Mem/tree_bro.png" style="width: 40%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CsNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">friendchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,CSTree;</span><br></pre></td></tr></table></figure>
<p>根结点右指针为空——没有兄弟结点</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Mem/tree_bro1.png" style="width: 70%"></p>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>双亲表示法</td>
<td>寻找结点双亲结点效率高</td>
<td>寻找结点的孩子结点效率低</td>
</tr>
<tr>
<td>孩子表示法</td>
<td>寻找结点的孩子结点效率高</td>
<td>寻找结点的双亲结点效率低</td>
</tr>
<tr>
<td>孩子兄弟表示法</td>
<td>寻找结点的孩子结点效率高<br>方便实现树转换为二叉树</td>
<td>寻找结点的双亲结点效率低</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——线索二叉树</title>
    <url>/2020/06/04/DataStructure-BiTree-Cue/</url>
    <content><![CDATA[<p><img src="/2020/06/04/DataStructure-BiTree-Cue/cue_tree1.png" style="width: 50%"></p>
<a id="more"></a>
<h3 id="二叉树的遍历顺序"><a href="#二叉树的遍历顺序" class="headerlink" title="二叉树的遍历顺序"></a>二叉树的遍历顺序</h3><p><img src="/2020/06/04/DataStructure-BiTree-Cue/cue_tree.png" style="width: 30%"></p>
<p><strong>前序遍历：</strong>1、2、4、5、3、6</p>
<p><strong>中序遍历：</strong>4、2、5、1、6、3</p>
<p><strong>后序遍历：</strong>4、5、2、6、3、1</p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>利用二叉树链表的空指针实现线索二叉树。</p>
<p><strong>线索化：</strong></p>
<ul>
<li><strong>若无左子树，则将其左指针指向其前驱结点；</strong></li>
<li><strong>若无右子树，则将其右指针指向其后继结点；</strong></li>
</ul>
<h3 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h3><p><strong>前序遍历：</strong>1、2、4、5、3、6</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Cue/pre_cue.png" style="width: 30%"></p>
<h3 id="中序线索二叉树（较为常用）"><a href="#中序线索二叉树（较为常用）" class="headerlink" title="中序线索二叉树（较为常用）"></a>中序线索二叉树（较为常用）</h3><p><strong>中序遍历：</strong>4、2、5、1、6、3</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Cue/in_cue.png" style="width: 30%"></p>
<p>中序遍历：第一个结点是最左侧结点，最后一个结点是最右边的结点。</p>
<p>前驱结点：</p>
<ul>
<li>若左指针为线索，则其指向结点为前驱结点；</li>
<li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点。</li>
</ul>
<p>后继结点：</p>
<ul>
<li>若右指针为线索，则其指向结点为后驱结点；</li>
<li>若右指针为右孩子，则其右子树的最左侧结点为后驱结点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InTread(T,pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型：需要对其进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InTread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 传入参数 线索二叉树根结点、对应节点前驱结点</span></span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断根结点是否为空</span></span><br><span class="line">        InThread(p-&gt;lchild,pre);</span><br><span class="line">        <span class="comment">// 线索化，递归调用线索化左子树：左子树根结点及前驱结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchikd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InThread(p-&gt;rchild,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/04/DataStructure-BiTree-Cue/cue_post_list.png" style="width: 40%"></p>
<p><strong>带有头结点的中序线索二叉树：</strong></p>
<p>增加一个头结点</p>
<ul>
<li>左指针指向根结点；</li>
<li>第一个遍历序列（4）左指针指向头结点；</li>
<li>头结点的右指针指向最后一个遍历序列（3）;</li>
<li>遍历序列的最后一个结点（3）的右指针指向头结点。</li>
</ul>
<h3 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h3><p><strong>后序遍历：</strong>4、5、2、6、3、1</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Cue/post_cue.png" style="width: 30%"></p>
<h3 id="线索二叉树结点结构——线索链表"><a href="#线索二叉树结点结构——线索链表" class="headerlink" title="线索二叉树结点结构——线索链表"></a>线索二叉树结点结构——线索链表</h3><p>增加两个标志位：</p>
<p><img src="/2020/06/04/DataStructure-BiTree-Cue/cue_list.png" style="width: 30%"></p>
<script type="math/tex; mode=display">
标志域l(r)tag=\begin{cases} 0, & \text{$l(r)child$ 域指示结点的左（右）孩子}\\ 1, & \text{$l(r)child$ 域指示结点的前驱（后继）} \end{cases}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> structure ThreadNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    structure ThreadNode *lchild, *rchild;</span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
<h3 id="中序线索二叉树遍历"><a href="#中序线索二叉树遍历" class="headerlink" title="中序线索二叉树遍历"></a>中序线索二叉树遍历</h3><ol>
<li><p>寻找第一个结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从根结点出发，循环找到最左侧的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到后继结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// tag为0为孩子结点，需要找到它右子树最左侧结点为后继</span></span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// tag为1为先做点，右指针就是后继结点</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环调用寻找后继节点的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长公共子序列</title>
    <url>/2020/06/01/leetCode-longestCommonSequense/</url>
    <content><![CDATA[<p><img src="/2020/06/01/leetCode-longestCommonSequense/longest.png" style="width: 50%"></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</span><br><span class="line"></span><br><span class="line">一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span><br><span class="line">例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</span><br><span class="line"></span><br><span class="line">若这两个字符串没有公共子序列，则返回 0。</span><br></pre></td></tr></table></figure>
<p><strong>示例 :</strong></p>
<p>​    输入：text1 = “fish”, text2 = “hish”<br>​    输出：3<br>​    解释：最长公共子序列是 “ish”，它的长度为 3。</p>
<p><strong>说明：</strong></p>
<ol>
<li><code>1 &lt;= text1.length &lt;= 1000</code></li>
<li><code>1 &lt;= text2.length &lt;= 1000</code></li>
<li>输入的字符串只含有小写英文字符。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="动态转移方程"><a href="#动态转移方程" class="headerlink" title="动态转移方程"></a>动态转移方程</h4><script type="math/tex; mode=display">
dp[i][j]=\begin{cases}
0 & i=0/j=0 \\
dp[i-1][j-1]+1 & str1[i]=str1[j] \\
max(dp[i-1][j],dp[j-1][i]) & str1[i] \neq str2[j] 
\end{cases}</script><p>最长公共子序列问题时一个典型的二维动态规划求解的问题，子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝。</p>
<p><strong>第一步，一定要明确 <code>dp</code> 数组的含义</strong>。其中，<code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>最长公共子序列</tag>
        <tag>分治</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——重复数字</title>
    <url>/2020/06/01/leetCode-duplicateNumber/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line">假设只有一个重复的整数，找出这个重复的数。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例 1</strong><br>    输入: [1,3,4,2,2]<br>    输出: 2</p>
<p><strong>说明：</strong></p>
<pre><code> 1. 不能更改原数组（假设数组是只读的）。
 2. 只能使用额外的 O(1) 的空间。
 3. 时间复杂度小于 O(n2) 。
 4. 数组中只有一个重复的数字，但它可能不止重复出现一次。
</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把每个数字放到自己对应的下标处，如果其他位置上有和自己相同的数，则存在重复的数进行输出。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,temp;		<span class="comment">// 由于申请了额外的temp，内存消耗会占用一定的空间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]]==nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                temp=nums[nums[i]];</span><br><span class="line">                nums[nums[i]]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>nums=[1，3，4，2，2]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$i$</th>
<th>判断</th>
<th>交换</th>
<th>更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>$i=0$</td>
<td>$nums[0]=1 \neq 0$；<br>    $nums[1]=3 \neq 1$</td>
<td>$nums[1]=1$；<br>$nums[0]=3$</td>
<td>$[3，1，4，2，2]$</td>
</tr>
<tr>
<td>$i=1$</td>
<td>$nums[1]=1$；<br>    继续循环</td>
<td>$-$</td>
<td>$-$</td>
</tr>
<tr>
<td>$i=2$</td>
<td>$nums[2]=4 \neq 2$；<br>    $nums[4]=2 \neq 4$</td>
<td>$nums[2]=2$；<br>$nums[4]=4$</td>
<td>$[3，1，2，2，4]$</td>
</tr>
<tr>
<td>$i=3$</td>
<td>$nums[3]=2 \neq 3$<br>    $nums[3]=2=nums[2]$</td>
<td>$-$</td>
<td>输出重复数字：$2$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>重复数字</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——二叉树的遍历</title>
    <url>/2020/06/01/DataStructure-BiTree-trav/</url>
    <content><![CDATA[<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_trav.png" style="width: 50%"></p>
<a id="more"></a>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>按某条路径访问树中每个结点，树的每个结点均被访问一次，而且之访问一次，包括<strong>先序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>，这三种遍历都是<strong>深度优先遍历（DFS）</strong>。</p>
<blockquote>
<p>递归算法非常简洁——推荐使用</p>
<ul>
<li>当前编译系统优化效率很不错</li>
</ul>
<p>特殊情况下使用<strong>栈</strong>模拟递归</p>
<ul>
<li>理解编译栈的工作原理</li>
<li>理解深度优先遍历的回溯特点</li>
<li>有些应用环境资源限制不适合递归</li>
</ul>
</blockquote>
<h3 id="先序遍历（PreOrder）"><a href="#先序遍历（PreOrder）" class="headerlink" title="先序遍历（PreOrder）"></a>先序遍历（PreOrder）</h3><p><strong>“中左右”的递归顺序</strong>：</p>
<ol>
<li>访问根节点；</li>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    </span><br><span class="line">        temp=preorderTraversal(root-&gt;left);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">        temp=preorderTraversal(root-&gt;right);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n)</strong></p>
<h3 id="中序遍历（InOrder）"><a href="#中序遍历（InOrder）" class="headerlink" title="中序遍历（InOrder）"></a>中序遍历（InOrder）</h3><p><strong>“左中右”的递归顺序</strong>：</p>
<ol>
<li>中序遍历左子树；</li>
<li>访问根节点；</li>
<li>中序遍历右子树。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    temp=inorderTraversal(root-&gt;left);</span><br><span class="line">    res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    temp=inorderTraversal(root-&gt;right);</span><br><span class="line">    res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n)</strong></p>
<h3 id="后序遍历（PostOrder）"><a href="#后序遍历（PostOrder）" class="headerlink" title="后序遍历（PostOrder）"></a>后序遍历（PostOrder）</h3><p><strong>“左右中”的递归顺序：</strong></p>
<ol>
<li>后序遍历左子树；</li>
<li>后序遍历右子树；</li>
<li>访问根节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        temp=postorderTraversal(root-&gt;left);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        temp=postorderTraversal(root-&gt;right);</span><br><span class="line">        res.insert(res.<span class="built_in">end</span>(),temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());  </span><br><span class="line">        </span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：O(n)</strong></p>
<h3 id="递归算法转非递归算法——栈（前序遍历为例）"><a href="#递归算法转非递归算法——栈（前序遍历为例）" class="headerlink" title="递归算法转非递归算法——栈（前序遍历为例）"></a>递归算法转非递归算法——栈（前序遍历为例）</h3><p><strong>算法思想：</strong></p>
<ol>
<li>遇到一个结点，就访问该结点，并把此节点的非空右结点推入栈，然后下降取遍历它的左子树；</li>
<li>遍历完左子树后，从栈顶托出一个结点，并按照它的右链接指示的地址再去遍历该结点的右子树结构。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            Push(S,p-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!-<span class="literal">NULL</span>)</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归算法转非递归算法——栈（中序遍历为例）"><a href="#递归算法转非递归算法——栈（中序遍历为例）" class="headerlink" title="递归算法转非递归算法——栈（中序遍历为例）"></a>递归算法转非递归算法——栈（中序遍历为例）</h3><p><strong>算法思想：</strong></p>
<ol>
<li>初始时依次扫描<strong>根结点</strong>的所有<strong>左侧结点</strong>并将它们——<strong>进栈</strong>；</li>
<li>出栈一个结点——<strong>访问</strong>它；</li>
<li>扫描该结点的右孩子结点并将其进栈；</li>
<li>依次扫描右孩子结点的所有<strong>左侧结点</strong>——<strong>进栈</strong>；</li>
<li>反复该过程直到栈为空。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S,p);	<span class="comment">// 压栈</span></span><br><span class="line">            p=p-&gt;lchild;	<span class="comment">// 扫描左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p);	<span class="comment">// 弹出</span></span><br><span class="line">            visit(p);	<span class="comment">// 访问</span></span><br><span class="line">            p=p-&gt;rchild;	<span class="comment">// 扫描右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归算法转非递归算法——栈（后序遍历为例）"><a href="#递归算法转非递归算法——栈（后序遍历为例）" class="headerlink" title="递归算法转非递归算法——栈（后序遍历为例）"></a>递归算法转非递归算法——栈（后序遍历为例）</h3><p><strong>算法思想：</strong></p>
<ol>
<li>左子树返回 VS 右子树返回？</li>
<li>给栈中元素加上一个<strong>特征位</strong><ul>
<li>$Left$ 表示已进入该结点的左子树，将从左边回来</li>
<li>$Right$ 表示已进入该结点的右子树，将从右边回来</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    PostStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p||!IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="层次遍历——队列（先序遍历为例）"><a href="#层次遍历——队列（先序遍历为例）" class="headerlink" title="层次遍历——队列（先序遍历为例）"></a>层次遍历——队列（先序遍历为例）</h3><p><strong>算法思想：</strong></p>
<ol>
<li>初始将<strong>根节点入队列</strong>并<strong>访问</strong>根结点；</li>
<li>若有<strong>左子树</strong>，则将左子树的<strong>根入队列</strong>；</li>
<li>若有<strong>右子树</strong>，则将右子树的<strong>根入队列</strong>；</li>
<li>然后<strong>出队列</strong>，<strong>访问</strong>该结点；</li>
<li>反复该过程直到队列为空为止。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;     <span class="comment">// 初始化队列</span></span><br><span class="line">        q.push(root);           <span class="comment">// 根结点入队列 第一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            res.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;currentLevelSize;++i)&#123;        <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)                         <span class="comment">// 第二步</span></span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                    q.push(node-&gt;right);                <span class="comment">// 第三步</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历序列构造二叉树"><a href="#遍历序列构造二叉树" class="headerlink" title="遍历序列构造二叉树"></a>遍历序列构造二叉树</h3><p><strong>（后）先序遍历序列</strong>+<strong>中序遍历序列</strong>可以确定一棵二叉树，而后序遍历和先序遍历序列不可以确定一棵二叉树。</p>
<p><strong>中序遍历和先序遍历序列：</strong></p>
<ol>
<li>先序遍历序列中，第一个结点时根结点；</li>
<li>根节点将中序遍历序列划分成为两部分；</li>
<li>再先序遍历中确定两部分的结点，两部分的第一个结点分别为左子树、右子树的根；</li>
<li>再子树递归重复过程中，便可以唯一确定一棵二叉树。</li>
</ol>
<p><strong>过程：</strong></p>
<ol>
<li><p>先序遍历序列中的第一个结点为二叉树根结点；在中序遍历序列中找出根结点——将中序遍历序列划分成：左子树中序遍历+右子树中序遍历；</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat.png" style="width: 50%"></p>
</li>
<li><p>由左子树的遍历序列和右子树的遍历序列找出所有左子树结点和右子树结点，并在先序遍历中确立它们的位置；</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat1.png" style="width: 50%"></p>
</li>
<li><p>继续执行该过程，找出左子树和右子树先序遍历的第一个结点：分别为左子树根结点和右子树根结点；</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat2.png" style="width: 50%"></p>
</li>
<li><p>重复执行该过程，就可以确定一棵二叉树。</p>
</li>
</ol>
<p><strong>例子：</strong></p>
<p>先序遍历：1，2，4，5，3，6；中序遍历：4，2，5，1，6，3。</p>
<ol>
<li><p>找出先序遍历的第一个结点，为二叉树的根结点（1）；</p>
</li>
<li><p>在中序遍历中找到该结点，将其划分为左子树（4，2，5）和右子树（6，3）；</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat_eg1.png" style="width: 30%"></p>
</li>
<li><p>依次找出左子树的根结点（2），并在中序遍历序列中找到该结点的左子树（4）和右子树（5）；</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat_eg2.png" style="width: 30%"></p>
</li>
<li><p>按照同样的方法操作右子树，右子树根结点为 3，在中序遍历序列中找到该结点的左子树（6）和右子树（空）。</p>
<p><img src="/2020/06/01/DataStructure-BiTree-trav/tree_creat_eg3.png" style="width: 30%"></p>
</li>
</ol>
<p><strong>层次遍历序列和中序遍历序列也可以构造出二叉树。</strong></p>
<h3 id="leetcode重建二叉树"><a href="#leetcode重建二叉树" class="headerlink" title="leetcode重建二叉树"></a>leetcode重建二叉树</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。</span><br><span class="line">假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line">	前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">	中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">	</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ol>
<li>需要找中序遍历中元素的Index，可以建立值与Index的映射（哈希表）：Key=前序遍历的val；Value=中序遍历的Index，并对这个哈希表进行维护；</li>
<li>6个参数：前序——左、右子树的起始位置（preLeft，preRight）；中序——左、右子树对应的下标范围（preorder[]、inorder[]、inLeft、inRight）；</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署到Github</title>
    <url>/2020/05/31/MarkdownGithub/</url>
    <content><![CDATA[<p>我真的太难了，下次再更新吧！</p>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Hexo建站</title>
    <url>/2020/05/31/Markdown/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=23303987&bvid=BV1WW411F7qn&cid=38819312&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500"> </iframe>

<a id="more"></a>
<p>&emsp;&emsp;啊，Hexo建站这件事情，真的是让人头疼了一下。哈哈哈！不过好在对于我这种菜鸟来说，先整点简单的吧！以后再慢慢整好看的样式啥的！具体可以参考b站一个up主的教程和网上的各种教程（b站课可真是一个名副其实的学习网站！！）在次进行一个整理~~针对部署到Github上的不用给钱稍微优点慢的博客，哈哈</p>
<hr>
<h3 id="GitHub账号申请"><a href="#GitHub账号申请" class="headerlink" title="GitHub账号申请"></a><strong>GitHub账号申请</strong></h3><p>&emsp;&emsp;首先，申请一个Github账号：<a href="https://github.com/join，根据提示完成邮箱验证啥的" target="_blank" rel="noopener">https://github.com/join，根据提示完成邮箱验证啥的</a></p>
<p><img src="/2020/05/31/Markdown/creatGithub.png" style="width: 50%"></p>
<h3 id="新建博客仓库"><a href="#新建博客仓库" class="headerlink" title="新建博客仓库"></a><strong>新建博客仓库</strong></h3><p>&emsp;&emsp;点击New repository，创建一个新仓库，仓库名必须要遵守格式：<strong>Github用户名.github.io</strong>，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a>。并且需要勾选Initialize this repository with a README。如下图所示</p>
<p><img src="/2020/05/31/Markdown/setName.png" style="width: 50%"></p>
<p>&emsp;&emsp;在建好的仓库右侧有个settings按钮，点击它，向下拉到GitHub Pages，选择一个主题：</p>
<p><img src="/2020/05/31/Markdown/settheme.png" style="width: 70%"></p>
<p><img src="/2020/05/31/Markdown/settheme1.png" style="width: 70%"></p>
<p>&emsp;&emsp;返回就可以看到有个网址：</p>
<p><img src="/2020/05/31/Markdown/settheme2.png" style="width: 70%"></p>
<p>&emsp;&emsp;点击网址就可以访问你的博客啦！！</p>
<p><img src="/2020/05/31/Markdown/settheme3.png"></p>
<hr>
<h3 id="Node-js、Git"><a href="#Node-js、Git" class="headerlink" title="Node.js、Git"></a><strong>Node.js、Git</strong></h3><p>确保你的电脑上已经安装好了<strong>git</strong>和<strong>Node.js</strong>。可以在控制台输入：node -v、git —version进行查看：</p>
<p><img src="/2020/05/31/Markdown/cmd.png"></p>
<p>Node.js  <a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装教程</a></p>
<hr>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h3><ol>
<li><p>在你的电脑里面找一个合适的地方创建文件夹Blog（我的在E盘）：</p>
<p><img src="/2020/05/31/Markdown/blogfile.png"></p>
</li>
<li><p>在Blog文件夹下进入控制台，输入npm install hexo -g，安装Hexo；控制台输入：hexo -v查看是否安装成功：</p>
<p><img src="/2020/05/31/Markdown/hexo-v.png"></p>
</li>
<li><p>初始化博客：在Blog文件夹下，进入控制台输入：hexo init如下图进行初始化（看到后面的“Start blogging with Hexo！”就说明初始化好了）：</p>
<p><img src="/2020/05/31/Markdown/initial.png" style="width: 70%"></p>
</li>
<li><p>输入npm install，安装所需要的组件（Blog文件夹就新增了配置博客需要的内容）</p>
<p><img src="/2020/05/31/Markdown/blogcontent.png" style="width: 70%"></p>
</li>
<li><p>安装好了之后，执行以下命令：hexo g，用于生成静态文件；hexo s，用于启动服务器：</p>
<p><img src="/2020/05/31/Markdown/hexogs.png" style="width: 70%"></p>
</li>
<li><p>就可以在指定端口访问博客了！！！</p>
<p><img src="/2020/05/31/Markdown/blogpage.png"></p>
</li>
</ol>
<hr>
<h3 id="博客主题修改"><a href="#博客主题修改" class="headerlink" title="博客主题修改"></a>博客主题修改</h3><p>个人感觉Next主题比较简约好看，可以从<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">这里</a>下载Next主题，将解压的文件夹重命名为next，然后放在Blog的Theme文件夹下（默认是landscape主题）：</p>
<p><img src="/2020/05/31/Markdown/next.png" style="width: 50%"></p>
<p>修改Blog文件夹下的_config.yml文件配置，找到theme，将其修改为next：</p>
<p><img src="/2020/05/31/Markdown/next_1.png" style="width: 50%"></p>
<p>重新生成静态文件：hexo g；并启动服务器：hexo s就可以看到更换主题的博客了。next提供不同的外观，在Blog\theme\next_config.yml文件中配置不同的Scheme参数（Muse、Mist、Pisces、Genini）即可：</p>
<p>scheme：Muse：<img src="/2020/05/31/Markdown/nextdone.png"></p>
<p>scheme: Mist：<img src="/2020/05/31/Markdown/next_Mist.png"></p>
<p>scheme: Pisces：<img src="/2020/05/31/Markdown/next_Pisces.png"></p>
<p>scheme: Genini：<img src="/2020/05/31/Markdown/next_Genini.png"></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——二叉树存储结构</title>
    <url>/2020/05/31/DataStructure-Tree-1-0531/</url>
    <content><![CDATA[<p><img src="/2020/05/31/DataStructure-Tree-1-0531/tree_save_2.png" style="width: 50%"></p>
<h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>用一组连续的存储单元依次<strong>自上而下</strong>、<strong>自左向右</strong>存储完全二叉树上的结点元素。</p>
<p><strong>完全二叉树</strong>：依次编号，结点$i$，左孩子$2i$，右孩子$2i+1$。</p>
<p><img src="/2020/05/31/DataStructure-Tree-1-0531/tree_save_2.png" style="width: 50%"></p>
<p><strong>非完全二叉树</strong>：无法进行存储，可将其补成完全二叉树，空结点为$0$</p>
<p><img src="/2020/05/31/DataStructure-Tree-1-0531/tree_save_3.png" style="width: 50%"></p>
<font color="red">**缺点**：占用内存空间较多，适用于完全二叉树</font>

<p><img src="/2020/05/31/DataStructure-Tree-1-0531/tree_save_4.png" style="width: 50%"></p>
<hr>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a><strong>链式存储</strong></h3><p>用链表来存放二叉树，二叉树中每个结点用链表一个链结点来存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;     <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">// 保存孩子结点</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/31/DataStructure-Tree-1-0531/tree_save_5.png" style="width: 50%"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——二叉树的概念</title>
    <url>/2020/05/31/DataStructure-Tree-0531/</url>
    <content><![CDATA[<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_1.png" style="width: 50%"></p>
<a id="more"></a>
<p>树是一种典型的数据结构（逻辑结构），可以用来描述分支结构，属于一种<strong>分层、非线性结构</strong>。树的定义是递归的，因此树是一种递归的数据结构。每个结点有唯一的前驱结点，有一个或多个后继结点。（$n$个节点有$n-1$条边）</p>
<h3 id="基本术语："><a href="#基本术语：" class="headerlink" title="基本术语："></a><strong>基本术语：</strong></h3><ol>
<li><strong>度</strong>：结点的子结点的个数；</li>
<li><strong>树的度</strong>：树种最大的度数；</li>
<li><strong>分支结点</strong>：度大于$0$的结点；</li>
<li><strong>叶子结点</strong>：度为$0$的结点；</li>
<li><strong>结点层次</strong>：根结点为第一层，往下递增；</li>
<li><strong>结点高度</strong>：从<strong>叶结点</strong>开始自底向上逐层累加；</li>
<li><strong>结点深度</strong>：从<strong>根结点</strong>自顶向下逐层累加；</li>
<li><strong>树的高度（深度）</strong>：树中结点的最大层数；</li>
<li><strong>有序树</strong>：从左到右，子树有序；交换子结点位置树不同；</li>
<li><strong>无序树</strong>：交换子结点后树是相同的；</li>
<li><strong>路径</strong>：两个结点之间所经过的节点序列，不包含边；路径是<strong>自上而下</strong>的（树的分支是有向的：从双亲指向孩子）；</li>
<li><strong>路径长度</strong>：路径上经历的边的数量；</li>
<li><strong>森林</strong>：m棵互不相交的树的集合；</li>
</ol>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a><strong>性质：</strong></h3><ol>
<li><p>树中的结点数=所有结点度数（等价于所有的非根结点数）$+1$</p>
</li>
<li><p>度为$m$的树中第$i$层至多有：$m^{i-1}$个结点</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_2.png" style="width: 50%"></p>
</li>
<li><p>高度为$h$的$m$叉树至多有$(m^h-1)/(m-1)$个结点</p>
</li>
<li><p>具有$n$个结点的$m$叉树的最小高度为$log_m(n(m-1)+1)$（向上取整）</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_3.png" style="width: 50%"></p>
</li>
</ol>
<h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a><strong>二叉树：</strong></h3><p><strong>五种基本形态：</strong>空树、根节点、根节点-左子树、根节点-右子树、根节点-左子树-右子树</p>
<p><strong>二叉树  vs  度为2的有序树：</strong></p>
<ol>
<li>二叉树可以为空，度为2的有序树至少有3个结点</li>
<li>二叉树孩子结点有左右之分，度为2的有序树的孩子结点次序是相对的（一个结点的时候，不区分左右）</li>
</ol>
<h3 id="特殊二叉树："><a href="#特殊二叉树：" class="headerlink" title="特殊二叉树："></a><strong>特殊二叉树：</strong></h3><ol>
<li><p><strong>满二叉树</strong>：高度为$h$，含有$2^h-1$个结点（公式$(m^h-1)/(m-1)$ ，$m=2$），每一层都有最多结点，最后一层全是叶子结点。<strong>结点$i$：左孩子$2i$，右孩子$2i+1$</strong>；孩子结点$i$存在，双亲编号为$i/2$ 取整数</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_man1.png" style="width: 50%"></p>
</li>
<li><p><strong>完全二叉树：</strong>高度为$h$，有$n$个结点的二叉树，当且仅当每个结点高度为$h$的<strong>满二叉树</strong>中编号$1-n$的结点一一对应（不能产生错位，即满二叉树的子集）。</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_wanquan.png" style="width: 50%"></p>
<ul>
<li>若$i\le n/2$，则结点$i$为分支结点，否则为叶子结点；（$i=n/2$为最后一个结点的双亲结点，比该结点的双亲结点小，则为分支结点（1、2、3、4、5），大则为叶子结点（7、8、9、10、11、12））</li>
<li>叶子结点只可能在层次最大的两层上出现。对于最大层次的叶子结点（8、9、10、11、12），都一此排在左边位置上。</li>
<li>度为$1$的结点若存在，则可能有一个，且是编号最大的分支结点（6），并且孩子结点一定是左结点。</li>
</ul>
</li>
<li><p><strong>二叉排序树：</strong>一棵二叉树，若树非空则具有性质——对任意结点存在左子树或又子树，则其左子树上左右关键字均<strong>小于</strong>该结点，右子树上所有结点的关键字均<strong>大于</strong>该结点。</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_paixv.png" style="width: 50%"></p>
</li>
<li><p><strong>平衡二叉树：</strong>树上<strong>任意结点</strong>（非根节点）的左子树和右子树的深度之差不超过$1$（蓝色）。</p>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_pingheng.png" style="width: 50%"></p>
</li>
</ol>
<h3 id="二叉树性质："><a href="#二叉树性质：" class="headerlink" title="二叉树性质："></a><strong>二叉树性质：</strong></h3><ol>
<li>非空二叉树的叶子结点数等于度为$2$的结点数$+1$，即$n_0=n_2+1$。（$n=n_0+n_1+n_2$）</li>
<li>非空二叉树上第$k$层上至多有$2^(k-1)$个结点（$k\geq0$）</li>
<li>高度为$h$的二叉树至多有$2^h-1$个结点（$h\geq0$）</li>
</ol>
<p><img src="/2020/05/31/DataStructure-Tree-0531/tree_xingzhi1.png" style="width: 30%"><img src="/2020/05/31/DataStructure-Tree-0531/tree_xingzhi2.png" style="width: 30%"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记一</title>
    <url>/2020/05/29/note_1/</url>
    <content><![CDATA[<h3 id="1-数据传输的方式"><a href="#1-数据传输的方式" class="headerlink" title="1. 数据传输的方式"></a><strong>1. 数据传输的方式</strong></h3><p>​        数据传输方式（data transmission mode），是<strong>数据在信道上传送所采取的方式</strong>：<br>​        1）若按数据传输的<strong>顺序</strong>可以分为<strong>并行传输</strong>和<strong>串行传输</strong>；<br>​        2）若按数据传输的<strong>同步方式</strong>可分为<strong>同步传输</strong>和<strong>异步传输</strong>；<br>​        3）若按数据传输的<strong>流向和时间关系</strong>可以分为<strong>单工</strong>、<strong>半双工</strong>和<strong>全双工</strong>数据传输。</p>
<a id="more"></a>
<h3 id="2-高速缓冲区-ARP"><a href="#2-高速缓冲区-ARP" class="headerlink" title="2. 高速缓冲区 ARP"></a><strong>2. 高速缓冲区 ARP</strong></h3><p>​        ARP缓存是一个缓冲区，用来储存IP地址和MAC地址，本质就是<strong><IP地址，MAC地址></IP地址，MAC地址></strong>的对应表。表中一个条目记录了网络上<strong>一个主机的IP地址和其对应的MAC地址</strong>。</p>
<p>​        缓冲区是<strong>动态分配</strong>的，当ARP表访问一次MAC地址就会产生，将IP地址与Mac的映射存储起来。并不是人工产生的，它是随MAC的访问自动产生的。</p>
<h3 id="3-无分类IP地址"><a href="#3-无分类IP地址" class="headerlink" title="3. 无分类IP地址"></a><strong>3. 无分类IP地址</strong></h3><p>​        无分类编制CIDR：网络前缀越少，包含的地址越多。（待补充）</p>
<p>​        I<strong>P地址的分类</strong>：        </p>
<p>​        A类网络的IP地址范围为：1.0.0.0      －  127.255.255.255，掩码：255.0.0.0；  </p>
<p>​        B类网络的IP地址范围为：128.0.0.0  －  191.255.255.255，掩码：255.255.0.0； </p>
<p>​        C类网络的IP地址范围为：192.0.0.0  －  223.255.255.255，掩码：255.255.255.0。</p>
<h3 id="4-进程挂起、退出、阻塞、就绪"><a href="#4-进程挂起、退出、阻塞、就绪" class="headerlink" title="4. 进程挂起、退出、阻塞、就绪"></a><strong>4. 进程挂起、退出、阻塞、就绪</strong></h3><p>​        <strong>进程挂起</strong>：终端用户的请求、父进程的请求、负荷调节的需要、操作系统的需要。(检查运行中的资源使用情况或进行记账)</p>
<p>​        <strong>进程退出</strong>：exit和return ： exit是一个函数，有参数。exit执行完后把控制权交给系统；return是函数执行完后的返回。return执行完后把控制权交给调用函数。exit和abort：exit是正常终止进程；abort是异常终止。</p>
<p>​        <strong>进程阻塞</strong>：正在执行的进程，由于等待某个事件的发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如：等待I/O完成、申请缓冲区不能满足、等待信号等。</p>
<p>​        <strong>进程就绪</strong>：运行态——就绪态：运行时间片到，或出现有更高优先权进程。等待态——就绪态：资源得到满足或某事件己经发生，如外设传输结束；人工干预完成。</p>
<p>​        <strong>进程死锁</strong>：竞争资源、进程间推进顺序非法。</p>
<h3 id="5-OSI、TCP-IP每一层数据的传输格式"><a href="#5-OSI、TCP-IP每一层数据的传输格式" class="headerlink" title="5. OSI、TCP/IP每一层数据的传输格式"></a><strong>5. OSI、TCP/IP每一层数据的传输格式</strong></h3><p>​        计算机网络通常由三个部分组成：资源子网、通信子网和通信协议。</p>
<p>​        <strong>OSI:</strong></p>
<p>​        物理层——比特流<br>​        数据链路层——帧<br>​        网络层——包<br>​        传输层——段/消息<br>​        表示层——字符或字<br>​        应用层——程序</p>
<p>​        <strong>TCP/IP：（四层）</strong></p>
<p>​        应用层——报文</p>
<p>​        运输层——传输层协议</p>
<p>​        网际层——数据报</p>
<p>​        网络接口层——网络帧</p>
<h3 id="6-排序算法复杂度"><a href="#6-排序算法复杂度" class="headerlink" title="6. 排序算法复杂度"></a><strong>6. 排序算法复杂度</strong></h3><p>​        <strong>快速排序——时间复杂度为O(nlog2n)，空间复杂度为O(nlog2n)</strong>：从数列选定一个基准值进行分区，大于基准值的放在右区，小于基准值的放在左区，依次继续对左右两区继续进行基准分区，直到分区中只有一个数为止。</p>
<p>​        <strong>归并排序——时间复杂度为O(nlog2n)，空间复杂度为O(n)</strong>：分而治之然后合并，即先使每个子序列有序，再使子序列段间有序，最后合并各个有序的子序列为有序的完整序列。</p>
<p>​        <strong>堆排序——时间复杂度O(nlog2n),空间复杂度为O(1)</strong>：利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征。</p>
<p>​        <strong>选择排序——时间复杂度为O(n2),空间复杂度为O(1)</strong>：每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<h3 id="7-文件block"><a href="#7-文件block" class="headerlink" title="7. 文件block"></a><strong>7. 文件block</strong></h3><p>​        文件系统中的<strong>最小存储单元</strong>是逻辑块，也就是这里所说的Block；</p>
<p>​        block越大，inode越少，适合存储<strong>大文件</strong>的文件系统；</p>
<p>​        block越小，inode越多，适合存储文件<strong>多而小</strong>的文件系统。<br>​        block存放文件的数据，每个block最多存放一个文件，而当一个block存放不下的情况下，会占用下一个block。</p>
<h3 id="8-排序算法特征度"><a href="#8-排序算法特征度" class="headerlink" title="8. 排序算法特征度"></a><strong>8. 排序算法特征度</strong></h3><p>​        <strong>冒泡排序</strong>：第一趟排序之后最大值会在最后面，第二趟排序会在次后面</p>
<p>​        <strong>选择排序</strong>：第一趟排序之后最小值会在最前面，第二趟排序会在次前面<br>​        <strong>插入排序</strong>：第一趟排序范围0-1,前一个数比后一个数小，第二趟排序范围0-2，前三个数小大排列<br>​        <strong>快速排序</strong>：以一个值为分界点</p>
<h3 id="9-线性表存储方式"><a href="#9-线性表存储方式" class="headerlink" title="9. 线性表存储方式"></a><strong>9. 线性表存储方式</strong></h3><p>​        线性表包括<strong>顺序结构</strong>和<strong>链式结构</strong>，顺序结构逻辑相邻且物理位置相邻，链式结构逻辑相邻，物理不一定相邻。</p>
<p>​        静态链表是用数组实现链表，指针表示下标。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——链表</title>
    <url>/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=29912609&cid=52105892&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<a id="more"></a>
<h1 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h1><p>&emsp;&emsp;  包含8道链表常考题目，如下：</p>
<h2 id="206-反转链表（easy）"><a href="#206-反转链表（easy）" class="headerlink" title="206  反转链表（easy）"></a>206  反转链表（easy）</h2><p>&emsp;&emsp;  <strong>题目描述：</strong> 反转一个单链表。<br>&emsp;&emsp;  <strong>示例：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;  <strong>思路：</strong> 依次遍历链表节点，每遍历一个节点即逆置一个节点。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list1.PNG"></center></td>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list2.PNG"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list3.PNG"></center></td>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list4.PNG"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list5.PNG"></center></td>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list6.PNG"></center></td>
    </tr>
</table>


<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">reverseListNode</span> <span class="params">( ListNode* head )</span> </span>&#123;</span><br><span class="line">		ListNode* new_head = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> ( head ) &#123;</span><br><span class="line">			ListNode* next = head -&gt; next;   <span class="comment">// 备份 head-&gt;next</span></span><br><span class="line">			head -&gt; next = new_head;          <span class="comment">// 更新 head-&gt;next</span></span><br><span class="line">			new_head = head;                    <span class="comment">// 移动 new_head</span></span><br><span class="line">			head = next; 					<span class="comment">// 遍历链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> new_head;				<span class="comment">//返回新链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="91-反转链表-（medium）"><a href="#91-反转链表-（medium）" class="headerlink" title="91  反转链表||（medium）"></a>91  反转链表||（medium）</h2><p>&emsp;&emsp;  <strong>题目描述：</strong> 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>&emsp;&emsp;  <strong>说明：</strong> 1 ≤ m ≤ n ≤ 链表长度。<br>&emsp;&emsp;  <strong>示例：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">输出：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;  <strong>思路：</strong> 依次遍历链表节点，每遍历一个节点即逆置一个节点。</p>
<table border="0">
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list7.PNG"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list7.PNG"></center></td>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list8.PNG"></center></td>
    </tr>
    <tr>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list9.PNG"></center></td>
        <td><center><img src="/2020/03/13/LeetCode%E9%93%BE%E8%A1%A8/list10.PNG"></center></td>
    </tr>
</table>


<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> change_len = n - m + <span class="number">1</span>;</span><br><span class="line">        ListNode* pre_head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* result = head;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; --m)&#123;</span><br><span class="line">            pre_head = head;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* modify_list_tail = head;</span><br><span class="line">        ListNode* new_head = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; change_len)&#123;</span><br><span class="line">            ListNode* next = head -&gt; next;</span><br><span class="line">            head -&gt; next = new_head;</span><br><span class="line">            new_head = head;</span><br><span class="line">            head = next;</span><br><span class="line">            change_len--;</span><br><span class="line">        &#125;</span><br><span class="line">        modify_list_tail -&gt; next = head;</span><br><span class="line">        <span class="keyword">if</span>(pre_head)&#123;</span><br><span class="line">            pre_head -&gt; next = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           result = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏数值策划</title>
    <url>/2020/03/12/%E6%B8%B8%E6%88%8F%E6%95%B0%E5%80%BC%E7%AD%96%E5%88%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>游戏策划</category>
      </categories>
      <tags>
        <tag>游戏策划</tag>
      </tags>
  </entry>
</search>
